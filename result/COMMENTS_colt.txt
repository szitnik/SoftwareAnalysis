#CANONICAL_CLASS_NAME "AUTHOR"
cern.clhep.PhysicalConstants "high energy physics coherent physical constants. this class is a java port of the c++ version found in clhep 1.4.0, which in turn has been provided by geant4 (a simulation toolkit for hep).  for aliasing see {@link #physicalconstants}. little trick to allow for "aliasing", that is, renaming this class. normally you would write  physicalconstants.twopi; physicalconstants.c_light; physicalconstants.h_planck;  since this class has only static methods, but no instance methods you can also shorten the name "physicalconstants" to a name that better suits you, for example "p".  physicalconstants p = physicalconstants.physicalconstants; // kind of "alias" p.twopi; p.c_light; p.h_planck;  makes this class non instantiable, but still let's others inherit from it. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/units/physicalconstants_h.html">c++ version found in clhep 1.4.0, which in turn has been provided by geant4 (a simulation toolkit for hep). kind of "alias"    3.14159265358979323846;     c = 299.792458 mm/ns c^2 = 898.7404 (mm/ns)^2   h = 4.13566e-12 mevns hbar = 6.58212e-13 mevns hbarc = 197.32705e-12 mevmm     see systemofunits.h  amu_c2 - atomic equivalent mass unit amu - atomic mass unit   permeability of free space mu0 = 2.01334e-16 mev(nseplus)^2/mm permittivity of free space epsil0 = 5.52636e+10 eplus^2/(mevmm)   electromagnetic coupling = 1.43996e-12 mevmm/(eplus^2)"
cern.clhep.Units "high energy physics coherent system of units. this class is a java port of the c++ version found in clhep 1.4.0, which in turn has been provided by geant4 (a simulation toolkit for hep). makes this class non instantiable, but still let's others inherit from it. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/units/systemofunits_h.html">c++ version found in clhep 1.4.0, which in turn has been provided by geant4 (a simulation toolkit for hep). symbols  angle  (3.14159265358979323846/180.0)radian; symbols  time [t]  symbols  electric charge [q]  positron charge positron charge in coulomb coulomb = 6.24150 e+18 eplus  energy [e]  joule = 6.24150 e+12 mev symbols  mass [e][t^2][l^-2]  symbols  power [e][t^-1]  watt = 6.24150 e+3 mev/ns  force [e][l^-1]  newton = 6.24150 e+9 mev/mm  pressure [e][l^-3]  pascal = 6.24150 e+3 mev/mm3 bar = 6.24150 e+8 mev/mm3 atm = 6.32420 e+8 mev/mm3  electric current [q][t^-1]  ampere = 6.24150 e+9 eplus/ns  electric potential [e][q^-1]   electric resistance [e][t][q^-2]  ohm = 1.60217e-16(mev/eplus)/(eplus/ns)  electric capacitance [q^2][e^-1]  farad = 6.24150e+24 eplus/megavolt  magnetic flux [t][e][q^-1]  weber = 1000megavoltns  magnetic field [t][e][q^-1][l^-2]  tesla =0.001megavoltns/mm2  inductance [t^2][e][q^-2]  henry = 1.60217e-7mev(ns/eplus)2  temperature   amount of substance   activity [t^-1]   absorbed dose [l^2][t^-2]   luminous intensity [i]   luminous flux [i]   illuminance [i][l^-2]   miscellaneous"
cern.colt.Arrays "array manipulations; complements java.util.arrays. @see java.util.arrays @see cern.colt.sorting makes this class non instantiable, but still let's others inherit from it. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. ensures that a given array can hold up to mincapacity elements. returns the identical array if it can hold at least the number of elements specified. otherwise, returns a new array with increased capacity containing the same elements, ensuring that it can hold at least the number of elements specified by the minimum capacity argument. mincapacity the desired minimum capacity. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. ensures that the specified array cannot hold more than maxcapacity elements. an application can use this operation to minimize array storage.  returns the identical array if array.length &lt;= maxcapacity. otherwise, returns a new array with a length of maxcapacity containing the first maxcapacity elements of array. maxcapacity the desired maximum capacity. for (int i = oldcapacity; --i >= 0; ) newarray[i] = array[i];"
cern.colt.bitvector.BitMatrix "fixed sized (non resizable) nm bit matrix. a bit matrix has a number of columns and rows, which are assigned upon instance construction - the matrix's size is then columns()rows(). bits are accessed via (column,row) coordinates.  individual bits can be examined, set, or cleared. rectangular parts (boxes) can quickly be extracted, copied and replaced. quick iteration over boxes is provided by optimized internal iterators (foreach() methods). one bitmatrix may be used to modify the contents of another bitmatrix through logical and, or, xor and other similar operations.  legal coordinates range from [0,0] to [columns()-1,rows()-1]. any attempt to access a bit at a coordinate column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() will throw an indexoutofboundsexception. operations involving two bit matrices (like and, or, xor, etc.) will throw an illegalargumentexception if both bit matrices do not have the same number of columns and rows.  if you need extremely quick access to individual bits: although getting and setting individual bits with methods get(...) and put(...) is quick, it is even quicker (but not safe) to use getquick(...) and putquick(...).  note that this implementation is not synchronized. the bits of this matrix. bits are stored in row major, i.e. bitindex==rowcolumns + column columnof(bitindex)==bitindex%columns rowof(bitindex)==bitindex/columns constructs a bit matrix with a given number of columns and rows. all bits are initially false. the number of columns the matrix shall have. the number of rows the matrix shall have. @throws illegalargumentexception if columns &lt; 0 || rows &lt; 0. performs a logical and of the receiver with another bit matrix. the receiver is modified so that a bit in it has the value true if and only if it already had the value true and the corresponding bit in the other bit matrix argument has the value true. other a bit matrix. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows(). clears all of the bits in receiver whose corresponding bit is set in the other bit matrix. in other words, determines the difference (a\b) between two bit matrices. other a bit matrix with which to mask the receiver. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows(). returns the number of bits currently in the true state. optimized for speed. particularly quick if the receiver is either sparse or dense. sanity check for operations requiring matrices with the same number of columns and rows. clears all bits of the receiver. cloning this bitmatrix produces a new bitmatrix that is equal to it. the clone of the bit matrix is another bit matrix that has exactly the same bits set to true as this bit matrix and the same number of columns and rows. a clone of this bit matrix. returns the number of columns of the receiver. checks whether the receiver contains the given box. returns a shallow clone of the receiver; calls clone() and casts the result. a shallow clone of the receiver. you normally need not use this method. use this method only if performance is critical. sets the bit matrix's backing bits, columns and rows. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. @throws illegalargumentexception if columns &lt; 0 || rows &lt; 0 || columnsrows &gt; bits.length64 compares this object against the specified object. the result is true if and only if the argument is not null and is a bitmatrix object that has the same number of columns and rows as the receiver and that has exactly the same bits set to true as the receiver. obj the object to compare with. true if the objects are the same; false otherwise. applies a procedure to each coordinate that holds a bit in the given state. iterates rowwise downwards from [columns()-1,rows()-1] to [0,0]. useful, for example, if you want to copy bits into an image or somewhere else. optimized for speed. particularly quick if one of the following conditions holds  state==true and the receiver is sparse (cardinality() is small compared to size()). state==false and the receiver is dense (cardinality() is large compared to size()).  element to search for. a procedure object taking as first argument the current column and as second argument the current row. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. this is equivalent to the low level version below, apart from that it iterates in the reverse oder and is slower. if (size()==0) return true; bitvector vector = tobitvector(); return vector.foreachindexfromtoinstate(0,size()-1,state, new cern.colt.function.intfunction() { public boolean apply(int index) { return function.apply(index%columns, index/columns); } } ); returns from the receiver the value of the bit at the specified coordinate. the value is true if this bit is currently set; otherwise, returns false. column the index of the column-coordinate. row the index of the row-coordinate. the value of the bit at the specified coordinate. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() returns from the receiver the value of the bit at the specified coordinate; warning: does not check preconditions. the value is true if this bit is currently set; otherwise, returns false. provided with invalid parameters this method may return invalid values without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): column&gt;=0 && column&lt;columns() && row&gt;=0 && row&lt;rows(). column the index of the column-coordinate. row the index of the row-coordinate. the value of the bit at the specified coordinate. returns a hash code value for the receiver. performs a logical not on the bits of the receiver. performs a logical or of the receiver with another bit matrix. the receiver is modified so that a bit in it has the value true if and only if it either already had the value true or the corresponding bit in the other bit matrix argument has the value true. other a bit matrix. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows(). constructs and returns a new matrix with width columns and height rows which is a copy of the contents of the given box. the box ranges from [column,row] to [column+width-1,row+height-1], all inclusive. column the index of the column-coordinate. row the index of the row-coordinate. width the width of the box. height the height of the box. @throws indexoutofboundsexception if column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows() sets the bit at the specified coordinate to the state specified by value. column the index of the column-coordinate. row the index of the row-coordinate. value the value of the bit to be copied into the specified coordinate. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() sets the bit at the specified coordinate to the state specified by value; warning: does not check preconditions. provided with invalid parameters this method may return invalid values without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): column&gt;=0 && column&lt;columns() && row&gt;=0 && row&lt;rows(). column the index of the column-coordinate. row the index of the row-coordinate. value the value of the bit to be copied into the specified coordinate. replaces a box of the receiver with the contents of another matrix's box. the source box ranges from [sourcecolumn,sourcerow] to [sourcecolumn+width-1,sourcerow+height-1], all inclusive. the destination box ranges from [column,row] to [column+width-1,row+height-1], all inclusive. does nothing if width &lt;= 0 || height &lt;= 0. if source==this and the source and destination box intersect in an ambiguous way, then replaces as if using an intermediate auxiliary copy of the receiver. column the index of the column-coordinate. row the index of the row-coordinate. width the width of the box. height the height of the box. source the source matrix to copy from(may be identical to the receiver). sourcecolumn the index of the source column-coordinate. sourcerow the index of the source row-coordinate. @throws indexoutofboundsexception if column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows() @throws indexoutofboundsexception if sourcecolumn&lt;0 || sourcecolumn+width&gt;source.columns() || sourcerow&lt;0 || sourcerow+height&gt;source.rows() sets the bits in the given box to the state specified by value. the box ranges from [column,row] to [column+width-1,row+height-1], all inclusive. (does nothing if width &lt;= 0 || height &lt;= 0). column the index of the column-coordinate. row the index of the row-coordinate. width the width of the box. height the height of the box. value the value of the bit to be copied into the bits of the specified box. @throws indexoutofboundsexception if column&lt;0 || column+width&gt;columns() || row&lt;0 || row+height&gt;rows() returns the number of rows of the receiver. returns the size of the receiver which is columns()rows(). converts the receiver to a bitvector. in many cases this method only makes sense on one-dimensional matrices. warning: the returned bitvector and the receiver share the same backing bits. modifying either of them will affect the other. if this behaviour is not what you want, you should first use copy() to make sure both objects use separate internal storage. returns a (very crude) string representation of the receiver. performs a logical xor of the receiver with another bit matrix. the receiver is modified so that a bit in it has the value true if and only if one of the following statements holds:  the bit initially has the value true, and the corresponding bit in the argument has the value false. the bit initially has the value false, and the corresponding bit in the argument has the value true.  other a bit matrix. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows(). low level implementation for speed. for each coordinate of bits of partial unit for each coordinate of bits of full units all 64 bits set at least one element within current unit matches. iterate over all bits within current unit. unrolled comparison for speed. no element within current unit matches --> skip unit avoid implementation with , /, % dangerous intersection"
cern.colt.bitvector.BitVector "fixed sized (non resizable) bitvector. upon instance construction a bitvector is told to hold a fixed number of bits - it's size. the size can be any number (need not be a power of 2 or so). the bits of a bitvector are indexed by nonnegative integers. any attempt to access a bit at an index&lt;0 || index&gt;=size() will throw an indexoutofboundsexception.  individual indexed bits can be examined, set, or cleared. subranges can quickly be extracted, copied and replaced. quick iteration over subranges is provided by optimized internal iterators (foreach() methods). one bitvector may be used to modify the contents of another bitvector through logical and, or, xor and other similar operations.  all operations consider the bits 0..size()-1 and nothing else. operations involving two bitvectors (like and, or, xor, etc.) will throw an illegalargumentexception if the secondary bit vector has a size smaller than the receiver.  a bitvector is never automatically resized, but it can manually be grown or shrinked via setsize(...).  for use cases that need to store several bits per information entity, quick accessors are provided that interpret subranges as 64 bit long integers.  why this class? fist, boolean[] take one byte per stored bit. this class takes one bit per stored bit. second, many applications find the semantics of java.util.bitset not particularly helpful for their needs. third, operations working on all bits of a bitvector are extremely quick. for example, on nt, pentium pro 200 mhz, sunjdk1.2.2, java -classic, for two bitvectors a,b (both much larger than processor cache), the following results are obtained.  a.and(b) i.e. a = a & b --> runs at about 35 mb/sec a.cardinality(), i.e. determining the selectivity, the number of bits in state "true" --> runs at about 80 mb/sec similar performance for or, xor, andnot, not, copy, replace, partfromto, indexof, clear etc.  if you need extremely quick access to individual bits: although getting and setting individual bits with methods get(...), set(...) and put(...)is quick, it is even quicker (but not safe) to use getquick(...) and putquick(...) or even quickbitvector.  note that this implementation is not synchronized. bits are packed into arrays of "units." currently a unit is a long, which consists of 64 bits, requiring 6 address bits. the choice of unit is determined purely by performance concerns. the bits of this object. the ith bit is stored in bits[i/64] at bit position i % 64 (where bit position 0 refers to the least significant bit and 63 refers to the most significant bit). @serial you normally need not use this method. use this method only if performance is critical. constructs a bit vector with the given backing bits and size. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. a bitvector is modelled as a long array, i.e. long[] bits holds bits of a bitvector. each long value holds 64 bits. the i-th bit is stored in bits[i/64] at bit position i % 64 (where bit position 0 refers to the least significant bit and 63 refers to the most significant bit). @throws illegalargumentexception if size &lt; 0 || size &gt; bits.length64. constructs a bit vector that holds size bits. all bits are initially false. the number of bits the bit vector shall have. @throws illegalargumentexception if size &lt; 0. performs a logical and of the receiver with another bit vector (a = a & b). the receiver is modified so that a bit in it has the value true if and only if it already had the value true and the corresponding bit in the other bit vector argument has the value true. other a bit vector. @throws illegalargumentexception if size() &gt; other.size(). clears all of the bits in receiver whose corresponding bit is set in the other bitvector (a = a \ b). in other words, determines the difference (a=a\b) between two bitvectors. other a bitvector with which to mask the receiver. @throws illegalargumentexception if size() &gt; other.size(). returns the number of bits currently in the true state. optimized for speed. particularly quick if the receiver is either sparse or dense. checks if the given range is within the contained array's bounds. sanity check for operations requiring another bitvector with at least the same size. clears all bits of the receiver. changes the bit with index bitindex to the "clear" (false) state. bitindex the index of the bit to be cleared. @throws indexoutofboundsexception if bitindex&lt;0 || bitindex&gt;=size() cloning this bitvector produces a new bitvector that is equal to it. the clone of the bit vector is another bit vector that has exactly the same bits set to true as this bit vector and the same current size, but independent state. a deep copy of this bit vector. returns a deep copy of the receiver; calls clone() and casts the result. a deep copy of the receiver. you normally need not use this method. use this method only if performance is critical. returns the bit vector's backing bits. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. a bitvector is modelled as a long array, i.e. long[] bits holds bits of a bitvector. each long value holds 64 bits. the i-th bit is stored in bits[i/64] at bit position i % 64 (where bit position 0 refers to the least significant bit and 63 refers to the most significant bit). you normally need not use this method. use this method only if performance is critical. sets the bit vector's backing bits and size. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. a bitvector is modelled as a long array, i.e. long[] bits holds bits of a bitvector. each long value holds 64 bits. the i-th bit is stored in bits[i/64] at bit position i % 64 (where bit position 0 refers to the least significant bit and 63 refers to the most significant bit). the backing bits of the bit vector. the number of bits the bit vector shall hold. @throws illegalargumentexception if size &lt; 0 || size &gt; bits.length64. compares this object against the specified object. the result is true if and only if the argument is not null and is a bitvector object that has the same size as the receiver and the same bits set to true as the receiver. that is, for every nonnegative int index k, ((bitvector)obj).get(k) == this.get(k) must be true. obj the object to compare with. true if the objects are the same; false otherwise. applies a procedure to each bit index within the specified range that holds a bit in the given state. starts at index from, moves rightwards to to. useful, for example, if you want to copy bits into an image or somewhere else.  optimized for speed. particularly quick if one of the following conditions holds  state==true and the receiver is sparse (cardinality() is small compared to size()). state==false and the receiver is dense (cardinality() is large compared to size()).  the leftmost search position, inclusive. the rightmost search position, inclusive. element to search for. a procedure object taking as argument the current bit index. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. @throws indexoutofboundsexception if (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). // this version is equivalent to the low level version below, but about 100 times slower for large ranges. if (nbits==0) return true; checkrangefromto(from, to, nbits); final long[] thebits = this.bits; // cached for speed int length=to-from+1; for (int i=from; --length >= 0; i++) { if (quickbitvector.get(thebits,i)==state) { if (!function.apply(i)) return false; } } return true; this low level implementation exploits the fact that for any full unit one can determine in o(1) whether it contains at least one true bit, and whether it contains at least one false bit. thus, 64 bits can often be skipped with one simple comparison if the vector is either sparse or dense. however, careful coding must be done for leading and/or trailing units which are not entirely contained in the query range. returns from the bitvector the value of the bit with the specified index. the value is true if the bit with the index bitindex is currently set; otherwise, returns false. bitindex the bit index. the value of the bit with the specified index. @throws indexoutofboundsexception if bitindex&lt;0 || bitindex&gt;=size() returns a long value representing bits of the receiver from index from to index to. bits are returned as a long value with the return value having bit 0 set to bit from, ..., bit to-from set to bit to. all other bits of the return value are set to 0. if to-from+1==0 then returns zero (0l). index of start bit (inclusive). index of end bit (inclusive). specified bits as long value. @throws indexoutofboundsexception if from&lt;0 || from&gt;=size() || to&lt;0 || to&gt;=size() || to-from+164 returns from the bitvector the value of the bit with the specified index; warning: does not check preconditions. the value is true if the bit with the index bitindex is currently set; otherwise, returns false. provided with invalid parameters this method may return invalid values without throwing any exception. you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): bitindex &gt;= 0 && bitindex &lt; size(). bitindex the bit index. the value of the bit with the specified index. returns a hash code value for the receiver. the hash code depends only on which bits have been set within the receiver. the algorithm used to compute it may be described as follows. suppose the bits in the receiver were to be stored in an array of long integers called, say, bits, in such a manner that bit k is set in the receiver (for nonnegative values of k) if and only if the expression ((k&gt;&gt;6) &lt; bits.length) && ((bits[k&gt;&gt;6] & (1l &lt;&lt; (bit & 0x3f))) != 0) is true. then the following definition of the hashcode method would be a correct implementation of the actual algorithm:  public int hashcode() { long h = 1234; for (int i = bits.length; --i &gt;= 0; ) { h ^= bits[i] (i + 1); } return (int)((h &gt;&gt; 32) ^ h); } note that the hash code values change if the set of bits is altered. a hash code value for the receiver. returns the index of the first occurrence of the specified state. returns -1 if the receiver does not contain this state. searches between from, inclusive and to, inclusive.  optimized for speed. preliminary performance (200mhz pentium pro, jdk 1.2, nt): size=10^6, from=0, to=size-1, receiver contains matching state in the very end --> 0.002 seconds elapsed time. state to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception if (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). performs a logical not on the bits of the receiver (a = ~a). returns the number of bits used in the trailing partial unit. returns zero if there is no such trailing partial unit. returns the number of units that are full (not partial). performs a logical or of the receiver with another bit vector (a = a | b). the receiver is modified so that a bit in it has the value true if and only if it either already had the value true or the corresponding bit in the other bit vector argument has the value true. other a bit vector. @throws illegalargumentexception if size() &gt; other.size(). constructs and returns a new bit vector which is a copy of the given range. the new bitvector has size()==to-from+1. the start index within the receiver, inclusive. the end index within the receiver, inclusive. @throws indexoutofboundsexception if size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sets the bit with index bitindex to the state specified by value. bitindex the index of the bit to be changed. value the value to be stored in the bit. @throws indexoutofboundsexception if bitindex&lt;0 || bitindex&gt;=size() sets bits of the receiver from index from to index to to the bits of value. bit from is set to bit 0 of value, ..., bit to is set to bit to-from of value. all other bits stay unaffected. if to-from+1==0 then does nothing. the value to be copied into the receiver. index of start bit (inclusive). index of end bit (inclusive). @throws indexoutofboundsexception if from&lt;0 || from&gt;=size() || to&lt;0 || to&gt;=size() || to-from+164. sets the bit with index bitindex to the state specified by value; warning: does not check preconditions. provided with invalid parameters this method may set invalid values without throwing any exception. you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): bitindex &gt;= 0 && bitindex &lt; size(). bitindex the index of the bit to be changed. value the value to be stored in the bit. replaces the bits of the receiver in the given range with the bits of another bit vector. replaces the range [from,to] with the contents of the range [sourcefrom,sourcefrom+to-from], all inclusive. if source==this and the source and destination range intersect in an ambiguous way, then replaces as if using an intermediate auxiliary copy of the receiver.  optimized for speed. preliminary performance (200mhz pentium pro, jdk 1.2, nt): replace 10^6 ill aligned bits --> 0.02 seconds elapsed time. the start index within the receiver, inclusive. the end index within the receiver, inclusive. the source bitvector to copy from. the start index within source, inclusive. @throws indexoutofboundsexception if size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size() || sourcefromsource.size())). this version is equivalent to the version below but 20 times slower... for (int i=from; --length >= 0; i++, sourcefrom++) { quickbitvector.put(thebits,i,quickbitvector.get(sourcebits,sourcefrom)); } sets the bits in the given range to the state specified by value.  optimized for speed. preliminary performance (200mhz pentium pro, jdk 1.2, nt): replace 10^6 ill aligned bits --> 0.002 seconds elapsed time. the start index, inclusive. the end index, inclusive. the value to be stored in the bits of the range. @throws indexoutofboundsexception if size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size()). slower: for (int i=bitsperunit-fromoffset; --i >= 0; ) { quickbitvector.put(thebits,bitindex++,value); } slower: for (int i=tooffset+1; --i >= 0; ) { quickbitvector.put(thebits,bitindex++,value); } changes the bit with index bitindex to the "set" (true) state. bitindex the index of the bit to be set. @throws indexoutofboundsexception if bitindex&lt;0 || bitindex&gt;=size() shrinks or expands the receiver so that it holds newsize bits. if the receiver is expanded, additional false bits are added to the end. if the receiver is shrinked, all bits between the old size and the new size are lost; their memory is subject to garbage collection. (this method introduces a new backing array of elements. warning: if you have more than one bitvector or bitmatrix sharing identical backing elements, be sure you know what you are doing.) the number of bits the bit vector shall have. @throws illegalargumentexception if size &lt; 0. returns the size of the receiver. returns a string representation of the receiver. for every index for which the receiver contains a bit in the "set" (true) state, the decimal representation of that index is included in the result. such indeces are listed in order from lowest to highest, separated by ",&nbsp;" (a comma and a space) and surrounded by braces. a string representation of this bit vector. performs a logical xor of the receiver with another bit vector (a = a ^ b). the receiver is modified so that a bit in it has the value true if and only if one of the following statements holds:  the bit initially has the value true, and the corresponding bit in the argument has the value false. the bit initially has the value false, and the corresponding bit in the argument has the value true.  other a bit vector. @throws illegalargumentexception if size() &gt; other.size(). the size intprocedure for method indexoffromto(...) cached for speed. cached for speed. cached for speed. cached for speed. determine cardinality on full units all bits set? more than one bit set? determine cardinality on remaining partial unit, if any. new longarraylist(bits).fillfromtowith(0,size()-1,0l); perform logical comparison on full units perform logical comparison on remaining bits this version is equivalent to the low level version below, but about 100 times slower for large ranges. cached for speed system.out.println("\n"); system.out.println(this); system.out.println("from="+from+", to="+to+", bit="+state); cache some vars for speed. prepare current bitvector index iterate over the leading partial unit, if any. there exists a leading partial unit. system.out.println("partialwidth1="+partialwidth); leading partial unit is done. done if there is a trailing partial unit, then there is one full unit less to test. trailing partial unit needs to be tested extra. system.out.println("partialwidth2="+partialwidth); iterate over all full units, if any. (it does not matter that iterating over partial units is a little bit slow, the only thing that matters is that iterating over full units is quick.) all 64 bits set system.out.println("fromunit="+fromunit+", tounit="+tounit); at least one element within current unit matches. iterate over all bits within current unit. is bit set? is bit cleared? system.out.println("trail with i="+i); iterate over trailing partial unit, if any. cached for speed. cached for speed. dangerous intersection cached for speed. cached for speed. low level implementation for speed. this could be done even faster by implementing on even lower levels. but then the code would probably become a "don't touch" piece. width/64 copy entire 64 bit blocks, if any. copy trailing bits, if any. width%64 cached for speed only one unit to do slower: for (; bitindex<=to; ) quickbitvector.put(thebits,bitindex++,value); treat leading partial unit, if any. fix by olivier janssens there is a trailing partial unit treat full units, if any. treat trailing partial unit, if any. cached for speed. cached for speed."
cern.colt.bitvector.QuickBitVector "implements quick non polymorphic non bounds checking low level bitvector operations. includes some operations that interpret sub-bitstrings as long integers.  warning: methods of this class do not check preconditions. provided with invalid parameters these method may return (or set) invalid values without throwing any exception. you should only use this class when performance is critical and you are absolutely sure that indexes are within bounds.  a bitvector is modelled as a long array, i.e. long[] bits holds bits of a bitvector. each long value holds 64 bits. the i-th bit is stored in bits[i/64] at bit position i % 64 (where bit position 0 refers to the least significant bit and 63 refers to the most significant bit). makes this class non instantiable, but still inheritable. returns a bit mask with bits in the specified range set to 1, all the rest set to 0. in other words, returns a bit mask having 0,1,2,3,...,64 bits set. if to-from+1==0 then returns zero (0l). precondition (not checked): to-from+1 &gt;= 0 && to-from+1 &lt;= 64. index of start bit (inclusive) index of end bit (inclusive). bit mask having all bits between from and to set to 1. changes the bit with index bitindex in the bitvector bits to the "clear" (false) state. bits the bitvector. bitindex the index of the bit to be cleared. returns from the bitvector the value of the bit with the specified index. the value is true if the bit with the index bitindex is currently set; otherwise, returns false. bits the bitvector. bitindex the bit index. the value of the bit with the specified index. returns a long value representing bits of a bitvector from index from to index to. bits are returned as a long value with the return value having bit 0 set to bit from, ..., bit to-from set to bit to. all other bits of return value are set to 0. if from &gt; to then returns zero (0l). precondition (not checked): to-from+1 &lt;= 64. the bitvector. index of start bit (inclusive). index of end bit (inclusive). specified bits as long value. returns the index of the least significant bit in state "true". returns 32 if no bit is in state "true". examples:  0x80000000 --> 31 0x7fffffff --> 0 0x00000001 --> 0 0x00000000 --> 32  constructs a low level bitvector that holds size elements, with each element taking bitsperelement bits. size the number of elements to be stored in the bitvector (must be &gt;= 0). bitsperelement the number of bits one single element takes. a low level bitvector. returns the index of the most significant bit in state "true". returns -1 if no bit is in state "true". examples:  0x80000000 --> 31 0x7fffffff --> 30 0x00000001 --> 0 0x00000000 --> -1  returns the index within the unit that contains the given bitindex. initializes a table with numbers having 1,2,3,...,64 bits set. pows[i] has bits [0..i-1] set. pows[64] == -1l == ~0l == has all 64 bits set --> correct. to speedup calculations in subsequent methods. for (int i=bits_per_unit+1; --i >= 0; ) { pows[i]=value; value = value >>> 1; system.out.println((i)+":"+pows[i]); } long[] pows=new long[bits_per_unit]; for (int i=0; ibitindex in the bitvector bits to the state specified by value. bits the bitvector. bitindex the index of the bit to be changed. value the value to be stored in the bit. sets bits of a bitvector from index from to index to to the bits of value. bit from is set to bit 0 of value, ..., bit to is set to bit to-from of value. all other bits stay unaffected. if from &gt; to then does nothing. precondition (not checked): to-from+1 &lt;= 64. the bitvector. the value to be copied into the bitvector. index of start bit (inclusive). index of end bit (inclusive). this is equivalent to the above, but slower: int fromindex=from/bits_per_unit; int toindex=to/bits_per_unit; int fromoffset=from%bits_per_unit; int tooffset=to%bits_per_unit; changes the bit with index bitindex in the bitvector bits to the "set" (true) state. bits the bitvector. bitindex the index of the bit to be set. returns the index of the unit that contains the given bitindex. 64=2^6 = 1 >> (bits_per_unit-width)) << from; equivalent to from/64 equivalent to from%64 this is equivalent to the above, but slower: final int fromindex=from/bits_per_unit; final int toindex=to/bits_per_unit; final int fromoffset=from%bits_per_unit; final int tooffset=to%bits_per_unit; range does not cross unit boundaries; value to retrieve is contained in one single long value. range crosses unit boundaries; value to retrieve is spread over two long values. get part from first long value get part from second long value combine equivalent to bitindex%64 system.out.println((i)+":"+pows[i]); system.out.println((0)+":"+pows[0]); old stuff equivalent to from/64 equivalent to from%64 make sure all unused bits to the left are cleared. range does not cross unit boundaries; should go into one single long value. range crosses unit boundaries; value should go into two long values. copy into first long value. copy into second long value. equivalent to bitindex/64"
cern.colt.buffer.DoubleBuffer "fixed sized (non resizable) streaming buffer connected to a target doublebufferconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified element to the receiver. the element to add. adds all elements of the specified list to the receiver. the list of which all elements shall be added. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered elements to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.DoubleBuffer2D "fixed sized (non resizable) streaming buffer connected to a target doublebuffer2dconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified point (x,y) to the receiver. the x-coordinate of the point to add. the y-coordinate of the point to add. adds all specified points (x,y) to the receiver. the x-coordinates of the points to add. the y-coordinates of the points to add. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered points to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.DoubleBuffer2DConsumer "target of a streaming doublebuffer2d into which data is flushed upon buffer overflow. adds all specified (x,y) points to the receiver. the x-coordinates of the points to be added. the y-coordinates of the points to be added."
cern.colt.buffer.DoubleBuffer3D "fixed sized (non resizable) streaming buffer connected to a target doublebuffer3dconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified point (x,y,z) to the receiver. the x-coordinate of the point to add. the y-coordinate of the point to add. the z-coordinate of the point to add. adds all specified (x,y,z) points to the receiver. the x-coordinates of the points. the y-coordinates of the points. the y-coordinates of the points. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered points to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.DoubleBuffer3DConsumer "target of a streaming doublebuffer3d into which data is flushed upon buffer overflow. adds all specified (x,y,z) points to the receiver. the x-coordinates of the points to be added. the y-coordinates of the points to be added. the z-coordinates of the points to be added."
cern.colt.buffer.DoubleBufferConsumer "target of a streaming doublebuffer into which data is flushed upon buffer overflow. adds all elements of the specified list to the receiver. the list of which all elements shall be added."
cern.colt.buffer.IntBuffer "fixed sized (non resizable) streaming buffer connected to a target intbufferconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified element to the receiver. the element to add. adds all elements of the specified list to the receiver. the list of which all elements shall be added. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered elements to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.IntBuffer2D "fixed sized (non resizable) streaming buffer connected to a target intbuffer2dconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified point (x,y) to the receiver. the x-coordinate of the point to add. the y-coordinate of the point to add. adds all specified points (x,y) to the receiver. the x-coordinates of the points to add. the y-coordinates of the points to add. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered points to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.IntBuffer2DConsumer "target of a streaming intbuffer2d into which data is flushed upon buffer overflow. adds all specified (x,y) points to the receiver. the x-coordinates of the points to be added. the y-coordinates of the points to be added."
cern.colt.buffer.IntBuffer3D "fixed sized (non resizable) streaming buffer connected to a target intbuffer3dconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified point (x,y,z) to the receiver. the x-coordinate of the point to add. the y-coordinate of the point to add. the z-coordinate of the point to add. adds all specified (x,y,z) points to the receiver. the x-coordinates of the points. the y-coordinates of the points. the y-coordinates of the points. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered points to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.IntBuffer3DConsumer "target of a streaming intbuffer3d into which data is flushed upon buffer overflow. adds all specified (x,y,z) points to the receiver. the x-coordinates of the points to be added. the y-coordinates of the points to be added. the z-coordinates of the points to be added."
cern.colt.buffer.IntBufferConsumer "target of a streaming intbuffer into which data is flushed upon buffer overflow. adds all elements of the specified list to the receiver. the list of which all elements shall be added."
cern.colt.buffer.ObjectBuffer "fixed sized (non resizable) streaming buffer connected to a target objectbufferconsumer to which data is automatically flushed upon buffer overflow. constructs and returns a new buffer with the given target. the target to flush to. the number of points the buffer shall be capable of holding before overflowing and flushing to the target. adds the specified element to the receiver. the element to add. adds all elements of the specified list to the receiver. the list of which all elements shall be added. sets the receiver's size to zero. in other words, forgets about any internally buffered elements. adds all internally buffered elements to the receiver's target, then resets the current buffer size to zero. vars cached for speed"
cern.colt.buffer.ObjectBufferConsumer "target of a streaming objectbuffer into which data is flushed upon buffer overflow. adds all elements of the specified list to the receiver. the list of which all elements shall be added."
cern.colt.function.BooleanProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.ByteComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.ByteProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.CharComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.CharProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.Double27Function "interface that represents a function object: a function that takes 27 arguments and returns a single value. applies a function to 27 arguments. result of the function."
cern.colt.function.Double5Function "interface that represents a function object: a function that takes 5 arguments and returns a single value. applies a function to two arguments. the first argument passed to the function. the second argument passed to the function. the third argument passed to the function. the fourth argument passed to the function. the fifth argument passed to the function. result of the function."
cern.colt.function.Double9Function "interface that represents a function object: a function that takes 9 arguments and returns a single value. applies a function to nine arguments. result of the function."
cern.colt.function.DoubleComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.DoubleDoubleFunction "interface that represents a function object: a function that takes two arguments and returns a single value. applies a function to two arguments. the first argument passed to the function. the second argument passed to the function. result of the function."
cern.colt.function.DoubleDoubleProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.DoubleFunction "interface that represents a function object: a function that takes a single argument and returns a single value. applies a function to an argument. argument passed to the function. result of the function."
cern.colt.function.DoubleIntProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.DoubleProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.FloatComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.FloatProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.IntDoubleFunction "interface that represents a function object: a function that takes two arguments. applies a function to two arguments. first argument passed to the function. second argument passed to the function. result of the function."
cern.colt.function.IntDoubleProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntFunction "interface that represents a function object: a function that takes a single argument and returns a single value. applies a function to an argument. argument passed to the function. result of the function."
cern.colt.function.IntIntDoubleFunction "interface that represents a function object: a function that takes three arguments. applies a function to three arguments. first argument passed to the function. second argument passed to the function. third argument passed to the function. result of the function."
cern.colt.function.IntIntDoubleProcedure "interface that represents a procedure object: a procedure that takes three arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. third argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntIntFunction "interface that represents a function object: a function that takes two arguments and returns a single value. applies a function to two arguments. the first argument passed to the function. the second argument passed to the function. result of the function."
cern.colt.function.IntIntIntProcedure "interface that represents a procedure object: a procedure that takes three arguments and does not return a value. applies a procedure to three arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. third argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntIntProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntObjectProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.IntProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.LongComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.LongObjectProcedure "interface that represents a procedure object: a procedure that takes two arguments and does not return a value. applies a procedure to two arguments. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. first argument passed to the procedure. second argument passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.LongProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.ObjectFunction "interface that represents a function object: a function that takes a single argument and returns a single value. applies a function to an argument. argument passed to the function. result of the function."
cern.colt.function.ObjectObjectFunction "interface that represents a function object: a function that takes two arguments and returns a single value. applies a function to two arguments. the first argument passed to the function. the second argument passed to the function. result of the function."
cern.colt.function.ObjectProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.function.ShortComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.function.ShortProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.GenericPermuting "generically reorders (permutes) arbitrary shaped data (for example, an array, three arrays, a 2-d matrix, two linked lists) using an in-place swapping algorithm. imagine having a couple of apples. for some reason you decide to reorder them. the green one before the red one. the pale one after the shiny one, etc. this class helps to do the job.  this class swaps elements around, in a way that avoids stumbling over its own feet: let before be the generic data before calling the reordering method. let after be the generic data after calling the reordering method. then there holds after[i] == before[indexes[i]].  similar to {@link genericsorting}, this class has no idea what kind of data it is reordering. it can decide to swap the data at index a with the data at index b. it calls a makes this class non instantiable, but still let's others inherit from it. returns the p-th permutation of the sequence [0,1,...,n-1]. a small but smart and efficient routine, ported from  cernlib. the  fortran source. a sequence of n distinct elements has n! permutations, which are enumerated in lexicographical order 1 .. n!.  this is, for example, useful for monte-carlo-tests where one might want to compute k distinct and random permutations of a sequence, obtaining p from {@link cern.jet.random.sampling} without replacement or a random engine like {@link cern.jet.random.engine.mersennetwister}.  note: when n! exceeds the 64-bit range (i.e. for n > 20), this method has different behaviour: it makes a sequence [0,1,...,n-1] and randomizes it, seeded with parameter p.  examples:  http://www.hep.net/wwwmirrors/cernlib/cnasdoc/shortwrups_html3/node255.html // exactly lexicographically enumerated (ascending) permutation(1,3) --> [ 0,1,2 ] permutation(2,3) --> [ 0,2,1 ] permutation(3,3) --> [ 1,0,2 ] permutation(4,3) --> [ 1,2,0 ] permutation(5,3) --> [ 2,0,1 ] permutation(6,3) --> [ 2,1,0 ] permutation(1 ,20) --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19] permutation(2 ,20) --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 18] permutation(1000000,20) --> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 12, 17, 18, 13, 19, 11, 15, 14, 16, 10] permutation(20! -2 ,20) --> [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 1, 2, 0] permutation(20! -1 ,20) --> [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 0, 1] permutation(20! ,20) --> [19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]  // not exactly enumerated, rather randomly shuffled permutation(1,21) --> [18, 20, 11, 0, 15, 1, 19, 13, 3, 6, 16, 17, 9, 5, 12, 4, 7, 14, 8, 10, 2] permutation(2,21) --> [1, 9, 4, 16, 14, 13, 11, 20, 10, 8, 18, 0, 15, 3, 17, 5, 12, 2, 6, 7, 19] permutation(3,21) --> [12, 0, 19, 1, 20, 5, 8, 16, 6, 14, 2, 4, 3, 17, 11, 13, 9, 10, 15, 18, 7]  the lexicographical ordinal number of the permutation to be computed. the length of the sequence to be generated. p-th permutation. @throws illegalargumentexception if p  n!. a non-generic variant of reordering, specialized for int[], same semantics. quicker than generic reordering. also for convenience (forget about the swapper object). deprecated. generically reorders arbitrary shaped generic data g such that g[i] == g[indexes[i]]. (the generic data may be one array, a 2-d matrix, two linked lists or whatever). this class swaps elements around, in a way that avoids stumbling over its own feet.  example:  reordering [a,b,c,d,e] with indexes [0,4,2,3,1] yields [a,e,c,d,b] in other words g[0]  @deprecated indexes the permutation indexes. swapper an object that knows how to swap two indexes a,b. work the working storage, must satisfy work.length >= indexes.length; set work==null if you don't care about performance. generically reorders arbitrary shaped generic data g such that g[i] == g[indexes[i]]. (the generic data may be one array, a 2-d matrix, two linked lists or whatever). this class swaps elements around, in a way that avoids stumbling over its own feet.  example:  reordering [a,b,c,d,e] with indexes [0,4,2,3,1] yields [a,e,c,d,b] in other words g[0]  indexes the permutation indexes. swapper an object that knows how to swap two indexes a,b. work1 some working storage, must satisfy work1.length >= indexes.length; set work1==null if you don't care about performance. work2 some working storage, must satisfy work2.length >= indexes.length; set work2==null if you don't care about performance. a non-generic variant of reordering, specialized for object[], same semantics. quicker than generic reordering. also for convenience (forget about the swapper object). a swapper knows how to swap two indexes (a,b) reordering an array reordering string[] int tmp; // reordering int[] reordering a list reordering the rows of a 2-d matrix (see {@link cern.colt.matrix}) reordering the columns of a 2-d matrix www.hep.net/wwwmirrors/cernlib/cnasdoc/shortwrups_html3/node255.html"> cernlib. asisftp.cern.ch/cernlib/share/pro/src/mathlib/gen/v/permu.f"> fortran source. www.hep.net/wwwmirrors/cernlib/cnasdoc/shortwrups_html3/node255.html exactly lexicographically enumerated (ascending) not exactly enumerated, rather randomly shuffled factorial(21) would overflow 64-bit long) simply make a list (0,1,..n-1) and randomize it, seeded with "p". note that this is perhaps not what you want... swap(i, random) the normal case - exact enumeration "tracks" and "pos" keeps track of the current indexes of the elements example: we have a list==[a,b,c,d,e], indexes==[0,4,1,2,3] and swap b and e we need to know that the element formlerly at index 1 is now at index 4, and the one formerly at index 4 is now at index 1. otherwise we stumble over our own feet and produce nonsense. initially index i really is at index i, but this will change due to swapping. work1, work2 to avoid high frequency memalloc's"
cern.colt.GenericSorting "generically sorts arbitrary shaped data (for example multiple arrays, 1,2 or 3-d matrices, and so on) using a quicksort or mergesort. this class addresses two problems, namely  sorting multiple arrays in sync sorting by multiple sorting criteria (primary, secondary, tertiary, ...)  sorting multiple arrays in sync  assume we have three arrays x, y and z. we want to sort all three arrays by x (or some arbitrary comparison function). for example, we have x=[3, 2, 1], y=[3.0, 2.0, 1.0], z=[6.0, 7.0, 8.0]. the output should be  x=[1, 2, 3], y=[1.0, 2.0, 3.0], z=[8.0, 7.0, 6.0].  how can we achive this? here are several alternatives. we could ...    make a list of point3d objects, sort the list as desired using a comparison function, then copy the results back into x, y and z. the classic object-oriented way.  make an index list [0,1,2,...,n-1], sort the index list using a comparison function, then reorder the elements of x,y,z as defined by the index list. reordering cannot be done in-place, so we need to copy x to some temporary array, then copy in the right order back from the temporary into x. same for y and z.   use a generic quicksort or mergesort which, whenever two elements in x are swapped, also swaps the corresponding elements in y and z.   alternatives 1 and 2 involve quite a lot of copying and allocate significant amounts of temporary memory. alternative 3 involves more swapping, more polymorphic message dispatches, no copying and does not need any temporary memory.  this class implements alternative 3. it operates on arbitrary shaped data. in fact, it has no idea what kind of data it is sorting. comparisons and swapping are delegated to makes this class non instantiable, but still let's others inherit from it. transforms two consecutive sorted ranges into a single sorted range. the initial ranges are [first, middle) and [middle, last), and the resulting range is [first, last). elements in the first input range will precede equal elements in the second. performs a binary search on an already-sorted range: finds the first position where an element can be inserted without violating the ordering. sorting is by a returns the index of the median of the three indexed chars. sorts the specified range of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(a, b) must not throw an exception for any indexes a and b in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the generic data. an object that knows how to swap the elements at any two indexes (a,b). @see intcomparator @see swapper we retain the same method signature as quicksort. given only a comparator and swapper we do not know how to copy and move elements from/to temporary arrays. hence, in contrast to the jdk mergesorts this is an "in-place" mergesort, i.e. does not allocate any temporary arrays. a non-inplace mergesort would perhaps be faster in most cases, but would require non-intuitive delegate objects... sorts the specified range of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(a, b) must not throw an exception for any indexes a and b in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the generic data. an object that knows how to swap the elements at any two indexes (a,b). @see intcomparator @see swapper sorts the specified sub-array into ascending order. reverses a sequence of elements. array containing the sequence beginning of the range one past the end of the range @exception arrayindexoutofboundsexception if the range is invalid. rotate a range in place: array[middle] is put in array[first], array[middle+1] is put in array[first+1], etc. generally, the element in position i is put into position (i + (last-middle)) % (last-first). array containing the range beginning of the range index of the element that will be put in array[first] one past the end of the range performs a binary search on an already-sorted range: finds the last position where an element can be inserted without violating the ordering. sorting is by a swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. this one knows how to swap two indexes (a,b) simple comparison: compare by x and ignore y,z genericsorting.mergesort(0, x.length, comp, swapper); compare by y, if that doesn't help, reside to z rotate(firstcut, middle, secondcut, swapper); is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are "static private") speedup = 1.7 begin inline end inline if (comp==null) throw new nullpointerexception(); insertion sort on smallest arrays recursively sort halves if list is already sorted, nothing left to do. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 long v = x[m]; establish invariant: v (v) v moving target; delta to jdk !!! moving target; delta to jdk !!! moving target; delta to jdk !!! moving target; delta to jdk !!! moving target; delta to jdk !!! moving target; delta to jdk !!! swap partition elements back to middle recursively sort non-partition-elements no more needed since manually inlined no more needed since manually inlined if (comp==null) throw new nullpointerexception();"
cern.colt.GenericSortingTest "demonstrates how to use {@link sort}. makes this class non instantiable, but still let's others inherit from it. just a demo. just a demo. checks the correctness of the partition method by generating random input parameters and checking whether results are correct."
cern.colt.list.AbstractBooleanList "abstract base class for resizable lists holding boolean elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call booleanens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractbooleanlist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. transforms a boolean value to an integer (false --> 0, true --> 1) returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractByteList "abstract base class for resizable lists holding byte elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call byteens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @exception indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractbytelist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractCharList "abstract base class for resizable lists holding char elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractcharlist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractCollection "abstract base class for resizable collections holding objects or primitive data types such as int, float, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. removes all elements from the receiver. the receiver will be empty after this call returns. tests if the receiver has no elements. true if the receiver has no elements; false otherwise. returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. public abstract class abstractcollection extends object implements cloneable, java.io.serializable {"
cern.colt.list.AbstractDoubleList "abstract base class for resizable lists holding double elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends all elements of the specified list to the receiver. the list of which all elements shall be appended. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractdoublelist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found cern.colt.sorting.mergesort(myelements, from, to+1); // todo just for debugging nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractFloatList "abstract base class for resizable lists holding float elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractfloatlist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractIntList "abstract base class for resizable lists holding int elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends all elements of the specified list to the receiver. the list of which all elements shall be appended. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractintlist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found cern.colt.sorting.mergesort(myelements, from, to+1); // todo just for debugging nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractList "abstract base class for resizable lists holding objects or primitive data types such as int, float, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. appends all of the elements of the specified collection to the receiver. @exception classcastexception if an element in the collection is not of the same parameter type of the receiver. inserts all elements of the specified collection before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right (increases their indices). index before which to insert first element from the specified collection. the collection to be inserted @exception classcastexception if an element in the collection is not of the same parameter type of the receiver. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). checks if the given index is in range. checks if the given range is within the contained array's bounds. @throws indexoutofboundsexception if to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size(). removes all elements from the receiver. the receiver will be empty after this call returns, but keep its current capacity. sorts the receiver into ascending order. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. sorts the receiver into ascending order. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @throws indexoutofboundsexception if (from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1. sorts the receiver into ascending order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. sorts the specified range of the receiver into ascending order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @throws indexoutofboundsexception if (from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1. removes the element at the specified position from the receiver. shifts any subsequent elements to the left. the index of the element to removed. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @throws indexoutofboundsexception if (from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1. replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. sets the size of the receiver. if the new size is greater than the current size, new null or zero items are added to the end of the receiver. if the new size is less than the current size, all components at index newsize and greater are discarded. this method does not release any superfluos internal memory. use method trimtosize to release superfluos internal memory. the new size of the receiver. @throws indexoutofboundsexception if newsize &lt; 0. randomly permutes the receiver. after invocation, all elements will be at random positions. randomly permutes the receiver between from (inclusive) and to (inclusive). the start position (inclusive) the end position (inclusive) @throws indexoutofboundsexception if (from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1. sorts the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. this implementation simply calls sortfromto(...). override sortfromto(...) if you can determine which sort is most appropriate for the given data set. sorts the specified range of the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. this default implementation simply calls quicksort. override this method if you can determine which sort is most appropriate for the given data set. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @throws indexoutofboundsexception if (from&lt;0 || from&gt;to || to&gt;=size()) && to!=from-1. trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver.  this default implementation does nothing. override this method in space efficient implementations."
cern.colt.list.AbstractLongList "abstract base class for resizable lists holding long elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractlonglist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.AbstractShortList "abstract base class for resizable lists holding short elements; abstract. first see the package summary and javadoc tree view to get the broad picture. the size of the list. this is a read_only variable for all methods but setsizeraw(int newsize) !!! if you violate this principle in subclasses, you should exactly know what you are doing. @serial makes this class non instantiable, but still let's others inherit from it. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummy elements before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. this method must set the new size to be size()+length. index before which to insert dummy elements (must be in [0,size]).. number of dummy elements to be inserted. @throws indexoutofboundsexception if index &lt; 0 || index &gt; size(). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified element. element whose presence in the receiver is to be tested. deletes the first element from the receiver that is identical to the specified element. does nothing, if no such matching element is contained. the element to be deleted. returns the elements currently stored, possibly including invalid elements between size and capacity. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array. the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, this method may decide not to copy the array. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. element the element to be searched for. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @throws indexoutofboundsexception if index &lt; 0 || index &gt;= size(). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). this method is normally only used internally in large loops where bounds are explicitly checked before the loop and need no be rechecked within the loop. however, when desperately, you can give this method public visibility in subclasses. index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. if your subclass overrides and delegates size changing methods to some other object, you must make sure that those overriding methods not only update the size of the delegate but also of this class. for example: public databaselist extends abstractshortlist { ... public void removefromto(int from,int to) { mydatabase.removefromto(from,to); this.setsizeraw(size-(to-from+1)); } } randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. key found key not found. delta delta found not found found not found nothing to do fillfromtowith(from+nummoved, size-1, 0.0f); //delta unambiguous copy (it may hold other==this) avoid stumbling over my own feet delta swap swap(i, random)"
cern.colt.list.adapter.DoubleListAdapter "adapter that permits an {@link cern.colt.list.abstractdoublelist} to be viewed and treated as a jdk 1.2 {@link java.util.abstractlist}. makes the contained list compatible with the jdk 1.2 collections framework.  any attempt to pass elements other than java.lang.number to setter methods will throw a java.lang.classcastexception. java.lang.number.doublevalue() is used to convert objects into primitive values which are then stored in the backing templated list. getter methods return java.lang.double objects. constructs a list backed by the specified content list. inserts the specified element at the specified position in this list (optional operation). shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). index at which the specified element is to be inserted. element to be inserted. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns the element at the specified position in this list. index of element to return. element at the specified position in this list. @throws indexoutofboundsexception if the given index is out of range (index &lt; 0 || index &gt;= size()). transforms an element of a primitive data type to an object. removes the element at the specified position in this list (optional operation). shifts any subsequent elements to the left (subtracts one from their indices). returns the element that was removed from the list. the index of the element to remove. element previously at the specified position. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in this list with the specified element (optional operation).  index of element to replace. element to be stored at the specified position. element previously at the specified position. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). returns the number of elements in this list. the number of elements in this list. transforms an object element to a primitive data type."
cern.colt.list.adapter.FloatListAdapter "adapter that permits an {@link cern.colt.list.abstractfloatlist} to be viewed and treated as a jdk 1.2 {@link java.util.abstractlist}. makes the contained list compatible with the jdk 1.2 collections framework.  any attempt to pass elements other than java.lang.number to setter methods will throw a java.lang.classcastexception. java.lang.number.floatvalue() is used to convert objects into primitive values which are then stored in the backing templated list. getter methods return java.lang.float objects. constructs a list backed by the specified content list. inserts the specified element at the specified position in this list (optional operation). shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). index at which the specified element is to be inserted. element to be inserted. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns the element at the specified position in this list. index of element to return. element at the specified position in this list. @throws indexoutofboundsexception if the given index is out of range (index &lt; 0 || index &gt;= size()). transforms an element of a primitive data type to an object. removes the element at the specified position in this list (optional operation). shifts any subsequent elements to the left (subtracts one from their indices). returns the element that was removed from the list. the index of the element to remove. element previously at the specified position. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in this list with the specified element (optional operation).  index of element to replace. element to be stored at the specified position. element previously at the specified position. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). returns the number of elements in this list. the number of elements in this list. transforms an object element to a primitive data type."
cern.colt.list.adapter.IntListAdapter "adapter that permits an {@link cern.colt.list.abstractintlist} to be viewed and treated as a jdk 1.2 {@link java.util.abstractlist}. makes the contained list compatible with the jdk 1.2 collections framework.  any attempt to pass elements other than java.lang.number to setter methods will throw a java.lang.classcastexception. java.lang.number.intvalue() is used to convert objects into primitive values which are then stored in the backing templated list. getter methods return java.lang.integer objects. constructs a list backed by the specified content list. inserts the specified element at the specified position in this list (optional operation). shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). index at which the specified element is to be inserted. element to be inserted. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns the element at the specified position in this list. index of element to return. element at the specified position in this list. @throws indexoutofboundsexception if the given index is out of range (index &lt; 0 || index &gt;= size()). transforms an element of a primitive data type to an object. removes the element at the specified position in this list (optional operation). shifts any subsequent elements to the left (subtracts one from their indices). returns the element that was removed from the list. the index of the element to remove. element previously at the specified position. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in this list with the specified element (optional operation).  index of element to replace. element to be stored at the specified position. element previously at the specified position. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). returns the number of elements in this list. the number of elements in this list. transforms an object element to a primitive data type."
cern.colt.list.adapter.LongListAdapter "adapter that permits an {@link cern.colt.list.abstractlonglist} to be viewed and treated as a jdk 1.2 {@link java.util.abstractlist}. makes the contained list compatible with the jdk 1.2 collections framework.  any attempt to pass elements other than java.lang.number to setter methods will throw a java.lang.classcastexception. java.lang.number.longvalue() is used to convert objects into primitive values which are then stored in the backing templated list. getter methods return java.lang.long objects. constructs a list backed by the specified content list. inserts the specified element at the specified position in this list (optional operation). shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). index at which the specified element is to be inserted. element to be inserted. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns the element at the specified position in this list. index of element to return. element at the specified position in this list. @throws indexoutofboundsexception if the given index is out of range (index &lt; 0 || index &gt;= size()). transforms an element of a primitive data type to an object. removes the element at the specified position in this list (optional operation). shifts any subsequent elements to the left (subtracts one from their indices). returns the element that was removed from the list. the index of the element to remove. element previously at the specified position. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in this list with the specified element (optional operation).  index of element to replace. element to be stored at the specified position. element previously at the specified position. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). returns the number of elements in this list. the number of elements in this list. transforms an object element to a primitive data type."
cern.colt.list.adapter.ObjectListAdapter "adapter that permits an {@link cern.colt.list.objectarraylist} to be viewed and treated as a jdk 1.2 {@link java.util.abstractlist}. makes the contained list compatible with the jdk 1.2 collections framework. constructs a list backed by the specified content list. inserts the specified element at the specified position in this list (optional operation). shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices). index at which the specified element is to be inserted. element to be inserted. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns the element at the specified position in this list. index of element to return. element at the specified position in this list. @throws indexoutofboundsexception if the given index is out of range (index &lt; 0 || index &gt;= size()). removes the element at the specified position in this list (optional operation). shifts any subsequent elements to the left (subtracts one from their indices). returns the element that was removed from the list. the index of the element to remove. element previously at the specified position. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in this list with the specified element (optional operation).  index of element to replace. element to be stored at the specified position. element previously at the specified position. @throws classcastexception if the class of the specified element prevents it from being added to this list. @throws illegalargumentexception if some aspect of the specified element prevents it from being added to this list. @throws indexoutofboundsexception if the specified index is out of range (index &lt; 0 || index &gt;= size()). returns the number of elements in this list. the number of elements in this list."
cern.colt.list.BooleanArrayList "resizable list holding boolean elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order (false &lt; true). the sorting algorithm is a count sort. this algorithm offers guaranteed o(n) performance without auxiliary memory. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order (false &lt; true). the sorting algorithm is not a mergesort, but rather a countsort. this algorithm offers guaranteed o(n) performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order (false &lt; true). the sorting algorithm is not a quicksort, but rather a countsort. this algorithm offers guaranteed o(n) performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is countsort. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random)"
cern.colt.list.ByteArrayList "resizable list holding byte elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed o(max(n,256)) performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed performance: o(max(n,max-min+1)). space requirements: int[max-min+1] buffer. this algorithm is only applicable if max-min+1 is not large! but if applicable, it usually outperforms quicksort by a factor of 3-4. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the smallest element contained in the range. the largest element contained in the range. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is countsort. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random) try to figure out which option is fastest. o(nlog(n,base=2)) ; ln(2)=0.6931471805599453 o(max(width,n))"
cern.colt.list.CharArrayList "resizable list holding char elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed performance: o(max(n,max-min+1)). space requirements: int[max-min+1] buffer. this algorithm is only applicable if max-min+1 is not large! but if applicable, it usually outperforms quicksort by a factor of 3-4. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the smallest element contained in the range. the largest element contained in the range. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. currently quicksort and countsort are considered. countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4. best case performance: o(n). worst case performance: o(n^2) (a degenerated quicksort). best case space requirements: 0 kb. worst case space requirements: 40 kb. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). computes min and max and decides on this basis. in practice the additional overhead is very small compared to the potential gains. trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random) never consider options resulting in outrageous memory allocations. determine minimum and maximum. try to figure out which option is fastest. o(nlog(n,base=2)) ; ln(2)=0.6931471805599453 o(max(width,n))"
cern.colt.list.DistinctNumberList "resizable compressed list holding numbers; based on the fact that a number from a large list with few distinct values need not take more than log(distinctvalues) bits; implemented with a minmaxnumberlist. first see the package summary and javadoc tree view to get the broad picture.  this class can, for example, be useful when making large lists of numbers persistent. also useful when very large lists would otherwise consume too much main memory.  you can add, get and set elements quite similar to java.util.arraylist.  applicability: applicable if data is highly skewed and legal values are known in advance. robust in the presence of "outliers".  performance: operations get(), size() and clear() are o(1), i.e. run in constant time. operations like add() and set() are o(log(distinctvalues.length)).  upon instantiation a contract is signed that defines the distinct values allowed to be hold in this list. it is not legal to store elements other than specified by the contract. any attempt to violate the contract will throw an illegalargumentexception.  although access methods are only defined on long values you can also store all other primitive data types: boolean, byte, short, int, long, float, double and char. you can do this by explicitly representing them as long values. use casts for discrete data types. use the methods of java.lang.float and java.lang.double for floating point data types: recall that with those methods you can convert any floating point value to a long value and back without losing any precision:  example usage: distinctnumberlist list = ... instantiation goes here double d1 = 1.234; list.add(double.doubletolongbits(d1)); double d2 = double.longbitstodouble(list.get(0)); if (d1!=d2) system.out.println("this is impossible!"); distinctnumberlist list2 = ... instantiation goes here float f1 = 1.234f; list2.add((long) float.floattointbits(f1)); float f2 = float.intbitstofloat((int)list2.get(0)); if (f1!=f2) system.out.println("this is impossible!");  @see longarraylist @see minmaxnumberlist @see java.lang.float @see java.lang.double constructs an empty list with the specified initial capacity and the specified distinct values allowed to be hold in this list. distinctvalues an array sorted ascending containing the distinct values allowed to be hold in this list. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. returns the code that shall be stored for the given element. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. sets the receiver to an empty list with the specified initial capacity and the specified distinct values allowed to be hold in this list. distinctvalues an array sorted ascending containing the distinct values allowed to be hold in this list. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. trims the capacity of the receiver to be the receiver's current size. an application can use this operation to minimize the storage of the receiver. overridden for performance only. java.util.arrays.sort(this.distinctelements);"
cern.colt.list.DoubleArrayList "resizable list holding double elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random)"
cern.colt.list.FloatArrayList "resizable list holding float elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random)"
cern.colt.list.IntArrayList "resizable list holding int elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed performance: o(max(n,max-min+1)). space requirements: int[max-min+1] buffer. this algorithm is only applicable if max-min+1 is not large! but if applicable, it usually outperforms quicksort by a factor of 3-4. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the smallest element contained in the range. the largest element contained in the range. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. currently quicksort and countsort are considered. countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4. best case performance: o(n). worst case performance: o(n^2) (a degenerated quicksort). best case space requirements: 0 kb. worst case space requirements: 40 kb. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). computes min and max and decides on this basis. in practice the additional overhead is very small compared to the potential gains. trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random) never consider options resulting in outrageous memory allocations. determine minimum and maximum. try to figure out which option is fastest. o(nlog(n,base=2)) ; ln(2)=0.6931471805599453 o(max(width,n))"
cern.colt.list.LongArrayList "resizable list holding long elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed performance: o(max(n,max-min+1)). space requirements: int[max-min+1] buffer. this algorithm is only applicable if max-min+1 is not large! but if applicable, it usually outperforms quicksort by a factor of 3-4. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the smallest element contained in the range. the largest element contained in the range. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. currently quicksort and countsort are considered. countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4. best case performance: o(n). worst case performance: o(n^2) (a degenerated quicksort). best case space requirements: 0 kb. worst case space requirements: 40 kb. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). computes min and max and decides on this basis. in practice the additional overhead is very small compared to the potential gains. trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random) never consider options resulting in outrageous memory allocations. determine minimum and maximum. try to figure out which option is fastest. o(nlog(n,base=2)) ; ln(2)=0.6931471805599453 o(max(width,n))"
cern.colt.list.MinMaxNumberList "resizable compressed list holding numbers; based on the fact that a value in a given interval need not take more than log(max-min+1) bits; implemented with a cern.colt.bitvector.bitvector. first see the package summary and javadoc tree view to get the broad picture.  numbers can be compressed when minimum and maximum of all values ever to be stored in the list are known. for example, if min=16, max=27, only 4 bits are needed to store a value. no compression is achieved for float and double values.  you can add, get and set elements quite similar to java.util.arraylist.  applicability: applicable if the data is non floating point, highly skewed without "outliers" and minimum and maximum known in advance.  performance: basic operations like add(), get(), set(), size() and clear() are o(1), i.e. run in constant time. 200mhz pentium pro, jdk 1.2, nt: 10^6 calls to getquick() --> 0.5 seconds. (50 times slower than reading from a primitive array of the appropriate type.) 10^6 calls to setquick() --> 0.8 seconds. (15 times slower than writing to a primitive array of the appropriate type.)  this class can, for example, be useful when making large lists of numbers persistent. also useful when very large lists would otherwise consume too much main memory.  upon instantiation a contract is signed that defines the interval values may fall into. it is not legal to store values not contained in that interval. warning: the contract is not checked. be sure you do not store illegal values. if you need to store float or double values, you must set the minimum and maximum to [integer.min_value,integer.max_value] or [long.min_value,long.max_value], respectively.  although access methods are only defined on long values you can also store all other primitive data types: boolean, byte, short, int, long, float, double and char. you can do this by explicitly representing them as long values. use casts for discrete data types. use the methods of java.lang.float and java.lang.double for floating point data types: recall that with those methods you can convert any floating point value to a long value and back without losing any precision:  example usage: minmaxnumberlist list = ... instantiation goes here double d1 = 1.234; list.add(double.doubletolongbits(d1)); double d2 = double.longbitstodouble(list.get(0)); if (d1!=d2) system.out.println("this is impossible!"); minmaxnumberlist list2 = ... instantiation goes here float f1 = 1.234f; list2.add((long) float.floattointbits(f1)); float f2 = float.intbitstofloat((int)list2.get(0)); if (f1!=f2) system.out.println("this is impossible!");  @see longarraylist @see distinctnumberlist @see java.lang.float @see java.lang.double constructs an empty list with the specified initial capacity and the specified range of values allowed to be hold in this list. legal values are in the range [minimum,maximum], all inclusive. minimum the minimum of values allowed to be hold in this list. maximum the maximum of values allowed to be hold in this list. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. appends the elements elements[from] (inclusive), ..., elements[to] (inclusive) to the receiver. the elements to be appended to the receiver. the index of the first element to be appended (inclusive) the index of the last element to be appended (inclusive) bitsperelem; } / returns the number of bits necessary to store a single element. returns the number of bits necessary to store values in the range [minimum,maximum]. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. copies all elements between index from (inclusive) and to (inclusive) into part, starting at index partfrom within part. elements are only copied if a corresponding flag within qualificants is set. more precisely: for (; from replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. sets the size of the receiver without modifying it otherwise. this method should not release or allocate new memory but simply set some instance variable like size. sets the receiver to an empty list with the specified initial capacity and the specified range of values allowed to be hold in this list. legal values are in the range [minimum,maximum], all inclusive. minimum the minimum of values allowed to be hold in this list. maximum the maximum of values allowed to be hold in this list. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. this method was returns the receiver seen as bitvector. warning: the bitvector and the receiver share the backing bits. modifying one of them will affect the other. trims the capacity of the receiver to be the receiver's current size. an application can use this operation to minimize the storage of the receiver. deprecated returns the minimum element legal to the stored in the receiver. remark: this does not mean that such a minimum element is currently contained in the receiver. @deprecated overridden for performance only. cache some vars for speed. now let's go. bitsperelem; overflow or underflow in calculating "1+maximum-minimum" happens if signed long representation is too short for doing unsigned calculations e.g. if minimum==long.min_value, maximum==long.max_value --> in such cases store all bits of values without any compression. bitvector tmpbitvector = new bitvector(this.bits, this.sizebitsperelem); part[p] = minval + tmpbitvector.getlongfromto(j, j+bitsperelem-1); this.capacity=initialcapacity; overflow or underflow in calculating "1+maxvalue-minvalue" happens if signed long representation is too short for doing unsigned calculations e.g. if minvalue==long.min_value, maxvalue=long.max_value --> in such cases store all bits of values without any en/decoding"
cern.colt.list.ObjectArrayList "resizable list holding object elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial the size of the list. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. appends the part of the specified list between from (inclusive) and to (inclusive) to the receiver. the list to be added to the receiver. the index of the first element to be appended (inclusive). the index of the last element to be appended (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts the part of the specified list between otherfrom (inclusive) and otherto (inclusive) before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert first element from the specified list (must be in [0,size]).. list of which a part is to be inserted into the receiver. the index of the first element to be inserted (inclusive). the index of the last element to be inserted (inclusive). @exception indexoutofboundsexception index is out of range (other.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=other.size())). @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). inserts length dummies before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which to insert dummies (must be in [0,size]).. number of dummies to be inserted. searches the receiver for the specified value using the binary search algorithm. the receiver must be sorted into ascending order according to the natural ordering of its elements (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see comparable @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must be sorted into ascending order according to the natural ordering of its elements (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see comparable @see java.util.arrays searches the receiver for the specified value using the binary search algorithm. the receiver must be sorted into ascending order according to the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). if the receiver is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. the comparator by which the receiver is sorted. @throws classcastexception if the receiver contains elements that are not mutually comparable using the specified comparator. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays @see java.util.comparator returns a copy of the receiver such that the copy and the receiver share the same elements, but do not share the same array to index them; so modifying an object in the copy modifies the object in the receiver and vice versa; however, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa. a copy of the receiver. returns true if the receiver contains the specified element. tests for equality or identity as specified by testforequality. element to search for. if true -> test for equality, otherwise for identity. returns a copy of the receiver; call clone() and casts the result. returns a copy such that the copy and the receiver share the same elements, but do not share the same array to index them; so modifying an object in the copy modifies the object in the receiver and vice versa; however, structurally modifying the copy (for example changing its size, setting other objects at indexes, etc.) does not affect the receiver and vice versa. a copy of the receiver. deletes the first element from the receiver that matches the specified element. does nothing, if no such matching element is contained. tests elements for equality or identity as specified by testforequality. when testing for equality, two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) if true -> tests for equality, otherwise for identity. the element to be deleted. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver for equality. returns true if and only if the specified object is also an objectarraylist, both lists have the same size, and all corresponding pairs of elements in the two lists are equal. in other words, two lists are defined to be equal if they contain the same elements in the same order. two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) the object to be compared for equality with the receiver. if the specified object is equal to the receiver. compares the specified object with the receiver for equality. returns true if and only if the specified object is also an objectarraylist, both lists have the same size, and all corresponding pairs of elements in the two lists are the same. in other words, two lists are defined to be equal if they contain the same elements in the same order. tests elements for equality or identity as specified by testforequality. when testing for equality, two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) the object to be compared for equality with the receiver. if true -> tests for equality, otherwise for identity. if the specified object is equal to the receiver. sets the specified range of elements in the specified array to the specified value. the index of the first element (inclusive) to be filled with the specified value. the index of the last element (inclusive) to be filled with the specified value. the value to be stored in the specified elements of the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. tests for equality or identity as specified by testforequality. if true -> test for equality, otherwise for identity. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for equality or identity as specified by testforequality. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. if true -> test for equality, otherwise for identity. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). determines whether the receiver is sorted ascending, according to the natural ordering of its elements. all elements in this range must implement the comparable interface. furthermore, all elements in this range must be mutually comparable (that is, e1.compareto(e2) must not throw a classcastexception for any elements e1 and e2 in the array). the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. true if the receiver is sorted ascending, false otherwise. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. tests for equality or identity as specified by testforequality. element the element to be searched for. if true -> test for equality, otherwise for identity. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for equality or identity as specified by testforequality. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. if true -> test for equality, otherwise for identity. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. all elements in this range must implement the comparable interface. furthermore, all elements in this range must be mutually comparable (that is, e1.compareto(e2) must not throw a classcastexception for any elements e1 and e2 in the array). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). @see comparator returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. all elements in this range must implement the comparable interface. furthermore, all elements in this range must be mutually comparable (that is, e1.compareto(e2) must not throw a classcastexception for any elements e1 and e2 in the array). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. you should never call this method unless you are sure that this particular sorting algorithm is the right one for your data set. it is generally better to call sort() or sortfromto(...) instead, because those methods automatically choose the best sorting algorithm. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the receiver according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for equality or identity as specified by testforequality. the other list. if true -> test for equality, otherwise for identity. true if the receiver changed as a result of the call. removes from the receiver all elements whose index is between from, inclusive and to, inclusive. shifts any succeeding elements to the left (reduces their index). this call shortens the list by (to - from + 1) elements. index of first element to be removed. index of last element to be removed. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). replaces a number of elements in the receiver with the same number of elements of another list. replaces elements in the receiver, between from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. replaces the part between from (inclusive) and to (inclusive) with the other list's part between otherfrom and otherto. powerful (and tricky) method! both parts need not be of the same size (part a can both be smaller or larger than part b). parts may overlap. receiver and other list may (but most not) be identical. if from &gt; to, then inserts other part before from. the first element of the receiver (inclusive) the last element of the receiver (inclusive) the other list (may be identical with receiver) the first element of the other list (inclusive) the last element of the other list (inclusive) examples: a=[0, 1, 2, 3, 4, 5, 6, 7] b=[50, 60, 70, 80, 90] a.r(...)=a.replacefromtowithfromto(...) a.r(3,5,b,0,4)-->[0, 1, 2, 50, 60, 70, 80, 90, 6, 7] a.r(1,6,b,0,4)-->[0, 50, 60, 70, 80, 90, 7] a.r(0,6,b,0,4)-->[50, 60, 70, 80, 90, 7] a.r(3,5,b,1,2)-->[0, 1, 2, 60, 70, 6, 7] a.r(1,6,b,1,2)-->[0, 60, 70, 7] a.r(0,6,b,1,2)-->[60, 70, 7] a.r(5,3,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,0,b,0,4)-->[0, 1, 2, 3, 4, 50, 60, 70, 80, 90, 5, 6, 7] a.r(5,3,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] a.r(5,0,b,1,2)-->[0, 1, 2, 3, 4, 60, 70, 5, 6, 7] extreme cases: a.r(5,3,b,0,0)-->[0, 1, 2, 3, 4, 50, 5, 6, 7] a.r(5,3,b,4,4)-->[0, 1, 2, 3, 4, 90, 5, 6, 7] a.r(3,5,a,0,1)-->[0, 1, 2, 0, 1, 6, 7] a.r(3,5,a,3,5)-->[0, 1, 2, 3, 4, 5, 6, 7] a.r(3,5,a,4,4)-->[0, 1, 2, 4, 6, 7] a.r(5,3,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,b,0,4)-->[50, 60, 70, 80, 90, 0, 1, 2, 3, 4, 5, 6, 7] a.r(0,-1,a,0,4)-->[0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 5, 6, 7] a.r(8,0,a,0,4)-->[0, 1, 2, 3, 4, 5, 6, 7, 0, 1, 2, 3, 4]  replaces the part of the receiver starting at from (inclusive) with all the elements of the specified collection. does not alter the size of the receiver. replaces exactly math.max(0,math.min(size()-from, other.size())) elements. the index at which to copy the first element from the specified collection. collection to replace part of the receiver @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. tests for equality or identity as specified by testforequality. the other list to test against. if true -> test for equality, otherwise for identity. true if the receiver changed as a result of the call. reverses the elements of the receiver. last becomes first, second last becomes second first, and so on. replaces the element at the specified position in the receiver with the specified element. index of element to replace. element to be stored at the specified position. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns a list which is a concatenation of times times the receiver. the number of times the receiver shall be copied. returns an array containing all of the elements in the receiver in the correct order. the runtime type of the returned array is that of the specified array. if the receiver fits in the specified array, it is returned therein. otherwise, a new array is allocated with the runtime type of the specified array and the size of the receiver.  if the receiver fits in the specified array with room to spare (i.e., the array has more elements than the receiver), the element in the array immediately following the end of the receiver is set to null. this is useful in determining the length of the receiver only if the caller knows that the receiver does not contain any null elements. the array into which the elements of the receiver are to be stored, if it is big enough; otherwise, a new array of the same runtime type is allocated for this purpose. array containing the elements of the receiver. @exception arraystoreexception the runtime type of array is not a supertype of the runtime type of every element in the receiver. returns a java.util.arraylist containing all the elements in the receiver. returns a string representation of the receiver, containing the string representation of each element. trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. key found key not found. delta delta found found not found found found not found nothing to do delta avoid stumbling over my own feet system.out.println("from="+from); system.out.println("to="+to); system.out.println("diff="+diff); delta swap swap(i, random)"
cern.colt.list.ShortArrayList "resizable list holding short elements; implemented with arrays. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. appends the specified element to the end of this list. element to be appended to this list. inserts the specified element before the specified position into the receiver. shifts the element currently at that position (if any) and any subsequent elements to the right. index before which the specified element is to be inserted (must be in [0,size]). element to be inserted. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt; size()). searches the receiver for the specified value using the binary search algorithm. the receiver must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the receiver contains multiple elements equal to the specified object, there is no guarantee which instance will be found. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the receiver; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the receiver: the index of the first element greater than the key, or receiver.size(), if all elements in the receiver are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see cern.colt.sorting @see java.util.arrays returns a deep copy of the receiver. a deep copy of the receiver. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. sorts the specified range of the receiver into ascending numerical order. the sorting algorithm is a count sort. this algorithm offers guaranteed performance: o(max(n,max-min+1)). space requirements: int[max-min+1] buffer. this algorithm is only applicable if max-min+1 is not large! but if applicable, it usually outperforms quicksort by a factor of 3-4. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. the smallest element contained in the range. the largest element contained in the range. returns the elements currently stored, including invalid elements between size and capacity, if any. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the returned array directly via the [] operator, be sure you know what you're doing. elements currently stored. sets the receiver's elements to be the specified array (not a copy of it). the size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the new elements to be stored. receiver itself. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. compares the specified object with the receiver. returns true if and only if the specified object is also an arraylist of the same type, both lists have the same size, and all corresponding pairs of elements in the two lists are identical. in other words, two lists are defined to be equal if they contain the same elements in the same order. the object to be compared for equality with the receiver. if the specified object is equal to the receiver. applies a procedure to each element of the receiver, if any. starts at index 0, moving rightwards. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the element at the specified position in the receiver. index of element to return. @exception indexoutofboundsexception index is out of range (index &lt; 0 || index &gt;= size()). returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. returns the index of the first occurrence of the specified element. returns -1 if the receiver does not contain this element. searches between from, inclusive and to, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the first occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns the index of the last occurrence of the specified element. returns -1 if the receiver does not contain this element. searches beginning at to, inclusive until from, inclusive. tests for identity. element to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the index of the last occurrence of the element in the receiver; returns -1 if the element is not found. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). returns a new list of the part of the receiver between from, inclusive, and to, inclusive. the index of the first element (inclusive). the index of the last element (inclusive). new list @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). removes from the receiver all elements that are contained in the specified list. tests for identity. the other list. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn from (inclusive) and to (inclusive), with elements of other, starting from otherfrom (inclusive). the position of the first element to be replaced in the receiver the position of the last element to be replaced in the receiver list holding elements to be copied into the receiver. position of first element within other list to be copied. retains (keeps) only the elements in the receiver that are contained in the specified other list. in other words, removes from the receiver all of its elements that are not contained in the specified other list. the other list to test against. true if the receiver changed as a result of the call. there are two possibilities to do the thing a) use other.indexof(...) b) sort other, then use other.binarysearch(...) let's try to figure out which one is faster. let m=size, n=other.size, then a) takes o(mn) steps b) takes o(nlogn + mlogn) steps (sorting is o(nlogn) and binarysearch is o(logn)) hence, if nlogn + mlogn warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. randomly permutes the part of the receiver between from (inclusive) and to (inclusive). the index of the first element (inclusive) to be permuted. the index of the last element (inclusive) to be permuted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). sorts the specified range of the receiver into ascending order. the sorting algorithm is dynamically chosen according to the characteristics of the data set. currently quicksort and countsort are considered. countsort is not always applicable, but if applicable, it usually outperforms quicksort by a factor of 3-4. best case performance: o(n). worst case performance: o(n^2) (a degenerated quicksort). best case space requirements: 0 kb. worst case space requirements: 40 kb. the index of the first element (inclusive) to be sorted. the index of the last element (inclusive) to be sorted. @exception indexoutofboundsexception index is out of range (size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=size())). computes min and max and decides on this basis. in practice the additional overhead is very small compared to the potential gains. trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. overridden for performance only. overridden for performance only. overridden for performance only. delta overridden for performance only. overridden for performance only. overridden for performance only. overridden for performance only. found not found overridden for performance only. found not found overridden for performance only. nothing to do it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. slower overridden for performance only. it is faster to sort other before searching in it it is faster to search in other without sorting overridden for performance only. swap overridden for performance only. overridden for performance only. swap(i, random) never consider options resulting in outrageous memory allocations. determine minimum and maximum. try to figure out which option is fastest. o(nlog(n,base=2)) ; ln(2)=0.6931471805599453 o(max(width,n))"
cern.colt.list.SimpleLongArrayList "resizable list holding long elements; implemented with arrays; not efficient; just to demonstrate which methods you must override to implement a fully functional list. first see the package summary and javadoc tree view to get the broad picture. the array buffer into which the elements of the list are stored. the capacity of the list is the length of this array buffer. @serial the size of the list. @serial constructs an empty list. constructs a list containing the specified elements. the initial size and capacity of the list is the length of the array. warning: for efficiency reasons and to keep memory usage low, the array is not copied. so if subsequently you modify the specified array directly via the [] operator, be sure you know what you're doing. the array to be backed by the the constructed list constructs an empty list with the specified initial capacity. initialcapacity the number of elements the receiver can hold without auto-expanding itself by allocating new internal memory. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver. mincapacity the desired minimum capacity. returns the element at the specified position in the receiver; warning: does not check preconditions. provided with invalid parameters this method may return invalid elements without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to return. replaces the element at the specified position in the receiver with the specified element; warning: does not check preconditions. provided with invalid parameters this method may access invalid indexes without throwing any exception! you should only use this method when you are absolutely sure that the index is within bounds. precondition (unchecked): index &gt;= 0 && index &lt; size(). index of element to replace. element to be stored at the specified position. trims the capacity of the receiver to be the receiver's current size. an application can use this operation to minimize the storage of the receiver."
cern.colt.map.AbstractDoubleIntMap "abstract base class for hash maps holding (key,value) associations of type (double-->int). first see the package summary and javadoc tree view to get the broad picture.  implementation:  almost all methods are expressed in terms of {@link #foreachkey(doubleprocedure)}. as such they are fully functional, but inefficient. override them in subclasses if necessary. makes this class non instantiable, but still let's others inherit from it. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. compares the specified object with this map for equality. returns true if the given object is also a map and the two maps represent the same mappings. more formally, two maps m1 and m2 represent the same mappings iff  m1.foreachpair( new doubleintprocedure() { public boolean apply(double key, int value) { return m2.containskey(key) && m2.get(key) == value; } } ) && m2.foreachpair( new doubleintprocedure() { public boolean apply(double key, int value) { return m1.containskey(key) && m1.get(key) == value; } } );  this implementation first checks if the specified object is this map; if so it returns true. then, it checks if the specified object is a map whose size is identical to the size of this set; if not, it it returns false. if so, it applies the iteration as described above. object to be compared for equality with this map. true if the specified object is equal to this map. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(double)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(int)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}. the value to search for. first key for which holds get(key) == value; returns double.nan if no such key exists. returns a list filled with all keys contained in the receiver. the returned list has a size that equals this.size(). note: keys are filled into the list in no particular order. however, the order is identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the keys of the receiver. keys. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all keys sorted ascending by their associated value into the specified list. fills into the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7) the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  example:   doubleintprocedure condition = new doubleintprocedure() { // match even values only public boolean apply(double key, int value) { return value%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by key into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size().  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (6,7,8), valuelist = (2,2,1) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. keys(keylist); values(valuelist); final double[] k = keylist.elements(); final int[] v = valuelist.elements(); cern.colt.swapper swapper = new cern.colt.swapper() { public void swap(int a, int b) { int t1; double t2; t1 = v[a]; v[a] = v[b]; v[b] = t1; t2 = k[a]; k[a] = k[b]; k[b] = t2; } }; cern.colt.function.intcomparator comp = new cern.colt.function.intcomparator() { public int compare(int a, int b) { return k[a]sorted ascending by value into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7), valuelist = (1,2,2) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by key. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by value. returns a list filled with all values contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the values of the receiver. values. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; // for debug only match even values only this variant may be quicker cern.colt.map.opendoubleinthashmap.hashcollisions = 0; system.out.println("collisions="+cern.colt.map.opendoubleinthashmap.hashcollisions); system.out.println("collisions="+cern.colt.map.opendoubleinthashmap.hashcollisions); cern.colt.map.opendoubleinthashmap.hashcollisions = 0; system.out.println("collisions="+cern.colt.map.opendoubleinthashmap.hashcollisions);"
cern.colt.map.AbstractIntDoubleMap "abstract base class for hash maps holding (key,value) associations of type (int-->double). first see the package summary and javadoc tree view to get the broad picture.  implementation:  almost all methods are expressed in terms of {@link #foreachkey(intprocedure)}. as such they are fully functional, but inefficient. override them in subclasses if necessary. makes this class non instantiable, but still let's others inherit from it. assigns the result of a function to each value; v[i] = function(v[i]). a function object taking as argument the current association's value. clears the receiver, then adds all (key,value) pairs of othervalues to it. the other map to be copied into the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. compares the specified object with this map for equality. returns true if the given object is also a map and the two maps represent the same mappings. more formally, two maps m1 and m2 represent the same mappings iff  m1.foreachpair( new intdoubleprocedure() { public boolean apply(int key, double value) { return m2.containskey(key) && m2.get(key) == value; } } ) && m2.foreachpair( new intdoubleprocedure() { public boolean apply(int key, double value) { return m1.containskey(key) && m1.get(key) == value; } } );  this implementation first checks if the specified object is this map; if so it returns true. then, it checks if the specified object is a map whose size is identical to the size of this set; if not, it it returns false. if so, it applies the iteration as described above. object to be compared for equality with this map. true if the specified object is equal to this map. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(double)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. returns a list filled with all keys contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. keys. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all keys sorted ascending by their associated value into the specified list. fills into the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7) the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intdoubleprocedure condition = new intdoubleprocedure() { // match even keys only public boolean apply(int key, double value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by key into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size().  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (6,7,8), valuelist = (2,2,1) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by value into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7), valuelist = (1,2,2) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by key. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by value. returns a list filled with all values contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. values. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; // for debug only match even keys only stringbuffer buf = new stringbuffer();"
cern.colt.map.AbstractIntIntMap "abstract base class for hash maps holding (key,value) associations of type (int-->int). first see the package summary and javadoc tree view to get the broad picture.  implementation:  almost all methods are expressed in terms of {@link #foreachkey(intprocedure)}. as such they are fully functional, but inefficient. override them in subclasses if necessary. makes this class non instantiable, but still let's others inherit from it. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. compares the specified object with this map for equality. returns true if the given object is also a map and the two maps represent the same mappings. more formally, two maps m1 and m2 represent the same mappings iff  m1.foreachpair( new intintprocedure() { public boolean apply(int key, int value) { return m2.containskey(key) && m2.get(key) == value; } } ) && m2.foreachpair( new intintprocedure() { public boolean apply(int key, int value) { return m1.containskey(key) && m1.get(key) == value; } } );  this implementation first checks if the specified object is this map; if so it returns true. then, it checks if the specified object is a map whose size is identical to the size of this set; if not, it it returns false. if so, it applies the iteration as described above. object to be compared for equality with this map. true if the specified object is equal to this map. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(int)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. returns a list filled with all keys contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. keys. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all keys sorted ascending by their associated value into the specified list. fills into the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7) the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intintprocedure condition = new intintprocedure() { // match even keys only public boolean apply(int key, int value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by key into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size().  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (6,7,8), valuelist = (2,2,1) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by value into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7), valuelist = (1,2,2) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by key. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by value. returns a list filled with all values contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. values. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; // for debug only match even keys only thekeys.sort();"
cern.colt.map.AbstractIntObjectMap "abstract base class for hash maps holding (key,value) associations of type (int-->object). first see the package summary and javadoc tree view to get the broad picture.  implementation:  almost all methods are expressed in terms of {@link #foreachkey(intprocedure)}. as such they are fully functional, but inefficient. override them in subclasses if necessary. makes this class non instantiable, but still let's others inherit from it. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. tests for identity. true if the receiver contains the specified value. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. compares the specified object with this map for equality. returns true if the given object is also a map and the two maps represent the same mappings. more formally, two maps m1 and m2 represent the same mappings iff  m1.foreachpair( new intobjectprocedure() { public boolean apply(int key, object value) { return m2.containskey(key) && m2.get(key) == value; } } ) && m2.foreachpair( new intobjectprocedure() { public boolean apply(int key, object value) { return m1.containskey(key) && m1.get(key) == value; } } );  this implementation first checks if the specified object is this map; if so it returns true. then, it checks if the specified object is a map whose size is identical to the size of this set; if not, it it returns false. if so, it applies the iteration as described above. object to be compared for equality with this map. true if the specified object is equal to this map. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; null if no such key is present. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(object)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. returns a list filled with all keys contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. keys. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all keys sorted ascending by their associated value into the specified list. fills into the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7) the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intobjectprocedure condition = new intobjectprocedure() { // match even keys only public boolean apply(int key, object value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by key into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size().  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (6,7,8), valuelist = (2,2,1) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by value according to natural ordering into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7), valuelist = (1,2,2) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by key. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by value, according to natural ordering. returns a list filled with all values contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. values. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; // for debug only match even keys only return v[a]v[b] ? 1 : (k[a]<k[b] ? -1 : (k[a]==k[b] ? 0 : 1));"
cern.colt.map.AbstractLongObjectMap "abstract base class for hash maps holding (key,value) associations of type (long-->object). first see the package summary and javadoc tree view to get the broad picture.  implementation:  almost all methods are expressed in terms of {@link #foreachkey(longprocedure)}. as such they are fully functional, but inefficient. override them in subclasses if necessary. makes this class non instantiable, but still let's others inherit from it. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. tests for identity. true if the receiver contains the specified value. returns a deep copy of the receiver; uses clone() and casts the result. a deep copy of the receiver. compares the specified object with this map for equality. returns true if the given object is also a map and the two maps represent the same mappings. more formally, two maps m1 and m2 represent the same mappings iff  m1.foreachpair( new longobjectprocedure() { public boolean apply(long key, object value) { return m2.containskey(key) && m2.get(key) == value; } } ) && m2.foreachpair( new longobjectprocedure() { public boolean apply(long key, object value) { return m1.containskey(key) && m1.get(key) == value; } } );  this implementation first checks if the specified object is this map; if so it returns true. then, it checks if the specified object is a map whose size is identical to the size of this set; if not, it it returns false. if so, it applies the iteration as described above. object to be compared for equality with this map. true if the specified object is equal to this map. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(long)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; null if no such key is present. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(object)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}. the value to search for. first key for which holds get(key) == value; returns long.min_value if no such key exists. returns a list filled with all keys contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the keys of the receiver. keys. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all keys sorted ascending by their associated value into the specified list. fills into the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7) the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  example:   longobjectprocedure condition = new longobjectprocedure() { // match even keys only public boolean apply(long key, object value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by key into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size().  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (6,7,8), valuelist = (2,2,1) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. fills all keys and values sorted ascending by value according to natural ordering into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size that equals this.size(). primary sort criterium is "value", secondary sort criterium is "key". this means that if any two values are equal, the smaller key comes first.  example:  keys = (8,7,6), values = (1,2,2) --> keylist = (8,6,7), valuelist = (1,2,2) the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by key. returns a string representation of the receiver, containing the string representation of each key-value pair, sorted ascending by value, according to natural ordering. returns a list filled with all values contained in the receiver. the returned list has a size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the values of the receiver. values. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; // for debug only match even keys only return v[a]v[b] ? 1 : (k[a]<k[b] ? -1 : (k[a]==k[b] ? 0 : 1));"
cern.colt.map.AbstractMap "abstract base class for hash maps holding objects or primitive data types such as int, float, etc. as keys and/or values. first see the package summary and javadoc tree view to get the broad picture.  note that implementations are not synchronized. the number of distinct associations in the map; its "size()". the table capacity c=table.length always satisfies the invariant c minloadfactor , where s=size() is the number of associations currently contained. the term "c minloadfactor" is called the "lowwatermark", "c maxloadfactor" is called the "highwatermark". in other words, the table capacity (and proportionally the memory used by this class) oscillates within these constraints. the terms are precomputed and cached to avoid recalculating them each time put(..) or removekey(...) is called. the minimum load factor for the hashtable. the maximum load factor for the hashtable. makes this class non instantiable, but still let's others inherit from it. chooses a new prime table capacity optimized for growing that (approximately) satisfies the invariant c minloadfactor  and has at least one free slot for the given size. returns new high water mark threshold based on current capacity and maxloadfactor. the new threshold. returns new low water mark threshold based on current capacity and minloadfactor. the new threshold. chooses a new prime table capacity neither favoring shrinking nor growing, that (approximately) satisfies the invariant c minloadfactor  and has at least one free slot for the given size. chooses a new prime table capacity optimized for shrinking that (approximately) satisfies the invariant c minloadfactor  and has at least one free slot for the given size. removes all (key,value) associations from the receiver. ensures that the receiver can hold at least the specified number of elements without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times.  this default implementation does nothing. override this method if necessary. mincapacity the desired minimum capacity. returns true if the receiver contains no (key,value) associations. true if the receiver contains no (key,value) associations. returns a prime number which is &gt;= desiredcapacity and very close to desiredcapacity (within 11% if desiredcapacity &gt;= 1000). the capacity desired by the initializes the receiver. you will almost certainly need to override this method in subclasses to initialize the hash table. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). returns the number of (key,value) associations currently contained. number of (key,value) associations currently contained. trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver.  this default implementation does nothing. override this method if necessary. public static boolean debug = false; // debug only makes sure there is always at least one free slot"
cern.colt.map.Benchmark "benchmarks the classes of this package. makes this class non instantiable, but still let's others inherit from it.  tests various methods of this class.  system.out.println(map.containskey(3)); system.out.println(map.get(3)); system.out.println(map.containskey(4)); system.out.println(map.get(4)); system.out.println(map.containsvalue((int)71.0)); system.out.println(map.keyof((int)71.0)); if (map instanceof quickopenintinthashmap) { system.out.println("totalprobessaved="+((quickopenintinthashmap)map).totalprobessaved); } system.out.println("probes="+map.hashcollisions); map.hashcollisions = 0; for (int i=size; --i >=0; ) { map.hashcollisions = 0; map.ensurecapacity(size3); system.out.println("collisions="+map.hashcollisions); boolean add = args[2].equals("add"); using a map int[] keys = {0 , 3 , 277+3, 2772+3, 100000, 9 }; double[] values = {100.0, 1000.0, 277+3, 2772+3, 70.0 , 71.0 ,}; int[] keys = {0,1,3,4,5,6, 271,272,273,274,275,276,277+5, 277+6,277+7}; abstractintintmap map = new openintinthashmap(size2, 0.2, 0.5); system.out.println(map); system.out.println(map); system.out.println(map.keys()); system.out.println(map.values()); system.out.println(map); system.out.println("probes="+map.hashcollisions);"
cern.colt.map.HashFunctions "provides various hash functions. makes this class non instantiable, but still let's others inherit from it. returns a hashcode for the specified value. a hash code value for the specified value. returns a hashcode for the specified value. a hash code value for the specified value. returns a hashcode for the specified value. a hash code value for the specified value. returns a hashcode for the specified value. a hash code value for the specified value. value &= 0x7fffffff; // make it >=0 int hashcode = 0; do hashcode = 31hashcode + value%10; while ((value /= 10) > 0); return 28629151hashcode; // spread even further; h31^5 returns a hashcode for the specified value. a hash code value for the specified value. value &= 0x7fffffffffffffffl; // make it >=0 (0x7fffffffffffffffl==long.max_value) int hashcode = 0; do hashcode = 31hashcode + (int) (value%10); while ((value /= 10) > 0); return 28629151hashcode; // spread even further; h31^5 returns a hashcode for the specified object. a hash code value for the specified object. returns a hashcode for the specified value. a hash code value for the specified value. returns a hashcode for the specified value. a hash code value for the specified value. return (int) double.doubletolongbits(value663608941.737); this avoids excessive hashcollisions in the case values are of the form (1.0, 2.0, 3.0, ...) this avoids excessive hashcollisions in the case values are of the form (1.0, 2.0, 3.0, ...) return value 0x278dde6d; // see cern.jet.random.engine.drand make it >=0 spread even further; h31^5 make it >=0 (0x7fffffffffffffffl==long.max_value) spread even further; h31^5"
cern.colt.map.OpenDoubleIntHashMap "hash map holding (key,value) associations of type (double-->int); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. overrides many methods for performance reasons only. the hash table keys. @serial the hash table values. @serial the state of each hash table entry (free, full, removed). @serial the number of table entries in state==free. @serial constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). removes all (key,value) associations from the receiver. implicitly calls trimtosize(). returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. mincapacity the desired minimum capacity. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(double)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. the key to be added to the receiver. index where the key would need to be inserted, if it is not already contained. returns -index-1 if the key is already contained at slot index. therefore, if the returned index = 0, then it is not already contained and should be inserted at slot index. the key to be searched in the receiver. index where the key is contained in the receiver, returns -1 if the key was not found. the value to be searched in the receiver. index where the value is contained in the receiver, returns -1 if the value was not found. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(int)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}. the value to search for. first key for which holds get(key) == value; returns double.nan if no such key exists. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  example:   doubleintprocedure condition = new doubleintprocedure() { // match even values only public boolean apply(double key, int value) { return value%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. system.out.print("grow rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); rehashes the contents of the receiver into a new table with a smaller or larger capacity. this method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. if (table.length != newcapacity) { system.out.print("shrink rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); } initializes the receiver. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(doubleprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. new doublearraylist(values).fillfromtowith(0, state.length-1, 0); // delta delta not contained double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a removed or free slot, or if we find the key itself do not skip over removed slots (yes, open addressing is like that...) hashcollisions++; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; key already contained at slot i. return a negative number identifying the slot. not already contained, should be inserted at slot i. return a number >= 0 identifying the slot. double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) hashcollisions++; not found found, return index where key is contained not found returns the first key found; there may be more matching keys, however. match even values only already contained delta if (oldcapacity == newcapacity) return; delta key not contained this.values[i]=0; // delta open addressing needs at least one free slot at any time. memory will be exhausted long before this pathological case happens, anyway. delta lowwatermark will be established upon first expansion. establishing it now (upon instance construction) would immediately make the table shrink upon first put(...). after all the idea of an "initialcapacity" implies violating lowwatermarks when an object is young. see ensurecapacity(...) 1.2 because open addressing's performance exponentially degrades beyond that point so that even rehashing the table can take very long"
cern.colt.map.OpenIntDoubleHashMap "hash map holding (key,value) associations of type (int-->double); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. overrides many methods for performance reasons only. the hash table keys. @serial the hash table values. @serial the state of each hash table entry (free, full, removed). @serial the number of table entries in state==free. @serial constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). assigns the result of a function to each value; v[i] = function(v[i]). a function object taking as argument the current association's value. clears the receiver, then adds all (key,value) pairs of othervalues to it. the other map to be copied into the receiver. removes all (key,value) associations from the receiver. implicitly calls trimtosize(). if (debug) { for (int i=table.length; --i >= 0; ) { state[i] = free; table[i]= integer.max_value; values[i]= double.nan; } } returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. mincapacity the desired minimum capacity. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. the key to be added to the receiver. index where the key would need to be inserted, if it is not already contained. returns -index-1 if the key is already contained at slot index. therefore, if the returned index = 0, then it is not already contained and should be inserted at slot index. the key to be searched in the receiver. index where the key is contained in the receiver, else returns -1. the value to be searched in the receiver. index where the value is contained in the receiver, returns -1 if the value was not found. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(double)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intdoubleprocedure condition = new intdoubleprocedure() { // match even keys only public boolean apply(int key, double value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. system.out.print("grow rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); rehashes the contents of the receiver into a new table with a smaller or larger capacity. this method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. if (table.length != newcapacity) { system.out.print("shrink rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); } initializes the receiver. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. public static int hashcollisions = 0; specialization for speed x[i] = multx[i] the general case x[i] = f(x[i]) new doublearraylist(values).fillfromtowith(0, state.length-1, 0); // delta delta not contained double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a removed or free slot, or if we find the key itself do not skip over removed slots (yes, open addressing is like that...) hashcollisions++; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; key already contained at slot i. return a negative number identifying the slot. not already contained, should be inserted at slot i. return a number >= 0 identifying the slot. double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; not found found, return index where key is contained not found returns the first key found; there may be more matching keys, however. match even keys only already contained if (debug) if (this.state[i] != full) throw new internalerror(); if (debug) if (this.table[i] != key) throw new internalerror(); delta if (oldcapacity == newcapacity) return; if (debug) check(); delta if (debug) check(); key not contained if (debug) if (this.state[i] == free) throw new internalerror(); if (debug) if (this.state[i] == removed) throw new internalerror(); this.values[i]=0; // delta if (debug) this.table[i]=integer.max_value; // delta if (debug) this.values[i]=double.nan; // delta open addressing needs at least one free slot at any time. memory will be exhausted long before this pathological case happens, anyway. delta lowwatermark will be established upon first expansion. establishing it now (upon instance construction) would immediately make the table shrink upon first put(...). after all the idea of an "initialcapacity" implies violating lowwatermarks when an object is young. see ensurecapacity(...) 1.2 because open addressing's performance exponentially degrades beyond that point so that even rehashing the table can take very long"
cern.colt.map.OpenIntIntHashMap "hash map holding (key,value) associations of type (int-->int); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. overrides many methods for performance reasons only. the hash table keys. @serial the hash table values. @serial the state of each hash table entry (free, full, removed). @serial the number of table entries in state==free. @serial constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). removes all (key,value) associations from the receiver. implicitly calls trimtosize(). returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. mincapacity the desired minimum capacity. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; 0 if no such key is present. the key to be added to the receiver. index where the key would need to be inserted, if it is not already contained. returns -index-1 if the key is already contained at slot index. therefore, if the returned index = 0, then it is not already contained and should be inserted at slot index. the key to be searched in the receiver. index where the key is contained in the receiver, returns -1 if the key was not found. the value to be searched in the receiver. index where the value is contained in the receiver, returns -1 if the value was not found. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(int)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intintprocedure condition = new intintprocedure() { // match even keys only public boolean apply(int key, int value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. rehashes the contents of the receiver into a new table with a smaller or larger capacity. this method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. if (table.length != newcapacity) { system.out.print("shrink rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); } initializes the receiver. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. new intarraylist(values).fillfromtowith(0, state.length-1, 0); // delta delta not contained system.out.println("key="+key); double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a removed or free slot, or if we find the key itself do not skip over removed slots (yes, open addressing is like that...) hashcollisions++; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; key already contained at slot i. return a negative number identifying the slot. not already contained, should be inserted at slot i. return a number >= 0 identifying the slot. double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) hashcollisions++; not found found, return index where key is contained not found returns the first key found; there may be more matching keys, however. match even keys only already contained system.out.print("grow rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); delta if (oldcapacity == newcapacity) return; delta key not contained this.values[i]=0; // delta open addressing needs at least one free slot at any time. memory will be exhausted long before this pathological case happens, anyway. delta lowwatermark will be established upon first expansion. establishing it now (upon instance construction) would immediately make the table shrink upon first put(...). after all the idea of an "initialcapacity" implies violating lowwatermarks when an object is young. see ensurecapacity(...) 1.2 because open addressing's performance exponentially degrades beyond that point so that even rehashing the table can take very long"
cern.colt.map.OpenIntObjectHashMap "hash map holding (key,value) associations of type (int-->object); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. overrides many methods for performance reasons only. the hash table keys. @serial the hash table values. @serial the state of each hash table entry (free, full, removed). @serial the number of table entries in state==free. @serial constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). removes all (key,value) associations from the receiver. implicitly calls trimtosize(). returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. mincapacity the desired minimum capacity. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(int)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; null if no such key is present. the key to be added to the receiver. index where the key would need to be inserted, if it is not already contained. returns -index-1 if the key is already contained at slot index. therefore, if the returned index = 0, then it is not already contained and should be inserted at slot index. the key to be searched in the receiver. index where the key is contained in the receiver, returns -1 if the key was not found. the value to be searched in the receiver. index where the value is contained in the receiver, returns -1 if the value was not found. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(object)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}. the value to search for. first key for which holds get(key) == value; returns integer.min_value if no such key exists. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  example:   intobjectprocedure condition = new intobjectprocedure() { // match even keys only public boolean apply(int key, object value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. rehashes the contents of the receiver into a new table with a smaller or larger capacity. this method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. initializes the receiver. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(intprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. delta delta not contained double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a removed or free slot, or if we find the key itself do not skip over removed slots (yes, open addressing is like that...) hashcollisions++; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; key already contained at slot i. return a negative number identifying the slot. not already contained, should be inserted at slot i. return a number >= 0 identifying the slot. double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) hashcollisions++; not found found, return index where key is contained not found returns the first key found; there may be more matching keys, however. match even keys only already contained delta if (oldcapacity == newcapacity) return; delta key not contained delta open addressing needs at least one free slot at any time. memory will be exhausted long before this pathological case happens, anyway. delta lowwatermark will be established upon first expansion. establishing it now (upon instance construction) would immediately make the table shrink upon first put(...). after all the idea of an "initialcapacity" implies violating lowwatermarks when an object is young. see ensurecapacity(...) 1.2 because open addressing's performance exponentially degrades beyond that point so that even rehashing the table can take very long"
cern.colt.map.OpenLongObjectHashMap "hash map holding (key,value) associations of type (long-->object); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. overrides many methods for performance reasons only. the hash table keys. @serial the hash table values. @serial the state of each hash table entry (free, full, removed). @serial the number of table entries in state==free. @serial constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). removes all (key,value) associations from the receiver. implicitly calls trimtosize(). returns a deep copy of the receiver. a deep copy of the receiver. returns true if the receiver contains the specified key. true if the receiver contains the specified key. returns true if the receiver contains the specified value. true if the receiver contains the specified value. ensures that the receiver can hold at least the specified number of associations without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before put()ing a large number of associations boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. mincapacity the desired minimum capacity. applies a procedure to each key of the receiver, if any. note: iterates over the keys in no particular order. subclasses can define a particular order, for example, "sorted by key". all methods which can be expressed in terms of this method (most methods can) must guarantee to use the same order defined by this method, even if it is no particular order. this is necessary so that, for example, methods keys and values will yield association pairs, not two uncorrelated lists. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. applies a procedure to each (key,value) pair of the receiver, if any. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all keys where iterated over, true otherwise. returns the value associated with the specified key. it is often a good idea to first check with {@link #containskey(long)} whether the given key has a value associated or not, i.e. whether there exists an association for the given key or not. the key to be searched for. value associated with the specified key; null if no such key is present. the key to be added to the receiver. index where the key would need to be inserted, if it is not already contained. returns -index-1 if the key is already contained at slot index. therefore, if the returned index = 0, then it is not already contained and should be inserted at slot index. the key to be searched in the receiver. index where the key is contained in the receiver, returns -1 if the key was not found. the value to be searched in the receiver. index where the value is contained in the receiver, returns -1 if the value was not found. returns the first key the given value is associated with. it is often a good idea to first check with {@link #containsvalue(object)} whether there exists an association from a key to this value. search order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}. the value to search for. first key for which holds get(key) == value; returns long.min_value if no such key exists. fills all keys contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the keys of the receiver. the list to be filled, can have any size. fills all pairs satisfying a given condition into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists both have a new size, the number of pairs satisfying the condition. iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  example:   longobjectprocedure condition = new longobjectprocedure() { // match even keys only public boolean apply(long key, object value) { return key%2==0; } } keys = (8,7,6), values = (1,2,2) --> keylist = (6,8), valuelist = (2,1)  the condition to be matched. takes the current key as first and the current value as second argument. the list to be filled with keys, can have any size. the list to be filled with values, can have any size. associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. rehashes the contents of the receiver into a new table with a smaller or larger capacity. this method is called automatically when the number of keys in the receiver exceeds the high water mark or falls below the low water mark. removes the given key with its associated element from the receiver, if present. the key to be removed from the receiver. true if the receiver contained the specified key, false otherwise. initializes the receiver. initialcapacity the initial capacity of the receiver. minloadfactor the minloadfactor of the receiver. maxloadfactor the maxloadfactor of the receiver. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). trims the capacity of the receiver to be the receiver's current size. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver. fills all values contained in the receiver into the specified list. fills the list, starting at index 0. after this call returns the specified list has a new size that equals this.size(). iteration order is guaranteed to be identical to the order used by method {@link #foreachkey(longprocedure)}.  this method can be used to iterate over the values of the receiver. the list to be filled, can have any size. delta delta not contained double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a removed or free slot, or if we find the key itself do not skip over removed slots (yes, open addressing is like that...) hashcollisions++; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) assertion: there is at least one free slot. hashcollisions++; key already contained at slot i. return a negative number identifying the slot. not already contained, should be inserted at slot i. return a number >= 0 identifying the slot. double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html int decrement = (hash / length) % length; stop if we find a free slot, or if we find the key itself. do skip over removed slots (yes, open addressing is like that...) hashcollisions++; not found found, return index where key is contained not found returns the first key found; there may be more matching keys, however. match even keys only already contained delta if (oldcapacity == newcapacity) return; delta key not contained delta open addressing needs at least one free slot at any time. memory will be exhausted long before this pathological case happens, anyway. delta lowwatermark will be established upon first expansion. establishing it now (upon instance construction) would immediately make the table shrink upon first put(...). after all the idea of an "initialcapacity" implies violating lowwatermarks when an object is young. see ensurecapacity(...) 1.2 because open addressing's performance exponentially degrades beyond that point so that even rehashing the table can take very long"
cern.colt.map.PrimeFinder "not of interest for the largest prime this class can generate; currently equal to integer.max_value. the prime number list consists of 11 chunks. each chunk contains prime numbers. a chunk starts with a prime p1. the next element is a prime p2. p2 is the smallest prime for which holds: p2 >= 2p1. the next element is p3, for which the same holds with respect to p2, and so on. chunks are chosen such that for any desired capacity >= 1000 the list includes a prime number = 200 the list includes a prime number = 16 the list includes a prime number = 1040, you will find a prime  1 kb of static memory needed. if you are stingy, then delete every second or fourth chunk. // some more chunks for the low range [3..1000] //chunk #11 13,29,59,127,257,521,1049,2099,4201,8419,16843,33703,67409,134837,269683, 539389,1078787,2157587,4315183,8630387,17260781,34521589,69043189,138086407, 276172823,552345671,1104691373, //chunk #12 19,41,83,167,337,677, //1361,2729,5471,10949,21911,43853,87719,175447,350899, //701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557, //359339171,718678369,1437356741, //chunk #13 53,107,223,449,907,1823,3659,7321,14653,29311,58631,117269, 234539,469099,938207,1876417,3752839,7505681,15011389,30022781, 60045577,120091177,240182359,480364727,960729461,1921458943 makes this class non instantiable, but still let's others inherit from it. tests correctness. try from=1000, to=10000 from=200, to=1000 from=16, to=1000 from=1000, to=integer.max_value returns a prime number which is &gt;= desiredcapacity and very close to desiredcapacity (within 11% if desiredcapacity &gt;= 1000). the capacity desired by the tests correctness. yes, it is prime. chunk #0 chunk #1 chunk #2 chunk #3 chunk #4 chunk #5 chunk #6 chunk #7 chunk #8 chunk #9 chunk #10 some more chunks for the low range [3..1000] chunk #11 chunk #12 1361,2729,5471,10949,21911,43853,87719,175447,350899, 701819,1403641,2807303,5614657,11229331,22458671,44917381,89834777,179669557, 359339171,718678369,1437356741, chunk #13 initializer the above prime numbers are formatted for human readability. to find numbers fast, we sort them once and for all. new cern.colt.list.intarraylist(primecapacities).mergesort(); // for debug only, todo int i = new cern.colt.list.intarraylist(primecapacities).binarysearch(desiredcapacity); // for debug only todo desired capacity not found, choose next prime greater than desired capacity remember the semantics of binarysearch... check that primes contain no accidental errors system.out.println(primecapacity);"
cern.colt.map.QuickOpenIntIntHashMap "status: experimental; do not use for production yet. hash map holding (key,value) associations of type (int-->int); automatically grows and shrinks as needed; implemented using open addressing with double hashing. first see the package summary and javadoc tree view to get the broad picture. implements open addressing with double hashing, using "brent's variation". brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors. (it does not improve unsuccessful searches.) see d. knuth, searching and sorting, 3rd ed., p.533-545 constructs an empty map with default capacity and default load factors. constructs an empty map with the specified initial capacity and default load factors. initialcapacity the initial capacity of the map. @throws illegalargumentexception if the initial capacity is less than zero. constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor. initialcapacity the initial capacity. minloadfactor the minimum load factor. maxloadfactor the maximum load factor. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). associates the given key with the given value. replaces any old (key,someothervalue) association, if existing. the key the value shall be associated with. the value to be associated. true if the receiver did not already contain such a key; false if the receiver did already contain such a key - the new value has now replaced the formerly associated value. this is open addressing with double hashing, using "brent's variation". brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches, in particular for large load factors. (it does not improve unsuccessful searches.) see d. knuth, searching and sorting, 3rd ed., p.533-545 h1(key) = hash % m h2(key) = decrement = max(1, hash/m % m) m is prime = capacity = table.length probing positions are table[(h1-jh2) % m] for j=0,1,... (m and h2 could also be chosen differently, but h2 is required to be relative prime to m.) brent's variation does a local reorganization to reduce probes. it essentially means: we test whether it is possible to move the association we probed first (table[p0]) out of the way. if this is possible, it will reduce probes for the key to be inserted, since it takes its place; it gets hit earlier. however, future probes for the key that we move out of the way will increase. thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose. for the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2). if the first probe cannot be moved out of the way, we try the next probe (p1). now we safe more than we loose if t>=3. we repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way. note: under the great majority of insertions t0) system.out.println("probed "+(comparisons-comp)+" slots."); key already contained at slot i. not already contained, should be inserted at slot i. system.out.print("grow rehashing "); system.out.println("at distinct="+distinct+", capacity="+table.length+" to newcapacity="+newcapacity+" ..."); system.out.println("t="+t); pc = (p0-jdecrement) % m, j=1,2,.. not a free slot, continue searching for free slot to move to, or break. free or removed slot found, now move... system.out.println("copying p0="+p0+" to pc="+pc+", (key,val)=("+tab[p0]+","+values[p0]+"), saving "+(t-1)+" probes."); prepare to insert: table[p0]=key break loop system.out.println("inserting at i="+i); delta if (oldcapacity == newcapacity) return; delta switch of watermarks"
cern.colt.matrix.bench.BenchmarkKernel "not yet documented. benchmark constructor comment. executes procedure repeatadly until more than minseconds have elapsed. returns a string with the system's properties (vendor, version, operating system, etc.) "java.vm.specification.version", "java.vm.specification.vendor", "java.vm.specification.name", "java.specification.version", "java.specification.vendor", "java.specification.name" unreliable timing due to very fast iteration; reading, starting and stopping timer distorts measurement do it again with minimal timer overhead system.out.println("iter="+iter+", minseconds/iter="+minseconds/iter); prevent compiler from optimizing away the loop if (dummy != 0) throw new runtimeexception("dummy != 0"); build string matrix retrieve property values prop not available format matrix"
cern.colt.matrix.bench.BenchmarkMatrix "configurable matrix benchmark. runs the operations defined in main(args) or in the file specified by args. to get this overall help on usage type java cern.colt.matrix.bench.benchmarkmatrix -help. to get help on usage of a given command, type java cern.colt.matrix.bench.benchmarkmatrix -help &lt;command&gt;. here is the help ouput for the dgemm command. here is a sample result. for more results see the performance log. benchmark constructor comment. not yet documented. not yet documented. not yet documented. not yet documented.  linear algebrax matrix-matrix multiply. linear algebrax matrix-matrix multiply. 2d assign with get,set 2d assign with a.assign(b) 2d assign with get,set for (int row=rows; --row >= 0; ) { for (int column=columns; --column >= 0; ) { a.set(row,column, b.get(row,column)); } } 2d assign with getquick,setquick 2d assign with a.assign(b) 2d assign with a.assign(b) linear algebrax matrix-matrix multiply. element-by-element matrix-matrix multiply. element-by-element matrix-matrix multiply. 2d assign with get,set 2d assign with getquick,setquick 2d assign with getquick,setquick linear algebrax matrix-matrix multiply. linear algebrax matrix-vector multiply. 2d assign with get,set    not yet documented. not yet documented. else if (cmd.equals("xxxxxxxxxxxxxxxxx")) return xxxxx(); } executes a command runs the matrix benchmark operations defined in args or in the file specified by args0. to get detailed help on usage type java cern.colt.matrix.bench.benchmarkmatrix -help parse command file in args[0] one command per line (including parameters) for example: // dgemm dense 2 2.0 false true 0.999 10 30 50 100 250 500 1000 dgemm dense 2 2.5 false true 0.999 10 50 dgemm sparse 2 2.5 false true 0.001 500 1000 comments java.io.inputstream input = new java.io.datainputstream(new java.io.bufferedinputstream(new java.io.fileinputstream(args[1]))); bufferedreader d = new bufferedreader(new inputstreamreader(in)); executes procedure repeatadly until more than minseconds have elapsed. title = "speedup of dense over sparse"; doublematrix2d speedup = cern.colt.matrix.doublealgo.transform.div(timings.viewslice(0).copy(),timings.viewslice(1)); system.out.println("\n"+new cern.colt.matrix.doublealgo.formatter("%1.3g").totitlestring(speedup,rownames,colnames,rowaxisname,colaxisname,title,aggr)); executes procedure repeatadly until more than minseconds have elapsed. overall usage. \n"+ "java like comments in file are ignored\n"+ "dgemv dense 1 2.0 0.001 false 5 10 25 50 100 250 500 1000\n"+ "dgemv sparse 1 2.0 0.001 false 5 10 25 50 100 250 500 1000\n"+ "dgemv rowcompressed 1 2.0 0.001 false 5 10 25 50 100 250 500 1000\n"+ " usage of a specific command. parse parse parse parse mflops mflops double p = b.columns(); must be nonsingular for inversion mflops identity lu.decompose lu.solve mult for (int row=rows; --row >= 0; ) { for (int column=columns; --column >= 0; ) { mflops transposed --> faster (memory aware) iteration in correlation algo mflops for (int row=rows; --row >= 0; ) { for (int column=columns; --column >= 0; ) { mflops mflops do not allocate mem for "d" --> safe some mem mflops mflops double p = b.columns(); for (int row=rows; --row >= 0; ) { for (int column=columns; --column >= 0; ) { a very fast random number generator (this is an inline version of class cern.jet.random.engine.drand) random uniform in (0.0,1.0) mflops mflops overall help help on specific command interactive mode, commands supplied via java class args batch mode, read commands from file dgemm dense 2 2.0 false true 0.999 10 30 50 100 250 500 1000 allow // comments allow / comments / while not end of file execute a command line at a time system.out.println(words); ignore emty lines execute command ok: 2.0 -> 2 wrong: 2.0 -> 2.0 (kills integer.parseint()) while not end of file int[] sizes = {33,500,1000}; double[] densities = {0.001,0.01,0.99}; int[] sizes = {3,5,7,9,30,45,60,61,100,200,300,500,800,1000}; double[] densities = {0.001,0.01,0.1,0.999}; int[] sizes = {3}; double[] densities = {0.1}; doublefactory2d factory = (k==0 ? doublefactory2d.dense : k==1 ? doublefactory2d.sparse : doublefactory2d.rowcompressed); doublefactory2d factory = (k==0 ? doublefactory2d.dense : k==1 ? doublefactory2d.sparse : k==2 ? doublefactory2d.rowcompressed : doublefactory2d.rowcompressedmodified); system.out.println("doing size="+size+"..."); system.out.println(" doing density="+density+"..."); if (true) { if (!((k==1 && density >= 0.1 && size >=100) || (size>5000 && (k==0 || density>1.0e-4) ))) { --> help gc before allocating new mem help gc skip this parameter combination (not used in practice & would take a lot of memory and time) system.out.println(secs); system.out.println(opspersec+" mops/sec\n"); "density"; string[] slicenames = {"dense", "sparse"}; string[] slicenames = {"dense", "sparse", "rowcompressed"}; {f.mean, f.median, f.sum}; show transposed --> help gc before allocating new mem help gc system.out.println(secs); system.out.println(opspersec+" mops/sec\n"); {f.mean, f.median, f.sum}; more comments ignored\n"; string usage = "illegal arguments! arguments to be supplied:\n" + "\te.g. "+cmd+" dense 2 2.0 false 0.999 10 30 50 100 250 500 1000\n"+"
cern.colt.matrix.bench.Double2DProcedure "the number of operations a single call to "apply" involves. sets the matrices to operate upon."
cern.colt.matrix.bench.TimerProcedure "interface that represents a procedure object: a procedure that takes a single argument and does not return a value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure. prepare parameters before calling apply()"
cern.colt.matrix.doublealgo.DoubleMatrix1DComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.matrix.doublealgo.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.matrix.doublealgo.DoubleMatrix2DComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.matrix.doublealgo.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.matrix.doublealgo.Formatter "flexible, well human readable matrix print formatting; by default decimal point aligned. build on top of the c-like sprintf functionality provided by the {@link corejava.format} class written by cay horstmann. currenly works on 1-d, 2-d and 3-d matrices. note that in most cases you will not need to get familiar with this class; just call matrix.tostring() and be happy with the default formatting. this class is for advanced requirements.  can't exactly remember the syntax of printf format strings? see {@link corejava.format} or henrik nordberg's documentation, or the dinkumware's c library reference. examples:  examples demonstrate usage on 2-d matrices. 1-d and 3-d matrices formatting works very similar.   original matrix    double[][] values = { {3, 0, -3.4, 0}, {5.1 ,0, +3.0123456789, 0},  {16.37, 0.0, 2.5, 0},  {-16.3, 0, -3.012345678e-4, -1}, {1236.3456789, 0, 7, -1.2} }; matrix = new densedoublematrix2d(values);    &nbsp;   format formatter.tostring(matrix); formatter.tosourcecode(matrix);   %g  (default) 5&nbsp;x&nbsp;4&nbsp;matrix &nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;3.012346&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-0.000301&nbsp;-1&nbsp;&nbsp; 1236.345679&nbsp;0&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.2  { &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;&nbsp;3.012346,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;-0.000301,&nbsp;-1&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{1236.345679,&nbsp;0,&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-1.2} };    %1.10g 5&nbsp;x&nbsp;4&nbsp;matrix &nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;3.0123456789&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp; &nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;-0.0003012346&nbsp;-1&nbsp;&nbsp; 1236.3456789&nbsp;0&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.2  { &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;&nbsp;3.0123456789,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{&nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0,&nbsp;-0.0003012346,&nbsp;-1&nbsp;&nbsp;}, &nbsp;&nbsp;&nbsp;{1236.3456789,&nbsp;0,&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-1.2} };    %f   5&nbsp;x&nbsp;4&nbsp;matrix &nbsp;&nbsp;&nbsp;3.000000&nbsp;0.000000&nbsp;-3.400000&nbsp;&nbsp;0.000000 &nbsp;&nbsp;&nbsp;5.100000&nbsp;0.000000&nbsp;&nbsp;3.012346&nbsp;&nbsp;0.000000 &nbsp;&nbsp;16.370000&nbsp;0.000000&nbsp;&nbsp;2.500000&nbsp;&nbsp;0.000000 &nbsp;-16.300000&nbsp;0.000000&nbsp;-0.000301&nbsp;-1.000000 1236.345679&nbsp;0.000000&nbsp;&nbsp;7.000000&nbsp;-1.200000    { &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;3.000000,&nbsp;0.000000,&nbsp;-3.400000,&nbsp;&nbsp;0.000000}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;5.100000,&nbsp;0.000000,&nbsp;&nbsp;3.012346,&nbsp;&nbsp;0.000000}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;16.370000,&nbsp;0.000000,&nbsp;&nbsp;2.500000,&nbsp;&nbsp;0.000000}, &nbsp;&nbsp;&nbsp;{&nbsp;-16.300000,&nbsp;0.000000,&nbsp;-0.000301,&nbsp;-1.000000}, &nbsp;&nbsp;&nbsp;{1236.345679,&nbsp;0.000000,&nbsp;&nbsp;7.000000,&nbsp;-1.200000} };     %1.2f 5&nbsp;x&nbsp;4&nbsp;matrix &nbsp;&nbsp;&nbsp;3.00&nbsp;0.00&nbsp;-3.40&nbsp;&nbsp;0.00 &nbsp;&nbsp;&nbsp;5.10&nbsp;0.00&nbsp;&nbsp;3.01&nbsp;&nbsp;0.00 &nbsp;&nbsp;16.37&nbsp;0.00&nbsp;&nbsp;2.50&nbsp;&nbsp;0.00 &nbsp;-16.30&nbsp;0.00&nbsp;-0.00&nbsp;-1.00 1236.35&nbsp;0.00&nbsp;&nbsp;7.00&nbsp;-1.20  { &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;3.00,&nbsp;0.00,&nbsp;-3.40,&nbsp;&nbsp;0.00}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;5.10,&nbsp;0.00,&nbsp;&nbsp;3.01,&nbsp;&nbsp;0.00}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;16.37,&nbsp;0.00,&nbsp;&nbsp;2.50,&nbsp;&nbsp;0.00}, &nbsp;&nbsp;&nbsp;{&nbsp;-16.30,&nbsp;0.00,&nbsp;-0.00,&nbsp;-1.00}, &nbsp;&nbsp;&nbsp;{1236.35,&nbsp;0.00,&nbsp;&nbsp;7.00,&nbsp;-1.20} };    %0.2e 5&nbsp;x&nbsp;4&nbsp;matrix &nbsp;3.00e+000&nbsp;0.00e+000&nbsp;-3.40e+000&nbsp;&nbsp;0.00e+000 &nbsp;5.10e+000&nbsp;0.00e+000&nbsp;&nbsp;3.01e+000&nbsp;&nbsp;0.00e+000 &nbsp;1.64e+001&nbsp;0.00e+000&nbsp;&nbsp;2.50e+000&nbsp;&nbsp;0.00e+000 -1.63e+001&nbsp;0.00e+000&nbsp;-3.01e-004&nbsp;-1.00e+000 &nbsp;1.24e+003&nbsp;0.00e+000&nbsp;&nbsp;7.00e+000&nbsp;-1.20e+000  { &nbsp;&nbsp;&nbsp;{&nbsp;3.00e+000,&nbsp;0.00e+000,&nbsp;-3.40e+000,&nbsp;&nbsp;0.00e+000}, &nbsp;&nbsp;&nbsp;{&nbsp;5.10e+000,&nbsp;0.00e+000,&nbsp;&nbsp;3.01e+000,&nbsp;&nbsp;0.00e+000}, &nbsp;&nbsp;&nbsp;{&nbsp;1.64e+001,&nbsp;0.00e+000,&nbsp;&nbsp;2.50e+000,&nbsp;&nbsp;0.00e+000}, &nbsp;&nbsp;&nbsp;{-1.63e+001,&nbsp;0.00e+000,&nbsp;-3.01e-004,&nbsp;-1.00e+000}, &nbsp;&nbsp;&nbsp;{&nbsp;1.24e+003,&nbsp;0.00e+000,&nbsp;&nbsp;7.00e+000,&nbsp;-1.20e+000} };    null 5&nbsp;x&nbsp;4&nbsp;matrix  &nbsp;&nbsp;&nbsp;3.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0 &nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;&nbsp;3.0123456789&nbsp;&nbsp;&nbsp;&nbsp;0.0 &nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0 &nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;-3.012345678e-4&nbsp;-1.0 1236.3456789&nbsp;0.0&nbsp;&nbsp;7.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-1.2     { &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;3.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0.0,&nbsp;-3.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.0}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;5.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0.0,&nbsp;&nbsp;3.0123456789&nbsp;&nbsp;,&nbsp;&nbsp;0.0}, &nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;16.37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0.0,&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;&nbsp;0.0}, &nbsp;&nbsp;&nbsp;{&nbsp;-16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;0.0,&nbsp;-3.012345678e-4,&nbsp;-1.0}, &nbsp;&nbsp;&nbsp;{1236.3456789,&nbsp;0.0,&nbsp;&nbsp;7.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,&nbsp;-1.2} };     here are some more elaborate examples, adding labels for axes, rows, columns, title and some statistical aggregations.     double[][] values = { {5 ,10, 20, 40 }, { 7, 8 , 6 , 7 }, {12 ,10, 20, 19 }, { 3, 1 , 5 , 6 } };  string title = "cpu performance over time [nops/sec]"; string columnaxisname = "year"; string rowaxisname = "cpu";  string[] columnnames = {"1996", "1997", "1998", "1999"}; string[] rownames = { "powerbar", "benzol", "mercedes", "sparcling"}; hep.aida.bin.binfunctions1d f = hep.aida.bin.binfunctions1d.functions; // alias hep.aida.bin.binfunction1d[] aggr = {f.mean, f.rms, f.quantile(0.25), f.median, f.quantile(0.75), f.stddev, f.min, f.max}; string format = "%1.2g"; doublematrix2d matrix = new densedoublematrix2d(values);  new formatter(format).totitlestring( &nbsp;&nbsp;&nbsp;matrix,rownames,columnnames,rowaxisname,columnaxisname,title,aggr);       cpu&nbsp;performance&nbsp;over&nbsp;time&nbsp;[nops/sec] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;year &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1996&nbsp;&nbsp;1997&nbsp;&nbsp;1998&nbsp;&nbsp;1999&nbsp;&nbsp;|&nbsp;mean&nbsp;&nbsp;rms&nbsp;&nbsp;&nbsp;25%&nbsp;q.&nbsp;median&nbsp;75%&nbsp;q.&nbsp;stddev&nbsp;min&nbsp;max --------------------------------------------------------------------------------------- c&nbsp;powerbar&nbsp;&nbsp;|&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;18.75&nbsp;23.05&nbsp;&nbsp;8.75&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15.48&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;40&nbsp; p&nbsp;benzol&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.04&nbsp;&nbsp;6.75&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7.25&nbsp;&nbsp;&nbsp;0.82&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;8&nbsp; u&nbsp;mercedes&nbsp;&nbsp;|&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;15.25&nbsp;15.85&nbsp;11.5&nbsp;&nbsp;&nbsp;15.5&nbsp;&nbsp;&nbsp;19.25&nbsp;&nbsp;&nbsp;4.99&nbsp;&nbsp;10&nbsp;&nbsp;20&nbsp; &nbsp;&nbsp;sparcling&nbsp;|&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;3.75&nbsp;&nbsp;4.21&nbsp;&nbsp;2.5&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5.25&nbsp;&nbsp;&nbsp;2.22&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;6&nbsp; --------------------------------------------------------------------------------------- &nbsp;&nbsp;mean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;6.75&nbsp;&nbsp;7.25&nbsp;12.75&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;rms&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;7.53&nbsp;&nbsp;8.14&nbsp;14.67&nbsp;22.62&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;25%&nbsp;q.&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;4.5&nbsp;&nbsp;&nbsp;6.25&nbsp;&nbsp;5.75&nbsp;&nbsp;6.75&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;median&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;75%&nbsp;q.&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;8.25&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;24.25&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;stddev&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;3.86&nbsp;&nbsp;4.27&nbsp;&nbsp;8.38&nbsp;15.81&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;min&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      same as above, but now without aggregations aggr=null;      cpu&nbsp;performance&nbsp;over&nbsp;time&nbsp;[nops/sec] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;year &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;1996&nbsp;1997&nbsp;1998&nbsp;1999 --------------------------------- c&nbsp;powerbar&nbsp;&nbsp;|&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp; p&nbsp;benzol&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp; u&nbsp;mercedes&nbsp;&nbsp;|&nbsp;12&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp; &nbsp;&nbsp;sparcling&nbsp;|&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;       same as above, but now without rows labeled aggr=null; rownames=null; rowaxisname=null;       cpu&nbsp;performance&nbsp;over&nbsp;time&nbsp;[nops/sec] year 1996&nbsp;1997&nbsp;1998&nbsp;1999 ------------------- &nbsp;5&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp; &nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp; &nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;     a column can be broader than specified by the parameter mincolumnwidth (because a cell may not fit into that width) but a column is never smaller than mincolumnwidth. normally one does not need to specify mincolumnwidth (default is 1). this parameter is only interesting when wanting to print two distinct matrices such that both matrices have the same column width, for example, to make it easier to see which column of matrix a corresponds to which column of matrix b. implementation: note that this class is by no means ment to be used for high performance i/o (serialization is much quicker). it is ment to produce well human readable output. analyzes the entire matrix before producing output. each cell is converted to a string as indicated by the given c-like format string. if null is passed as format string, {@link java.lang.double#tostring(double)} is used instead, yielding full precision. next, leading and trailing whitespaces are removed. for each column the maximum number of characters before and after the decimal point is determined. (no problem if decimal points are missing). each cell is then padded with leading and trailing blanks, as necessary to achieve decimal point aligned, left justified formatting. constructs and returns a matrix formatter with format "%g". constructs and returns a matrix formatter. the given format used to convert a single cell value. demonstrates how to use this class. demonstrates how to use this class. demonstrates how to use this class. demonstrates how to use this class. double[][] values = { {3, 1, }, {5.1 ,16.37, } }; demonstrates how to use this class. double[][] values = { {3, 1, }, {5.1 ,16.37, } }; demonstrates how to use this class. double[][] values = { {3, 1, }, {5.1 ,16.37, } }; demonstrates how to use this class. double[][] values = { {3, 0, -3.4, 0}, {5.1 ,0, +3.0123456789, 0}, {16.37, 0.0, 2.5, 0}, {-16.3, 0, -3.012345678e-4, -1}, {1236.3456789, 0, 7, -1.2} }; converts a given cell to a string; no alignment considered. converts a given cell to a string; no alignment considered. returns a string representations of all cells; no alignment considered. returns a string representations of all cells; no alignment considered. returns the index of the decimal point. returns the number of characters before the decimal point. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix with axis as well as rows and columns labeled. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. matrix converted to a string. same as totitlestring except that additionally statistical aggregates (mean, median, sum, etc.) of rows and columns are printed. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. the aggregation functions to be applied to columns and rows. matrix converted to a string. @see hep.aida.bin.binfunction1d @see hep.aida.bin.binfunctions1d returns a string representation of the given matrix with axis as well as rows and columns labeled. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all slices (to be put above each slice). the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the z-axis (to be put above each slice). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. the aggregation functions to be applied to columns, rows. matrix converted to a string. @see hep.aida.bin.binfunction1d @see hep.aida.bin.binfunctions1d returns a string representation of the given matrix with axis as well as rows and columns labeled. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all slices (to be put above each slice). the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the z-axis (to be put above each slice). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. matrix converted to a string. www.braju.com/docs/index.html">henrik www.dinkumware.com/htm_cl/lib_prin.html#print%20functions">dinkumware's alias parameters now the processing may not compile because of packages not included in the distribution htmlstrings[i] = cern.colt.matrixpattern.converting.tohtml(strings[i]); htmlsourcecodes[i] = cern.colt.matrixpattern.converting.tohtml(sourcecodes[i]); may not compile because of packages not included in the distribution system.out.println("\nhtmlstring("+formats[i]+"):\n"+htmlstrings[i]); system.out.println("\nhtmlsourcecode("+formats[i]+"):\n"+htmlsourcecodes[i]); parameters 5, 0.0, -0.0, -double.nan, double.nan, 0.0/0.0, double.negative_infinity, double.positive_infinity, double.min_value, double.max_value double.min_value, double.max_value //, double.negative_infinity, double.positive_infinity string[] formats = {"%g", "%1.10g", "%f", "%1.2f", "%0.2e"}; now the processing string[] javastrings = new string[size]; system.out.println(s); system.out.println(s); parameters string[] columnnames = { "he", "", "he", "four" }; string[] rownames = { "hello", "du", null, "abcdef", "five" }; string[] columnnames = { "0.1", "0.3" }; string[] rownames = { "sunjdk1.2.2 classic", "ibmjdk1.1.8"}; parameters string[] columnnames = { "he", "", "he", "four" }; string[] rownames = { "hello", "du", null, "abcdef", "five" }; string[] columnnames = { "0.1", "0.3" }; string[] rownames = { "sunjdk1.2.2 classic", "ibmjdk1.1.8"}; parameters string[] columnnames = { "he", "", "he", "four" }; string[] rownames = { "hello", "du", null, "abcdef", "five" }; string[] columnnames = { "0.1", "0.3", "0.5", "0.7" }; string[] columnnames = { "0.1", "0.3" }; string[] rownames = { "sunjdk1.2.2 classic", "ibmjdk1.1.8"}; system.out.println(cern.colt.matrix.doublefactory2d.dense.make(values)); system.out.println(new formatter().tosourcecode(cern.colt.matrix.doublefactory2d.dense.make(values))); parameters string[] columnnames = { "w", "x", "y", "z", "mean", "median", "sum"}; string[] rownames = { "sunjdk1.2.2 classic", "ibmjdk1.1.8", "sunjdk1.3 hotspot", "other1", "other2", "mean", "median", "sum" }; hep.aida.bin.binfunction1d[] aggr = {f.mean, f.median, f.sum}; system.out.println(cern.colt.matrix.doublefactory2d.dense.make(values)); system.out.println(new formatter().tosourcecode(cern.colt.matrix.doublefactory2d.dense.make(values))); system.out.println(new formatter().tostring(cern.colt.matrix.doublefactory2d.dense.make(values))); system.out.println(new formatter().totitlestring(cern.colt.matrix.doublefactory2d.dense.make(values),rownames,columnnames,rowaxisname,columnaxisname,title)); system.out.println(cern.colt.matrixpattern.converting.tohtml(new formatter(format).totitlestring(cern.colt.matrix.doublefactory2d.dense.make(values),rownames,columnnames,rowaxisname,columnaxisname,title, aggr))); string oldalignment = this.alignment; this.alignment = decimal; this.alignment = oldalignment; hold row aggregations hold column aggregations aggregate an entire column at a time aggregate an entire row at a time turn into strings tmp holds "matrix" plus "colstats" below (needed so that numbers in a columns can be decimal point aligned) copy strings into a large matrix holding the source matrix and all aggregations append a vertical "|" separator plus names of aggregation functions to line holding columnnames add names of aggregation functions append names of aggregation functions to line holding rownames add names of aggregation functions turn large matrix into string insert a horizontal "----------------------" separation line above the column stats determine insertion position and line width scan "aggr.length+1+v" lines backwards"
cern.colt.matrix.doublealgo.Partitioning "given some interval boundaries, partitions matrices such that cell values falling into an interval are placed next to each other.  performance  partitioning into two intervals is o( n ). partitioning into k intervals is o( n log(k)). constants factors are minimized. @see cern.colt.partitioning "partitioning arrays (provides more documentation)" makes this class non instantiable, but still let's others inherit from it. same as {@link cern.colt.partitioning#partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = 0; rowindexes = {0,1,2,..,matrix.rows()-1}; rowfrom = 0; rowto = matrix.rows()-1; splitters = {5,10,12} c = 0;  d = splitters.length-1; partition(matrix,rowindexes,rowfrom,rowto,column,splitters,c,d,splitindexes); ==> splitindexes == {0, 2, 3} rowindexes == {7, 6, 5, 4, 0, 1, 2, 3}   the matrix is not reordered. here is how it would look like, if it would be reordered accoring to rowindexes. 8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    the matrix to be partitioned. the index of the i-th row; is modified by this method to reflect partitioned indexes. the index of the first row (inclusive). the index of the last row (inclusive). the index of the column to partition on. the values at which the rows shall be split into intervals. must be sorted ascending and must not contain multiple identical values. these preconditions are not checked; be sure that they are met. the index of the first splitter element to be considered. the index of the last splitter element to be considered. the method considers the splitter elements splitters[splitfrom] .. splitters[splitto]. a list into which this method fills the indexes of rows delimiting intervals. upon return splitindexes[splitfrom..splitto] will be set accordingly. therefore, must satisfy splitindexes.length >= splitters.length. same as {@link cern.colt.partitioning#partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = 0; splitters = {5,10,12} partition(matrix,column,splitters,splitindexes); ==> splitindexes == {0, 2, 3}   the matrix is not reordered. the new view is reordered: 8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    the matrix to be partitioned. the index of the column to partition on. the values at which the rows shall be split into intervals. must be sorted ascending and must not contain multiple identical values. these preconditions are not checked; be sure that they are met. a list into which this method fills the indexes of rows delimiting intervals. therefore, must satisfy splitindexes.length >= splitters.length. new matrix view having rows partitioned by the given column and splitters. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  of course, the column must not be a column of a different matrix. more formally, there must hold:  there exists an i such that matrix.viewcolumn(i)==column.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = matrix.viewcolumn(0); a = 0; b = column.size()-1; splitters={5,10,12} c=0;  d=splitters.length-1; partition(matrix,column,a,b,splitters,c,d,splitindexes); ==> splitindexes == {0, 2, 3}  8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    double splitter; // int, double --> template type dependent if (splitfrom>splitto) return; // nothing to do if (from>to) { // all bins are empty from--; for (int i = splitfrom; i small) { int l = from; int n = to; if (len > medium) { // big arrays, pseudomedian of 9 int s = len/8; l = med3(column, l, l+s, l+2s); m = med3(column, m-s, m, m+s); n = med3(column, n-2s, n-s, n); } m = med3(column, l, m, n); // mid-size, pseudomedian of 3 } // find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. medianindex = cern.colt.sorting.binarysearchfromto(splitters,column.getquick(m),splitfrom,splitto); if (medianindex  splitto) medianindex = splitto; // not found, one past the end } splitter = splitters[medianindex]; // partition the list according to the splitter, i.e. // establish invariant: list[i] =splitfrom && (!(splitter = to) { // all elements fall into this bin // all bins with splitters[i] >= splitter are empty int i = medianindex+1; while (i splitters[i]))) splitindexes[i++] = splitindex; splitto = medianindex-1; } // recursively partition left half if (splitfrom synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  of course, the column must not be a column of a different matrix. more formally, there must hold:  there exists an i such that matrix.viewcolumn(i)==column. note that arguments are not checked for validity. double element; // int, double --> template type dependent for (int i=from-1; ++i template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from]"
cern.colt.matrix.doublealgo.Sorting "matrix quicksorts and mergesorts. use idioms like sorting.quicksort.sort(...) and sorting.mergesort.sort(...).  this is another case demonstrating one primary goal of this library: delivering easy to use, yet very efficient apis. the sorts return convenient sort views. this enables the usage of algorithms which scale well with the problem size: for example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix. this is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices. the original matrix is left unaffected.  the quicksort is a derivative of the jdk 1.2 v1.26 algorithms (which are, in turn, based on bentley's and mcilroy's fine work). the mergesort is a derivative of the jal algorithms, with optimisations taken from the jdk algorithms. mergesort is stable (by definition), while quicksort is not. a stable sort is, for example, helpful, if matrices are sorted successively by multiple columns. it preserves the relative position of equal elements. @see cern.colt.genericsorting @see cern.colt.sorting @see java.util.arrays a prefabricated quicksort. a prefabricated mergesort. makes this class non instantiable, but still let's others inherit from it. compare two values, one of which is assumed to be double.nan sorts the vector into ascending order, according to the natural ordering. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort descending, use flip views ...  example:    7, 1, 3, 1    ==&gt; 1, 1, 3, 7 the vector is not sorted. the new view is sorted.    the vector to be sorted. new sorted vector (matrix) view. note that the original matrix is left unaffected. sorts the vector into ascending order, according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort descending, use flip views ...  example:  // sort by sinus of cells doublecomparator comp = new doublecomparator() { &nbsp;&nbsp;&nbsp;public int compare(double a, double b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = math.sin(a); double bs = math.sin(b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the vector to be sorted. the comparator to determine the order. new matrix view sorted as specified. note that the original vector (matrix) is left unaffected. sorts the matrix rows into ascending order, according to the natural ordering of the matrix values in the virtual column aggregates; particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts. essentially, this algorithm makes expensive comparisons cheap. normally each element of aggregates is a summary measure of a row. speedup over comparator based sorting = 2log(rows), on average. for this operation, quicksort is usually faster.  the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example: each aggregate is the sum of a row   4 x 2 matrix:  1, 1 5, 4 3, 0 4, 4    aggregates= 2 9 3 8 ==>  4 x 2 matrix: 1, 1 3, 0 4, 4 5, 4 the matrix is not sorted. the new view is sorted.       // sort 10000 x 1000 matrix by sum of logarithms in a row (i.e. by geometric mean) doublematrix2d matrix = new densedoublematrix2d(10000,1000); matrix.assign(new cern.jet.random.engine.mersennetwister()); // initialized randomly cern.jet.math.functions f = cern.jet.math.functions.functions; // alias for convenience // the quick version (takes some 3 secs) // aggregates[i] = sum(log(row)); double[] aggregates = new double[matrix.rows()]; for (int i = matrix.rows(); --i >= 0; ) aggregates[i] = matrix.viewrow(i).aggregate(f.plus, f.log); doublematrix2d sorted = quicksort(matrix,aggregates); // the slow version (takes some 90 secs) doublematrix1dcomparator comparator = new doublematrix1dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(doublematrix1d x, doublematrix1d y) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a = x.aggregate(f.plus,f.log); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double b = y.aggregate(f.plus,f.log); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a    the matrix to be sorted. the values to sort on. (as a side effect, this array will also get sorted). new matrix view having rows sorted. note that the original matrix is left unaffected. @throws indexoutofboundsexception if aggregates.length != matrix.rows(). sorts the matrix rows into ascending order, according to the natural ordering of the matrix values in the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example:   4 x 2 matrix:  7, 6 5, 4 3, 2 1, 0    column = 0; view = quicksort(matrix,column); system.out.println(view);  ==>    4 x 2 matrix: 1, 0 3, 2 5, 4 7, 6 the matrix is not sorted. the new view is sorted.    the matrix to be sorted. the index of the column inducing the order. new matrix view having rows sorted by the given column. note that the original matrix is left unaffected. @throws indexoutofboundsexception if column = matrix.columns(). sorts the matrix rows according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example:  // sort by sum of values in a row doublematrix1dcomparator comp = new doublematrix1dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(doublematrix1d a, doublematrix1d b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = a.zsum(); double bs = b.zsum(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the matrix to be sorted. the comparator to determine the order. new matrix view having rows sorted as specified. note that the original matrix is left unaffected. sorts the matrix rows into ascending order, according to the natural ordering of the values computed by applying the given aggregation function to each row; particularly efficient when comparing expensive aggregates, because aggregates need not be recomputed time and again, as is the case for comparator based sorts. essentially, this algorithm makes expensive comparisons cheap. normally aggregates defines a summary measure of a row. speedup over comparator based sorting = 2log(rows), on average.  the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example: each aggregate is the sum of a row   4 x 2 matrix:  1, 1 5, 4 3, 0 4, 4    aggregates= hep.aida.bin.binfunctions1d.sum ==>  4 x 2 matrix: 1, 1 3, 0 4, 4 5, 4 the matrix is not sorted. the new view is sorted.       // sort 10000 x 1000 matrix by median or by sum of logarithms in a row (i.e. by geometric mean) doublematrix2d matrix = new densedoublematrix2d(10000,1000); matrix.assign(new cern.jet.random.engine.mersennetwister()); // initialized randomly cern.jet.math.functions f = cern.jet.math.functions.functions; // alias for convenience // the quick version (takes some 10 secs) doublematrix2d sorted = quicksort(matrix,hep.aida.bin.binfunctions1d.median); //doublematrix2d sorted = quicksort(matrix,hep.aida.bin.binfunctions1d.sumoflogarithms); // the slow version (takes some 300 secs) doublematrix1dcomparator comparator = new doublematrix1dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(doublematrix1d x, doublematrix1d y) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a = cern.colt.matrix.doublealgo.statistic.bin(x).median(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double b = cern.colt.matrix.doublealgo.statistic.bin(y).median(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double a = x.aggregate(f.plus,f.log); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double b = y.aggregate(f.plus,f.log); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return a    the matrix to be sorted. the function to sort on; aggregates values in a row. new matrix view having rows sorted. note that the original matrix is left unaffected. sorts the matrix slices into ascending order, according to the natural ordering of the matrix values in the given [row,column] position. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort by other dimensions, use dice views. to sort descending, use flip views ...  the algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other. comparison is based on the cell [row,column] within a slice. let a and b be two 2-d slices. then we have the following rules  a &lt; b iff a.get(row,column) &lt; b.get(row,column) a == b iff a.get(row,column) == b.get(row,column) a &gt; b iff a.get(row,column) &gt; b.get(row,column)  the matrix to be sorted. the index of the row inducing the order. the index of the column inducing the order. new matrix view having slices sorted by the values of the slice view matrix.viewrow(row).viewcolumn(column). note that the original matrix is left unaffected. @throws indexoutofboundsexception if row = matrix.rows() || column = matrix.columns(). sorts the matrix slices according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort by other dimensions, use dice views. to sort descending, use flip views ...  example:  // sort by sum of values in a slice doublematrix2dcomparator comp = new doublematrix2dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(doublematrix2d a, doublematrix2d b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double as = a.zsum(); double bs = b.zsum(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the matrix to be sorted. the comparator to determine the order. new matrix view having slices sorted as specified. note that the original matrix is left unaffected. demonstrates advanced sorting. sorts by sum of row. demonstrates advanced sorting. sorts by sum of slice. demonstrates advanced sorting. sorts by sinus of cell values. sorted.assign( new cern.colt.function.doublefunction() { public double apply(double arg) { return math.sin(arg); } } ); demonstrates applying functions. matrix1.assign(matrix2, new cern.colt.function.doubledoublefunction() { public double apply(double x, double y) { return math.pow(x,y); } } ); demonstrates sorting with precomputation of aggregates (median and sum of logarithms). demonstrates advanced sorting. sorts by sum of row. doublematrix1dcomparator comp = new doublematrix1dcomparator() { public int compare(doublematrix1d a, doublematrix1d b) { double as = a.zsum(); double bs = b.zsum(); return as  5 e.g. 5 < nan row indexes to reorder instead of matrix itself swap nans to the end sort by sinus of cells row indexes to reorder instead of matrix itself sort 10000 x 1000 matrix by sum of logarithms in a row (i.e. by geometric mean) initialized randomly alias for convenience the quick version (takes some 3 secs) aggregates[i] = sum(log(row)); the slow version (takes some 90 secs) set up index reordering compares two aggregates at a time swap nans to the end swaps aggregates and reorders indexes sort indexes and aggregates view the matrix according to the reordered row indexes take all columns in the original order row indexes to reorder instead of matrix itself swap nans to the end view the matrix according to the reordered row indexes take all columns in the original order sort by sum of values in a row row indexes to reorder instead of matrix itself precompute views for speed return c.compare(matrix.viewrow(a), matrix.viewrow(b)); view the matrix according to the reordered row indexes take all columns in the original order sort 10000 x 1000 matrix by median or by sum of logarithms in a row (i.e. by geometric mean) initialized randomly alias for convenience the quick version (takes some 10 secs) doublematrix2d sorted = quicksort(matrix,hep.aida.bin.binfunctions1d.sumoflogarithms); the slow version (takes some 300 secs) double a = x.aggregate(f.plus,f.log); double b = y.aggregate(f.plus,f.log); precompute aggregates over rows, as defined by "aggregate" a bit clumsy, because statistic.aggregate(...) is defined on columns, so we need to transpose views indexes to reorder instead of matrix itself swap nans to the end view the matrix according to the reordered slice indexes take all rows and columns in the original order sort by sum of values in a slice indexes to reorder instead of matrix itself precompute views for speed return c.compare(matrix.viewslice(a), matrix.viewslice(b)); view the matrix according to the reordered slice indexes take all rows and columns in the original order check whether it is really sorted for reliable benchmarks, call this method twice: once with small dummy parameters to "warm up" the jitter, then with your real work-load initialize randomly also benchmark copying in its several implementation flavours system.out.println(a); the quick version (takes some 10 secs) a = sort.sort(a,hep.aida.bin.binfunctions1d.sumlog); check results for correctness warning: be sure not to print huge matrices unless you have tons of main memory and time!! so we just show the first 5 rows double a = x.aggregate(f.plus,f.log); double b = y.aggregate(f.plus,f.log); for reliable benchmarks, call this method twice: once with small dummy parameters to "warm up" the jitter, then with your real work-load initialize randomly"
cern.colt.matrix.doublealgo.Statistic "basic statistics operations on matrices. computation of covariance, correlation, distance matrix. random sampling views. conversion to histograms with and without olap cube operators. conversion to bins with retrieval of statistical bin measures. also see {@link cern.jet.stat} and {@link hep.aida.bin}, in particular {@link hep.aida.bin.dynamicbin1d}.  examples:   a covariance(a) correlation(covariance(a)) distance(a,euclid)    4&nbsp;x&nbsp;3&nbsp;matrix 1&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3 2&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6 3&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;9 4&nbsp;-8&nbsp;-10    3&nbsp;x&nbsp;3&nbsp;matrix &nbsp;1.25&nbsp;-3.5&nbsp;-4.5 -3.5&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp; -4.5&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;52.5   3&nbsp;x&nbsp;3&nbsp;matrix &nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.581318&nbsp;-0.555492 -0.581318&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.999507 -0.555492&nbsp;&nbsp;0.999507&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   3&nbsp;x&nbsp;3&nbsp;matrix &nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.569805&nbsp;15.874508 12.569805&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.242641 15.874508&nbsp;&nbsp;4.242641&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    euclidean distance function; sqrt(sum( (x[i]-y[i])^2 )). bray-curtis distance function; sum( abs(x[i]-y[i]) ) / sum( x[i]+y[i] ). canberra distance function; sum( abs(x[i]-y[i]) / abs(x[i]+y[i]) ). maximum distance function; max( abs(x[i]-y[i]) ). manhattan distance function; sum( abs(x[i]-y[i]) ). interface that represents a function object: a function that takes two argument vectors and returns a single value. applies a function to two argument vectors. the first argument vector passed to the function. the second argument vector passed to the function. result of the function. makes this class non instantiable, but still let's others inherit from it. applies the given aggregation functions to each column and stores the results in a the result matrix. if matrix has shape m x n, then result must have shape aggr.length x n. tip: to do aggregations on rows use dice views (transpositions), as in aggregate(matrix.viewdice(),aggr,result.viewdice()). any matrix; a column holds the values of a given variable. the aggregation functions to be applied to each column. the matrix to hold the aggregation results. result (for convenience only). @see formatter @see hep.aida.bin.binfunction1d @see hep.aida.bin.binfunctions1d fills all cell values of the given vector into a bin from which statistics measures can be retrieved efficiently. cells values are copied.  tip: use system.out.println(bin(vector)) to print most measures computed by the bin. example:    size: 20000 sum: 299858.02350278624 sumofsquares: 5399184.154095971 min: 0.8639113139711261 max: 59.75331890541892 mean: 14.992901175139313 rms: 16.43043540825375 variance: 45.17438077634358 standard deviation: 6.721188940681818 standard error: 0.04752598277592142 geometric mean: 13.516615397064466 product: infinity harmonic mean: 11.995174297952191 sum of inversions: 1667.337172700724 skew: 0.8922838940067878 kurtosis: 1.1915828121825598 sum of powers(3): 1.1345828465808412e8 sum of powers(4): 2.7251055344494686e9 sum of powers(5): 7.367125643433887e10 sum of powers(6): 2.215370909100143e12 moment(0,0): 1.0 moment(1,0): 14.992901175139313 moment(2,0): 269.95920770479853 moment(3,0): 5672.914232904206 moment(4,0): 136255.27672247344 moment(5,0): 3683562.8217169433 moment(6,0): 1.1076854545500715e8 moment(0,mean()): 1.0 moment(1,mean()): -2.0806734113421045e-14 moment(2,mean()): 45.172122057305664 moment(3,mean()): 270.92018671421 moment(4,mean()): 8553.8664869067 moment(5,mean()): 153357.41712233616 moment(6,mean()): 4273757.570142922 25%, 50% and 75% quantiles: 10.030074811938091, 13.977982089912224, 18.86124362967137 quantileinverse(mean): 0.559163335012079 distinct elements & frequencies not printed (too many).    the vector to analyze. bin holding the statistics measures of the vector. modifies the given covariance matrix to be a correlation matrix (in-place). the correlation matrix is a square, symmetric matrix consisting of nothing but correlation coefficients. the rows and the columns represent the variables, the cells represent correlation coefficients. the diagonal cells (i.e. the correlation between a variable and itself) will equal 1, for the simple reason that the correlation coefficient of a variable with itself equals 1. the correlation of two column vectors x and y is given by corr(x,y) = cov(x,y) / (stddev(x)stddev(y)) (pearson's correlation coefficient). a correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). see the  math definition and cov(x,y) = (1/n) sum((x[i]-mean(x)) (y[i]-mean(y))). see the  math definition. compares two column vectors at a time. use dice views to compare two row vectors at a time. any matrix; a column holds the values of a given variable. covariance matrix (n x n, n=matrix.columns). 2-d olap cube operator; fills all cells of the given vectors into the given histogram. if you use hep.aida.ref.converter.tostring(histo) on the result, the olap cube of x-"column" vs. y-"column" , summing the weights "column" will be printed. for example, aggregate sales by product by region.  computes the distinct values of x and y, yielding histogram axes that capture one distinct value per bin. then fills the histogram.  example output:    cube: &nbsp;&nbsp;&nbsp;entries=5000, extraentries=0 &nbsp;&nbsp;&nbsp;meanx=4.9838, rmsx=nan &nbsp;&nbsp;&nbsp;meany=2.5304, rmsy=nan &nbsp;&nbsp;&nbsp;xaxis: min=0, max=10, bins=11 &nbsp;&nbsp;&nbsp;yaxis: min=0, max=5, bins=6 heights: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| x &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 1 2 3 4 5 6 7 8 9 10 | sum ---------------------------------------------------------- y 5 | 30 53 51 52 57 39 65 61 55 49 22 | 534 &nbsp;&nbsp;4 | 43 106 112 96 92 94 107 98 98 110 47 | 1003 &nbsp;&nbsp;3 | 39 134 87 93 102 103 110 90 114 98 51 | 1021 &nbsp;&nbsp;2 | 44 81 113 96 101 86 109 83 111 93 42 | 959 &nbsp;&nbsp;1 | 54 94 103 99 115 92 98 97 103 90 44 | 989 &nbsp;&nbsp;0 | 24 54 52 44 42 56 46 47 56 53 20 | 494 ---------------------------------------------------------- &nbsp;&nbsp;sum | 234 522 518 480 509 470 535 476 537 493 226 |    histogram containing the cube. @throws illegalargumentexception if x.size() != y.size() || y.size() != weights.size(). 3-d olap cube operator; fills all cells of the given vectors into the given histogram. if you use hep.aida.ref.converter.tostring(histo) on the result, the olap cube of x-"column" vs. y-"column" vs. z-"column", summing the weights "column" will be printed. for example, aggregate sales by product by region by time.  computes the distinct values of x and y and z, yielding histogram axes that capture one distinct value per bin. then fills the histogram. histogram containing the cube. @throws illegalargumentexception if x.size() != y.size() || x.size() != z.size() || x.size() != weights.size(). demonstrates usage of this class. demonstrates usage of this class. demonstrates usage of this class. constructs and returns the distance matrix of the given matrix. the distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. the rows and the columns represent the variables, the cells represent distance coefficients. the diagonal cells (i.e. the distance between a variable and itself) will be zero. compares two column vectors at a time. use dice views to compare two row vectors at a time. any matrix; a column holds the values of a given variable (vector). (euclid, canberra, ..., or any fills all cells of the given vector into the given histogram. histo (for convenience only). fills all cells of the given vectors into the given histogram. histo (for convenience only). @throws illegalargumentexception if x.size() != y.size(). fills all cells of the given vectors into the given histogram. histo (for convenience only). @throws illegalargumentexception if x.size() != y.size() || y.size() != weights.size(). fills all cells of the given vectors into the given histogram. histo (for convenience only). @throws illegalargumentexception if x.size() != y.size() || x.size() != z.size() || x.size() != weights.size(). benchmarks covariance computation. constructs and returns a sampling view with a size of round(matrix.size() fraction). samples "without replacement" from the uniform distribution. any matrix. the percentage of rows to be included in the view. the percentage of columns to be included in the view. a uniform random number generator; set this parameter to null to use a default generator seeded with the current time. sampling view. @throws illegalargumentexception if ! (0 . @see cern.jet.random.sampling.randomsampler constructs and returns a sampling view with round(matrix.rows() rowfraction) rows and round(matrix.columns() columnfraction) columns. samples "without replacement". rows and columns are randomly chosen from the uniform distribution. examples:    matrix   rowfraction=0.2 columnfraction=0.2   rowfraction=0.2 columnfraction=1.0    rowfraction=1.0 columnfraction=0.2      10&nbsp;x&nbsp;10&nbsp;matrix &nbsp;1&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;4&nbsp;&nbsp;5&nbsp;&nbsp;6&nbsp;&nbsp;7&nbsp;&nbsp;8&nbsp;&nbsp;9&nbsp;&nbsp;10 11&nbsp;12&nbsp;13&nbsp;14&nbsp;15&nbsp;16&nbsp;17&nbsp;18&nbsp;19&nbsp;&nbsp;20 21&nbsp;22&nbsp;23&nbsp;24&nbsp;25&nbsp;26&nbsp;27&nbsp;28&nbsp;29&nbsp;&nbsp;30 31&nbsp;32&nbsp;33&nbsp;34&nbsp;35&nbsp;36&nbsp;37&nbsp;38&nbsp;39&nbsp;&nbsp;40 41&nbsp;42&nbsp;43&nbsp;44&nbsp;45&nbsp;46&nbsp;47&nbsp;48&nbsp;49&nbsp;&nbsp;50 51&nbsp;52&nbsp;53&nbsp;54&nbsp;55&nbsp;56&nbsp;57&nbsp;58&nbsp;59&nbsp;&nbsp;60 61&nbsp;62&nbsp;63&nbsp;64&nbsp;65&nbsp;66&nbsp;67&nbsp;68&nbsp;69&nbsp;&nbsp;70 71&nbsp;72&nbsp;73&nbsp;74&nbsp;75&nbsp;76&nbsp;77&nbsp;78&nbsp;79&nbsp;&nbsp;80 81&nbsp;82&nbsp;83&nbsp;84&nbsp;85&nbsp;86&nbsp;87&nbsp;88&nbsp;89&nbsp;&nbsp;90 91&nbsp;92&nbsp;93&nbsp;94&nbsp;95&nbsp;96&nbsp;97&nbsp;98&nbsp;99&nbsp;100    2&nbsp;x&nbsp;2&nbsp;matrix 43&nbsp;50 53&nbsp;60   2&nbsp;x&nbsp;10&nbsp;matrix 41&nbsp;42&nbsp;43&nbsp;44&nbsp;45&nbsp;46&nbsp;47&nbsp;48&nbsp;49&nbsp;&nbsp;50 91&nbsp;92&nbsp;93&nbsp;94&nbsp;95&nbsp;96&nbsp;97&nbsp;98&nbsp;99&nbsp;100    10&nbsp;x&nbsp;2&nbsp;matrix &nbsp;4&nbsp;&nbsp;8 14&nbsp;18 24&nbsp;28 34&nbsp;38 44&nbsp;48 54&nbsp;58 64&nbsp;68 74&nbsp;78 84&nbsp;88 94&nbsp;98     any matrix. the percentage of rows to be included in the view. the percentage of columns to be included in the view. a uniform random number generator; set this parameter to null to use a default generator seeded with the current time. sampling view. @throws illegalargumentexception if ! (0 . @see cern.jet.random.sampling.randomsampler constructs and returns a sampling view with round(matrix.slices() slicefraction) slices and round(matrix.rows() rowfraction) rows and round(matrix.columns() columnfraction) columns. samples "without replacement". slices, rows and columns are randomly chosen from the uniform distribution. any matrix. the percentage of slices to be included in the view. the percentage of rows to be included in the view. the percentage of columns to be included in the view. a uniform random number generator; set this parameter to null to use a default generator seeded with the current time. sampling view. @throws illegalargumentexception if ! (0 . @see cern.jet.random.sampling.randomsampler constructs and returns the distance matrix of the given matrix. the distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. the rows and the columns represent the variables, the cells represent distance coefficients. the diagonal cells (i.e. the distance between a variable and itself) will be zero. compares two column vectors at a time. use dice views to compare two row vectors at a time. any matrix; a column holds the values of a given variable (vector). the kind of norm to be used (euclid, canberra, ...). distance matrix (n x n, n=matrix.columns). int rows = matrix.rows(); int columns = matrix.columns(); doublematrix2d distance = new cern.colt.matrix.impl.densedoublematrix2d(columns,columns); // cache views doublematrix1d[] cols = new doublematrix1d[columns]; for (int i=columns; --i >= 0; ) { cols[i] = matrix.viewcolumn(i); } // setup distance function cern.jet.math.functions f = cern.jet.math.functions.functions; doubledoublefunction function = null; //doubledoublefunction function2 = null; if (norm==euclid) function = f.chain(f.square,f.minus); else if (norm==bray_curtis) function = f.chain(f.abs,f.minus); else if (norm==canberra) function = new doubledoublefunction() { public final double apply(double a, double b) { return math.abs(a-b) / math.abs(a+b);} }; else if (norm==maximum) function = f.chain(f.abs,f.minus); else if (norm==manhattan) function = f.chain(f.abs,f.minus); else throw new illegalargumentexception("unknown norm"); // work out all permutations for (int i=columns; --i >= 0; ) { for (int j=i; --j >= 0; ) { double d = 0; if (norm==euclid) d = math.sqrt(cols[i].aggregate(cols[j], f.plus, function)); else if (norm==bray_curtis) d = cols[i].aggregate(cols[j], f.plus, function) / cols[i].aggregate(cols[j], f.plus, f.plus); else if (norm==canberra) d = cols[i].aggregate(cols[j], f.plus, function); else if (norm==maximum) d = cols[i].aggregate(cols[j], f.max, function); else if (norm==manhattan) d = cols[i].aggregate(cols[j], f.plus, function); distance.setquick(i,j,d); distance.setquick(j,i,d); // symmetric } } return distance; constructs and returns the distance matrix of the given matrix. the distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. the rows and the columns represent the variables, the cells represent distance coefficients. the diagonal cells (i.e. the distance between a variable and itself) will be zero. compares two column vectors at a time. use dice views to compare two row vectors at a time. any matrix; a column holds the values of a given variable (vector). the kind of norm to be used (euclid, canberra, ...). distance matrix (n x n, n=matrix.columns). // setup distance function final cern.jet.math.functions f = cern.jet.math.functions.functions; vectorvectorfunction function; if (norm==euclid) function = new vectorvectorfunction() { public final double apply(doublematrix1d a, doublematrix1d b) { return math.sqrt(a.aggregate(b, f.plus, f.chain(f.square,f.minus))); } }; else if (norm==bray_curtis) function = new vectorvectorfunction() { public final double apply(doublematrix1d a, doublematrix1d b) { return a.aggregate(b, f.plus, f.chain(f.abs,f.minus)) / a.aggregate(b, f.plus, f.plus); } }; else if (norm==canberra) function = new vectorvectorfunction() { doubledoublefunction fun = new doubledoublefunction() { public final double apply(double a, double b) { return math.abs(a-b) / math.abs(a+b); } }; public final double apply(doublematrix1d a, doublematrix1d b) { return a.aggregate(b, f.plus, fun); } }; else if (norm==maximum) function = new vectorvectorfunction() { public final double apply(doublematrix1d a, doublematrix1d b) { return a.aggregate(b, f.max, f.chain(f.abs,f.minus)); } }; else if (norm==manhattan) function = new vectorvectorfunction() { public final double apply(doublematrix1d a, doublematrix1d b) { return a.aggregate(b, f.plus, f.chain(f.abs,f.minus)); } }; else throw new illegalargumentexception("unknown norm"); return distance(matrix,function); copy column into values www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition www.stat.berkeley.edu/ symmetric www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition. symmetric compute distinct values of x copy x into vals since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin compute distinct values of y since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin compute distinct values of x copy x into vals since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin compute distinct values of y since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin compute distinct values of z since bins are right-open [from,to) we need an additional dummy bin so that the last distinct value does not fall into the overflow bin system.out.println(correlation(covariance(a))); system.out.println(distance(a,euclid)); system.out.println(cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println(cern.colt.matrixpattern.converting.tohtml(covariance(a).tostring())); system.out.println(cern.colt.matrixpattern.converting.tohtml(correlation(covariance(a)).tostring())); system.out.println(cern.colt.matrixpattern.converting.tohtml(distance(a,euclid).tostring())); double value = 1; doublematrix2d a = factory.make(rows,columns); a.assign(value); cache views work out all permutations symmetric check preconditions and allow for a little tolerance random generator seeded with current time sampler works on long's, not int's sample check preconditions and allow for a little tolerance random generator seeded with current time sampler works on long's, not int's sample rows sample columns check preconditions and allow for a little tolerance random generator seeded with current time sampler works on long's, not int's sample slices sample rows sample columns cache views setup distance function doubledoublefunction function2 = null; work out all permutations symmetric setup distance function"
cern.colt.matrix.doublealgo.Stencil "stencil operations. for efficient finite difference operations. applies a function to a moving 3 x 3 or 3 x 3 x 3 window. build on top of matrix.zassignxxxneighbors(...). you can specify how many iterations shall at most be done, a convergence condition when iteration shall be terminated, and how many iterations shall pass between convergence checks. always does two iterations at a time for efficiency. these class is for convencience and efficiency. makes this class non instantiable, but still let's others inherit from it. 27 point stencil operation. applies a function to a moving 3 x 3 x 3 window. the matrix to operate on. the function to be applied to each window. the maximum number of times the stencil shall be applied to the matrix. should be a multiple of 2 because two iterations are always done in one atomic step. convergence condition; will return before maxiterations are done when hasconverged.apply(a)==true. set this parameter to null to indicate that no convergence checks shall be made. the number of iterations to pass between each convergence check. (since a convergence may be expensive, you may want to do it only every 2,4 or 8 iterations.) number of iterations actually executed. 9 point stencil operation. applies a function to a moving 3 x 3 window. the matrix to operate on. the function to be applied to each window. the maximum number of times the stencil shall be applied to the matrix. should be a multiple of 2 because two iterations are always done in one atomic step. convergence condition; will return before maxiterations are done when hasconverged.apply(a)==true. set this parameter to null to indicate that no convergence checks shall be made. the number of iterations to pass between each convergence check. (since a convergence may be expensive, you may want to do it only every 2,4 or 8 iterations.) number of iterations actually executed. odd -> make it even do two steps at a time for efficiency odd -> make it even do two steps at a time for efficiency"
cern.colt.matrix.doublealgo.Transform "deprecated; basic element-by-element transformations on {@link cern.colt.matrix.doublematrix1d} and {@link cern.colt.matrix.doublematrix2d}. all transformations modify the first argument matrix to hold the result of the transformation. use idioms like result = mult(matrix.copy(),5) to leave source matrices unaffected.  if your favourite transformation is not provided by this class, consider using method assign in combination with prefabricated function objects of {@link cern.jet.math.functions}, using idioms like    cern.jet.math.functions f = cern.jet.math.functions.functions; // alias matrix.assign(f.square); matrix.assign(f.sqrt); matrix.assign(f.sin); matrix.assign(f.log); matrix.assign(f.log(b)); matrix.assign(othermatrix, f.min); matrix.assign(othermatrix, f.max);    here are some other examples.  implementation: performance optimized for medium to very large matrices. in fact, there is now nomore a performance advantage in using this class; the assign (transform) methods directly defined on matrices are now just as fast. thus, this class will soon be removed altogether. @deprecated little trick to allow for "aliasing", that is, renaming this class. normally you would write  transform.mult(mymatrix,2); transform.plus(mymatrix,5);  since this class has only static methods, but no instance methods you can also shorten the name "doubletransform" to a name that better suits you, for example "trans".  transform t = transform.transform; // kind of "alias" t.mult(mymatrix,2); t.plus(mymatrix,5);  makes this class non instantiable, but still let's others inherit from it. a[i] = math.abs(a[i]). the matrix to modify. a (for convenience only). a[row,col] = math.abs(a[row,col]). the matrix to modify. a (for convenience only). a = a / s  a[i] = a[i] / s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a / b  a[i] = a[i] / b[i]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a / s  a[row,col] = a[row,col] / s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a / b  a[row,col] = a[row,col] / b[row,col]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a[row,col] = a[row,col] == s ? 1 : 0; ignores tolerance. the matrix to modify. the scalar; can have any value. a (for convenience only). a[row,col] = a[row,col] == b[row,col] ? 1 : 0; ignores tolerance. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a[row,col] = a[row,col] > s ? 1 : 0. the matrix to modify. the scalar; can have any value. a (for convenience only). a[row,col] = a[row,col] > b[row,col] ? 1 : 0. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a[row,col] = a[row,col] . the matrix to modify. the scalar; can have any value. a (for convenience only). a[row,col] = a[row,col] . the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a - s  a[i] = a[i] - s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a - b  a[i] = a[i] - b[i]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a - s  a[row,col] = a[row,col] - s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a - b  a[row,col] = a[row,col] - b[row,col]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a - bs  a[i] = a[i] - b[i]s. the matrix to modify. the matrix to stay unaffected. the scalar; can have any value. a (for convenience only). a = a - bs  a[row,col] = a[row,col] - b[row,col]s. the matrix to modify. the matrix to stay unaffected. the scalar; can have any value. a (for convenience only). a = a s  a[i] = a[i] s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a b  a[i] = a[i] b[i]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a s  a[row,col] = a[row,col] s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a b  a[row,col] = a[row,col] b[row,col]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = -a  a[i] = -a[i] for all cells. a (for convenience only). a = -a  a[row,col] = -a[row,col]. a (for convenience only). a = a + s  a[i] = a[i] + s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a + b  a[i] = a[i] + b[i]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a + s  a[row,col] = a[row,col] + s. the matrix to modify. the scalar; can have any value. a (for convenience only). a = a + b  a[row,col] = a[row,col] + b[row,col]. the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = a + bs a[i] = a[i] + b[i]s. the matrix to modify. the matrix to stay unaffected. the scalar; can have any value. a (for convenience only). a = a + bs  a[row,col] = a[row,col] + b[row,col]s. the matrix to modify. the matrix to stay unaffected. the scalar; can have any value. a (for convenience only). a = as  a[i] = math.pow(a[i], s). the matrix to modify. the scalar; can have any value. a (for convenience only). a = ab  a[i] = math.pow(a[i], b[i]). the matrix to modify. the matrix to stay unaffected. a (for convenience only). a = as  a[row,col] = math.pow(a[row,col], s). the matrix to modify. the scalar; can have any value. a (for convenience only). a = ab  a[row,col] = math.pow(a[row,col], b[row,col]). the matrix to modify. the matrix to stay unaffected. a (for convenience only). alias kind of "alias" alias"
cern.colt.matrix.DoubleFactory1D "factory for convenient construction of 1-d matrices holding double cells. use idioms like doublefactory1d.dense.make(1000) to construct dense matrices, doublefactory1d.sparse.make(1000) to construct sparse matrices. if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:    doublefactory1d f = doublefactory1d.dense; f.make(1000); f.descending(10); f.random(3); ...    a factory producing dense matrices. a factory producing sparse matrices. makes this class non instantiable, but still let's others inherit from it. c = a||b; constructs a new matrix which is the concatenation of two other matrices. example: 0 1 append 3 4 --> 0 1 3 4. constructs a matrix with cells having ascending values. for debugging purposes. example: 0 1 2 constructs a matrix with cells having descending values. for debugging purposes. example: 2 1 0 constructs a matrix with the given cell values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix which is the concatenation of all given parts. cells are copied. constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value. constructs a matrix from the values of the given list. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. new matrix. constructs a matrix with uniformly distributed values in (0,1) (exclusive). c = a||a||..||a; constructs a new matrix which is concatenated repeat times. example:  0 1 repeat(3) --> 0 1 0 1 0 1  constructs a randomly sampled matrix with the given shape. randomly picks exactly math.round(sizenonzerofraction) cells and initializes them to value, all the rest will be initialized to zero. note that this is not the same as setting each cell with probability nonzerofraction to value. @throws illegalargumentexception if nonzerofraction  1. @see cern.jet.random.sampling.randomsampler constructs a list from the given matrix. the values are copied. so subsequent changes in values are not reflected in the list, and vice-versa. the values to be filled into the new list. new list. concatenate"
cern.colt.matrix.DoubleFactory2D "factory for convenient construction of 2-d matrices holding double cells. also provides convenient methods to compose (concatenate) and decompose (split) matrices from/to constituent blocks.  &nbsp;    construction use idioms like doublefactory2d.dense.make(4,4) to construct dense matrices, doublefactory2d.sparse.make(4,4) to construct sparse matrices.    construction with initial values  use other make methods to construct matrices with given initial values.     appending rows and columns  use methods {@link #appendcolumns(doublematrix2d,doublematrix2d) appendcolumns}, {@link #appendcolumns(doublematrix2d,doublematrix2d) appendrows} and {@link #repeat(doublematrix2d,int,int) repeat} to append rows and columns.     general block matrices  use methods {@link #compose(doublematrix2d[][]) compose} and {@link #decompose(doublematrix2d[][],doublematrix2d) decompose} to work with general block matrices.     diagonal matrices  use methods {@link #diagonal(doublematrix1d) diagonal(vector)}, {@link #diagonal(doublematrix2d) diagonal(matrix)} and {@link #identity(int) identity} to work with diagonal matrices.     diagonal block matrices  use method {@link #composediagonal(doublematrix2d,doublematrix2d,doublematrix2d) composediagonal} to work with diagonal block matrices.    random use methods {@link #random(int,int) random} and {@link #sample(int,int,double,double) sample} to construct random matrices.    &nbsp; if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:     doublefactory2d f = doublefactory2d.dense; f.make(4,4); f.descending(10,20); f.random(4,4); ...    a factory producing dense matrices. a factory producing sparse hash matrices. a factory producing sparse row compressed matrices. a factory producing sparse row compressed modified matrices. makes this class non instantiable, but still let's others inherit from it. c = a||b; constructs a new matrix which is the column-wise concatenation of two other matrices.  0 1 2 3 4 5 appendcolumns 6 7 8 9 --> 0 1 2 6 7 3 4 5 8 9  c = a||b; constructs a new matrix which is the row-wise concatenation of two other matrices.  0 1 2 3 4 5 appendrows 6 7 8 9 --> 0 1 2 3 4 5 6 7 8 9  constructs a matrix with cells having ascending values. for debugging purposes. example:  0 1 2 3 4 5  checks whether the given array is rectangular, that is, whether all rows have the same number of columns. @throws illegalargumentexception if the array is not rectangular. checks whether the given array is rectangular, that is, whether all rows have the same number of columns. @throws illegalargumentexception if the array is not rectangular. constructs a block matrix made from the given parts. the inverse to method {@link #decompose(doublematrix2d[][], doublematrix2d)}.  all matrices of a given column within parts must have the same number of columns. all matrices of a given row within parts must have the same number of rows. otherwise an illegalargumentexception is thrown. note that nulls within parts[row,col] are an exception to this rule: they are ignored. cells are copied. example:   code result     doublematrix2d[][] parts1 = { &nbsp;&nbsp;&nbsp;{ null, make(2,2,1), null }, &nbsp;&nbsp;&nbsp;{ make(4,4,2), null, make(4,3,3) }, &nbsp;&nbsp;&nbsp;{ null, make(2,2,4), null } }; system.out.println(compose(parts1));   8&nbsp;x&nbsp;9&nbsp;matrix 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;0&nbsp;0&nbsp;0 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 0&nbsp;0&nbsp;0&nbsp;0&nbsp;4&nbsp;4&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;4&nbsp;4&nbsp;0&nbsp;0&nbsp;0     doublematrix2d[][] parts3 = { &nbsp;&nbsp;&nbsp;{ identity(3), null, }, &nbsp;&nbsp;&nbsp;{ null, identity(3).viewcolumnflip() }, &nbsp;&nbsp;&nbsp;{ identity(3).viewrowflip(), null } }; system.out.println("\n"+make(parts3));   9&nbsp;x&nbsp;6&nbsp;matrix 1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;1 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;0 0&nbsp;0&nbsp;0&nbsp;1&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0&nbsp;0&nbsp;0 1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0      doublematrix2d a = ascending(2,2); doublematrix2d b = descending(2,2); doublematrix2d _ = null; doublematrix2d[][] parts4 = { &nbsp;&nbsp;&nbsp;{ a, _, a, _ }, &nbsp;&nbsp;&nbsp;{ _, a, _, b } }; system.out.println("\n"+make(parts4));   4&nbsp;x&nbsp;8&nbsp;matrix 1&nbsp;2&nbsp;0&nbsp;0&nbsp;1&nbsp;2&nbsp;0&nbsp;0 3&nbsp;4&nbsp;0&nbsp;0&nbsp;3&nbsp;4&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;2 0&nbsp;0&nbsp;3&nbsp;4&nbsp;0&nbsp;0&nbsp;1&nbsp;0      doublematrix2d[][] parts2 = { &nbsp;&nbsp;&nbsp;{ null, make(2,2,1), null }, &nbsp;&nbsp;&nbsp;{ make(4,4,2), null, make(4,3,3) }, &nbsp;&nbsp;&nbsp;{ null, make(2,3,4), null } }; system.out.println("\n"+factory2d.make(parts2));   illegalargumentexception a[0,1].cols != a[2,1].cols (2 != 3)   @throws illegalargumentexception subject to the conditions outlined above. constructs a diagonal block matrix from the given parts (the direct sum of two matrices). that is the concatenation  a 0 0 b  (the direct sum has a.rows()+b.rows() rows and a.columns()+b.columns() columns). cells are copied. new matrix which is the direct sum. constructs a diagonal block matrix from the given parts. the concatenation has the form  a 0 0 0 b 0 0 0 c  from the given parts. cells are copied. splits a block matrix into its constituent blocks; copies blocks of a matrix into the given parts. the inverse to method {@link #compose(doublematrix2d[][])}.  all matrices of a given column within parts must have the same number of columns. all matrices of a given row within parts must have the same number of rows. otherwise an illegalargumentexception is thrown. note that nulls within parts[row,col] are an exception to this rule: they are ignored. cells are copied. example:   code matrix --&gt; parts      doublematrix2d matrix = ... ; doublematrix2d _ = null; doublematrix2d a,b,c,d; a = make(2,2); b = make (4,4); c = make(4,3); d = make (2,2); doublematrix2d[][] parts = { &nbsp;&nbsp;&nbsp;{ _, a, _ }, &nbsp;&nbsp;&nbsp;{ b, _, c }, &nbsp;&nbsp;&nbsp;{ _, d, _ } }; decompose(parts,matrix); system.out.println(&quot;\na = &quot;+a); system.out.println(&quot;\nb = &quot;+b); system.out.println(&quot;\nc = &quot;+c); system.out.println(&quot;\nd = &quot;+d);   8&nbsp;x&nbsp;9&nbsp;matrix 9&nbsp;9&nbsp;9&nbsp;9&nbsp;1&nbsp;1&nbsp;9&nbsp;9&nbsp;9 9&nbsp;9&nbsp;9&nbsp;9&nbsp;1&nbsp;1&nbsp;9&nbsp;9&nbsp;9 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 9&nbsp;9&nbsp;9&nbsp;9&nbsp;4&nbsp;4&nbsp;9&nbsp;9&nbsp;9 9&nbsp;9&nbsp;9&nbsp;9&nbsp;4&nbsp;4&nbsp;9&nbsp;9&nbsp;9  a = 2&nbsp;x&nbsp;2&nbsp;matrix 1&nbsp;1 1&nbsp;1 b = 4&nbsp;x&nbsp;4&nbsp;matrix 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 c = 4&nbsp;x&nbsp;3&nbsp;matrix 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 d = 2&nbsp;x&nbsp;2&nbsp;matrix 4&nbsp;4 4&nbsp;4    @throws illegalargumentexception subject to the conditions outlined above. demonstrates usage of this class. // illegal 2 != 3 doublematrix2d[][] parts2 = { { null, make(2,2,1), null }, { make(4,4,2), null, make(4,3,3) }, { null, make(2,3,4), null } }; system.out.println("\n"+make(parts2)); demonstrates usage of this class. // illegal 2 != 3 doublematrix2d[][] parts2 = { { null, make(2,2,1), null }, { make(4,4,2), null, make(4,3,3) }, { null, make(2,3,4), null } }; system.out.println("\n"+factory2d.make(parts2)); doublematrix2d[][] parts3 = { { identity(3), null, }, { null, identity(3).viewcolumnflip() }, { identity(3).viewrowflip(), null } }; system.out.println("\n"+make(parts3)); //system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts3).tostring())); doublematrix2d a = ascending(2,2); doublematrix2d b = descending(2,2); doublematrix2d _ = null; doublematrix2d[][] parts4 = { { a, _, a, _ }, { _, a, _, b } }; system.out.println("\n"+make(parts4)); //system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts4).tostring())); constructs a matrix with cells having descending values. for debugging purposes. example:  5 4 3 2 1 0  constructs a new diagonal matrix whose diagonal elements are the elements of vector. cells values are copied. the new matrix is not a view. example:  5 4 3 --> 5 0 0 0 4 0 0 0 3  new matrix. constructs a new vector consisting of the diagonal elements of a. cells values are copied. the new vector is not a view. example:  5 0 0 9 0 4 0 9 0 0 3 9 --> 5 4 3  the matrix, need not be square. new vector. constructs an identity matrix (having ones on the diagonal and zeros elsewhere). constructs a matrix with the given cell values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. construct a matrix from a one-dimensional column-major packed array, ala fortran. has the form matrix.get(row,column) == values[row + columnrows]. the values are copied. one-dimensional array of doubles, packed by columns (ala fortran). the number of rows. @exception illegalargumentexception values.length must be a multiple of rows. constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value. constructs a 1d matrix of the right dynamic type. constructs a matrix with uniformly distributed values in (0,1) (exclusive). c = a||a||..||a; constructs a new matrix which is duplicated both along the row and column dimension. example:  0 1 2 3 repeat(2,3) --> 0 1 0 1 0 1 2 3 2 3 2 3 0 1 0 1 0 1 2 3 2 3 2 3  constructs a randomly sampled matrix with the given shape. randomly picks exactly math.round(rowscolumnsnonzerofraction) cells and initializes them to value, all the rest will be initialized to zero. note that this is not the same as setting each cell with probability nonzerofraction to value. note: the random seed is a constant. @throws illegalargumentexception if nonzerofraction  1. @see cern.jet.random.sampling.randomsampler modifies the given matrix to be a randomly sampled matrix. randomly picks exactly math.round(rowscolumnsnonzerofraction) cells and initializes them to value, all the rest will be initialized to zero. note that this is not the same as setting each cell with probability nonzerofraction to value. note: the random seed is a constant. @throws illegalargumentexception if nonzerofraction  1. @see cern.jet.random.sampling.randomsampler public static final doublefactory2d rowcompressedmodified = new doublefactory2d(); force both to have maximal shared number of rows. concatenate force both to have maximal shared number of columns. concatenate determine maximum column width of each column determine row height of each row shape of result copy determine maximum column width of each column determine row height of each row shape of result parts copy system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts1).tostring()));  system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts3).tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts4).tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts1).tostring()));  system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts3).tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(make(parts4).tostring())); if (this==rowcompressedmodified) return new rcmdoublematrix2d(rows,columns);"
cern.colt.matrix.DoubleFactory3D "factory for convenient construction of 3-d matrices holding double cells. use idioms like doublefactory3d.dense.make(4,4,4) to construct dense matrices, doublefactory3d.sparse.make(4,4,4) to construct sparse matrices. if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:    doublefactory3d f = doublefactory3d.dense; f.make(4,4,4); f.descending(10,20,5); f.random(4,4,5); ...    a factory producing dense matrices. a factory producing sparse matrices. makes this class non instantiable, but still let's others inherit from it. constructs a matrix with cells having ascending values. for debugging purposes. constructs a matrix with cells having descending values. for debugging purposes. constructs a matrix with the given cell values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value. constructs a matrix with uniformly distributed values in (0,1) (exclusive)."
cern.colt.matrix.DoubleMatrix1D "abstract base class for 1-d matrices (aka vectors) holding double elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of cells (its size), which are assigned upon instance construction. elements are accessed via zero based indexes. legal indexes are of the form [0..size()-1]. any attempt to access an element at a coordinate index&lt;0 || index&gt;=size() will throw an indexoutofboundsexception. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(i)) ) and terminators are a(1) == f(get(0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; matrix = 0 1 2 3 // sum( x[i]x[i] ) matrix.aggregate(f.plus,f.square); --> 14  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. @see cern.jet.math.functions applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(i),other.get(i)) ) and terminators are a(1) == f(get(0),other.get(0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x = 0 1 2 3 y = 0 1 2 3 // sum( x[i]y[i] ) x.aggregate(y, f.plus, f.mult); --> 14 // sum( (x[i]+y[i])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 56  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if size() != other.size(). @see cern.jet.math.functions sets all cells to the state specified by values. values is required to have the same number of cells as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != size(). sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[i] = function(x[i]). (iterates downwards from [size()-1] to [0]).  example:  // change each cell to its sine matrix = 0.5 1.5 2.5 3.5 matrix.assign(cern.jet.math.functions.sin); --> matrix == 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same size. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if size() != other.size(). assigns the result of a function to each cell; x[i] = function(x[i],y[i]).  example:  // assign x[i] = x[i]y[i] m1 = 0 1 2 3; m2 = 0 2 4 6; m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if size() != y.size(). @see cern.jet.math.functions assigns the result of a function to each cell; x[i] = function(x[i],y[i]). (iterates downwards from [size()-1] to [0]).  example:  // assign x[i] = x[i]y[i] m1 = 0 1 2 3; m2 = 0 2 4 6; m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 1 16 729 // for non-standard functions there is no shortcut: m1.assign(m2, &nbsp;&nbsp;&nbsp;new doubledoublefunction() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(double x, double y) { return math.pow(x,y); } &nbsp;&nbsp;&nbsp;} );  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if size() != y.size(). @see cern.jet.math.functions returns the number of cells having non-zero values; ignores tolerance. returns the number of cells having non-zero values, but at most maxcardinality; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. returns whether all cells are equal to the given value. value the value to test against. true if all cells are equal to the given value, false otherwise. compares this object against the specified object. the result is true if and only if the argument is not null and is at least a doublematrix1d object that has the same sizes as the receiver and has exactly the same values at the same indexes. obj the object to compare with. true if the objects are the same; false otherwise. returns the matrix cell value at coordinate index. index the index of the cell. the value of the specified cell. @throws indexoutofboundsexception if index&lt;0 || index&gt;=size(). returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fills like: for (index = 0..size()-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell).  example:   0, 0, 8, 0, 7 --> indexlist = (2,4) valuelist = (8,7)  in other words, get(2)==8, get(4)==7. the list to be filled with indexes, can have any size. the list to be filled with values, can have any size. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fills like: for (index = 0..size()-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell).  example:   0, 0, 8, 0, 7 --> indexlist = (2,4) valuelist = (8,7)  in other words, get(2)==8, get(4)==7. the list to be filled with indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. index the index of the cell. value the value to be filled into the specified cell. @throws indexoutofboundsexception if index&lt;0 || index&gt;=size(). sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. swaps each element this[i] with other[i]. @throws illegalargumentexception if size() != other.size(). constructs and returns a 1-dimensional array containing the cell values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the returned array values has the form  for (int i=0; i  array filled with the values of the cells. fills the cell values into the specified 1-dimensional array. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. after this call returns the array values has the form  for (int i=0; i  @throws illegalargumentexception if values.length . returns a string representation using default formatting. @see cern.colt.matrix.doublealgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new flip view. what used to be index 0 is now index size()-1, ..., what used to be index size()-1 is now index 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. constructs and returns a new sub-range view that is a width sub matrix starting at index. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from index..index+width-1. and has view.size() == width. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view are 0 .. view.size()-1==width-1. as usual, any attempt to access a cell at other coordinates will throw an indexoutofboundsexception. index the index of the first cell. width the width of the range. @throws indexoutofboundsexception if indexsize(). new view. constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.size() == indexes.length and view.get(i) == this.get(indexes[i]). indexes can occur multiple times and can be in arbitrary order.  example:   this = (0,0,8,0,7) indexes = (0,2,4,2) --> view = (0,8,7,8)  note that modifying indexes after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. indexes the indexes of the cells that shall be visible in the new view. to indicate that all cells shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..indexes.length()-1. constructs and returns a new selection view that is a matrix holding the cells matching the given condition. applies the condition to each cell and takes only those cells where condition.apply(get(i)) yields true.  example:   // extract and view all cells with even value matrix = 0 1 2 3 matrix.viewselection( &nbsp;&nbsp;&nbsp;new doubleprocedure() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(double a) { return a % 2 == 0; } &nbsp;&nbsp;&nbsp;} ); --> matrix == 0 2  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. a new view. sorts the vector into ascending order, according to the natural ordering. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.doublealgo.sorting#sort(doublematrix1d)}. for more advanced sorting functionality, see {@link cern.colt.matrix.doublealgo.sorting}. new sorted vector (matrix) view. constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has size this.size()/stride holding cells this.get(istride) for all i = 0..size()/stride - 1. stride the step factor. @throws indexoutofboundsexception if stride . new view. applies a procedure to each cell's value. iterates downwards from [size()-1] to [0], as demonstrated by this snippet:  for (int i=size(); --i >=0;) { if (!procedure.apply(getquick(i))) return false; } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the dot product of two vectors x and y, which is sum(x[i]y[i]). where x == this. operates on cells at indexes 0 .. math.min(size(),y.size()). the second vector. sum of products. returns the dot product of two vectors x and y, which is sum(x[i]y[i]). where x == this. operates on cells at indexes from .. min(size(),y.size(),from+length)-1. the second vector. the first index to be considered. the number of cells to be considered. sum of products; zero if from. returns the dot product of two vectors x and y, which is sum(x[i]y[i]). where x == this. the second vector. the indexes of cells in yhaving a non-zero value. sum of products. returns the dot product of two vectors x and y, which is sum(x[i]y[i]). where x == this. the second vector. the indexes of cells in yhaving a non-zero value. sum of products. double sum = 0; int[] nonzeroindexelements = nonzeroindexes.elements(); for (int index=nonzeroindexes.size(); --index >= 0; ) { int i = nonzeroindexelements[index]; sum += getquick(i) y.getquick(i); } return sum; returns the sum of all cells; sum( x[i] ). sum. sum( x[i]x[i] ) sum( x[i]y[i] ) sum( (x[i]+y[i])^2 ) change each cell to its sine assign x[i] = x[i]y[i] assign x[i] = x[i]y[i] for non-standard functions there is no shortcut: specialized for speed x[i] = x[i] y[i] x[i] = 0 for all zeros x[i] y[i] for all nonzeros x[i] = x[i] + 0y[i] x[i] = x[i] + y[i] x[i] = x[i] - y[i] the general case x[i] = x[i] + multy[i] the general case x[i] = f(x[i],y[i]) check for "all" extract and view all cells with even value determine minimum length setup skip to start now the sparse dot product"
cern.colt.matrix.DoubleMatrix1DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.matrix.DoubleMatrix2D "abstract base class for 2-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of rows and columns, which are assigned upon instance construction - the matrix's size is then rows()columns(). elements are accessed via [row,column] coordinates. legal coordinates range from [0,0] to [rows()-1,columns()-1]. any attempt to access an element at a coordinate column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() will throw an indexoutofboundsexception.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(row,column)) ) and terminators are a(1) == f(get(0,0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; 2 x 2 matrix 0 1 2 3 // sum( x[row,col]x[row,col] ) matrix.aggregate(f.plus,f.square); --> 14  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. @see cern.jet.math.functions applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(row,column),other.get(row,column)) ) and terminators are a(1) == f(get(0,0),other.get(0,0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x == 2 x 2 matrix 0 1 2 3 y == 2 x 2 matrix 0 1 2 3 // sum( x[row,col] y[row,col] ) x.aggregate(y, f.plus, f.mult); --> 14 // sum( (x[row,col] + y[row,col])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 56  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions sets all cells to the state specified by values. values is required to have the form values[row][column] and have exactly the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns(). sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[row,col] = function(x[row,col]).  example:  matrix = 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 2 x 2 matrix 0 1 2 3 m2 = 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions returns the number of cells having non-zero values; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. returns whether all cells are equal to the given value. value the value to test against. true if all cells are equal to the given value, false otherwise. compares this object against the specified object. the result is true if and only if the argument is not null and is at least a doublematrix2d object that has the same number of columns and rows as the receiver and has exactly the same values at the same coordinates. obj the object to compare with. true if the objects are the same; false otherwise. assigns the result of a function to each non-zero cell; x[row,col] = function(x[row,col]). use this method for fast special-purpose iteration. if you want to modify another matrix instead of this (i.e. work in read-only mode), simply return the input value unchanged. parameters to function are as follows: first==row, second==column, third==nonzerovalue. a function object taking as argument the current non-zero cell's row, column and value. this (for convenience only). returns the matrix cell value at coordinate [row,column]. row the index of the row-coordinate. column the index of the column-coordinate. the value of the specified cell. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fills like for (row = 0..rows-1) for (column = 0..columns-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell).  example:   2 x 3 matrix: 0, 0, 8 0, 7, 0 --> rowlist = (0,1) columnlist = (2,1) valuelist = (8,7)  in other words, get(0,2)==8, get(1,1)==7. the list to be filled with row indexes, can have any size. the list to be filled with column indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. constructs and returns a 2-dimensional array containing the cell values. the returned array values has the form values[row][column] and has the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. array filled with the values of the cells. returns a string representation using default formatting. @see cern.colt.matrix.doublealgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   the column to fix. new slice view. @throws indexoutofboundsexception if column = columns(). @see #viewrow(int) constructs and returns a new flip view along the column axis. what used to be column 0 is now column columns()-1, ..., what used to be column columns()-1 is now column 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  columnflip ==> 2 x 3 matrix: 3, 2, 1  6, 5, 4 columnflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewrowflip() constructs and returns a new dice (transposition) view; swaps axes; example: 3 x 4 matrix --> 4 x 3 matrix. the view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns. in other words: view.get(row,column)==this.get(column,row). this is a zero-copy transposition, taking o(1), i.e. constant time. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. use idioms like result = viewdice(a).copy() to generate an independent transposed matrix.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  transpose ==> 3 x 2 matrix: 1, 4  2, 5  3, 6 transpose ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new dice view. constructs and returns a new sub-range view that is a height x width sub matrix starting at [row,column]. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from [row,column] to [row+height-1,column+width-1], all inclusive. and has view.rows() == height; view.columns() == width;. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view range from [0,0] to [view.rows()-1==height-1,view.columns()-1==width-1]. as usual, any attempt to access a cell at a coordinate column&lt;0 || column&gt;=view.columns() || row&lt;0 || row&gt;=view.rows() will throw an indexoutofboundsexception. row the index of the row-coordinate. column the index of the column-coordinate. height the height of the box. width the width of the box. @throws indexoutofboundsexception if columncolumns() || rowrows() new view. constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   the row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) constructs and returns a new flip view along the row axis. what used to be row 0 is now row rows()-1, ..., what used to be row rows()-1 is now row 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  rowflip ==> 2 x 3 matrix: 4, 5, 6  1, 2, 3 rowflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewcolumnflip() constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.rows() == rowindexes.length, view.columns() == columnindexes.length and view.get(i,j) == this.get(rowindexes[i],columnindexes[j]). indexes can occur multiple times and can be in arbitrary order.  example:  this = 2 x 3 matrix: 1, 2, 3 4, 5, 6 rowindexes = (0,1) columnindexes = (1,0,1,0) --> view = 2 x 4 matrix: 2, 1, 2, 1 5, 4, 5, 4  note that modifying the index arguments after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to indicate "all" rows or "all columns", simply set the respective parameter rowindexes the rows of the cells that shall be visible in the new view. to indicate that all rows shall be visible, simply set this parameter to null. columnindexes the columns of the cells that shall be visible in the new view. to indicate that all columns shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..rowindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..columnindexes.length()-1. constructs and returns a new selection view that is a matrix holding all rows matching the given condition. applies the condition to each row and takes only those row where condition.apply(viewrow(i)) yields true. to match columns, use a dice view.  example:   // extract and view all rows which have a value  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. sorts the matrix rows into ascending order, according to the natural ordering of the matrix values in the given column. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.doublealgo.sorting#sort(doublematrix2d,int)}. for more advanced sorting functionality, see {@link cern.colt.matrix.doublealgo.sorting}. new sorted vector (matrix) view. @throws indexoutofboundsexception if column = columns(). constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has this.rows()/rowstride rows and this.columns()/columnstride columns holding cells this.get(irowstride,jcolumnstride) for all i = 0..rows()/rowstride - 1, j = 0..columns()/columnstride - 1. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the row step factor. the column step factor. new view. @throws indexoutofboundsexception if rowstride. applies a procedure to each cell's value. iterates downwards from [rows()-1,columns()-1] to [0,0], as demonstrated by this snippet:  for (int row=rows; --row >=0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(getquick(row,column))) return false; } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. 8 neighbor stencil transformation. for efficient finite difference operations. applies a function to a moving 3 x 3 window. does nothing if rows() .  b[i,j] = function.apply( &nbsp;&nbsp;&nbsp;a[i-1,j-1], a[i-1,j], a[i-1,j+1], &nbsp;&nbsp;&nbsp;a[i, j-1], a[i, j], a[i, j+1], &nbsp;&nbsp;&nbsp;a[i+1,j-1], a[i+1,j], a[i+1,j+1] &nbsp;&nbsp;&nbsp;) x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x  make sure that cells of this and b do not overlap. in case of overlapping views, behaviour is unspecified.   example:  final double alpha = 0.25; final double beta = 0.75; // 8 neighbors cern.colt.function.double9function f = new cern.colt.function.double9function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa11 + alpha(a00+a01+a02 + a10+a12 + a20+a21+a22); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} }; a.zassign8neighbors(b,f); // 4 neighbors cern.colt.function.double9function g = new cern.colt.function.double9function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa11 + alpha(a01+a10+a12+a21); &nbsp;&nbsp;&nbsp;} c.zassign8neighbors(b,g); // fast, even though it doesn't look like it };  the matrix to hold the results. the function to be applied to the 9 cells. @throws nullpointerexception if function==null. @throws illegalargumentexception if rows() != b.rows() || columns() != b.columns(). linear algebraic matrix-vector multiplication; z = a y; equivalent to return a.zmult(y,z,1,0); linear algebraic matrix-vector multiplication; z = alpha a y + betaz. z[i] = alphasum(a[i,j] y[j]) + betaz[i], i=0..a.rows()-1, j=0..y.size()-1. where a == this.  note: matrix shape conformance is checked after potential transpositions. the source vector. the vector where results are to be stored. set this parameter to null to indicate that a new result vector shall be constructed. (for convenience only). @throws illegalargumentexception if a.columns() != y.size() || a.rows() > z.size()). linear algebraic matrix-matrix multiplication; c = a x b; equivalent to a.zmult(b,c,1,0,false,false). linear algebraic matrix-matrix multiplication; c = alpha a x b + betac. c[i,j] = alphasum(a[i,k] b[k,j]) + betac[i,j], k=0..n-1.  matrix shapes: a(m x n), b(n x p), c(m x p).  note: matrix shape conformance is checked after potential transpositions. the second source matrix. the matrix where results are to be stored. set this parameter to null to indicate that a new result matrix shall be constructed. (for convenience only). @throws illegalargumentexception if b.rows() != a.columns(). @throws illegalargumentexception if c.rows() != a.rows() || c.columns() != b.columns(). @throws illegalargumentexception if a == c || b == c. returns the sum of all cells; sum( x[i,j] ). sum. sum( x[row,col]x[row,col] ) last cell already done sum( x[row,col] y[row,col] ) sum( (x[row,col] + y[row,col])^2 ) last cell already done for (int row=rows; --row >= 0;) { for (int column=columns; --column >= 0;) { change each cell to its sine for (int row=0; rowy[row,col] check for "all" extract and view all rows which have a value < threshold in the first column (representing "age") extract and view all rows with rms < threshold the rms (root-mean-square) is a measure of the average "size" of the elements of a data sequence. take all columns 8 neighbors 4 neighbors fast, even though it doesn't look like it nothing to do in each step six cells can be remembered in registers - they don't need to be reread from slow memory in each step 3 instead of 9 cells need to be read from memory. boolean ignore = (z==null);"
cern.colt.matrix.DoubleMatrix2DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.matrix.DoubleMatrix3D "abstract base class for 3-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of slices, rows and columns, which are assigned upon instance construction - the matrix's size is then slices()rows()columns(). elements are accessed via [slice,row,column] coordinates. legal coordinates range from [0,0,0] to [slices()-1,rows()-1,columns()-1]. any attempt to access an element at a coordinate slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column() will throw an indexoutofboundsexception.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(slice,row,column)) ) and terminators are a(1) == f(get(0,0,0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 // sum( x[slice,row,col]x[slice,row,col] ) matrix.aggregate(f.plus,f.square); --> 140  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. @see cern.jet.math.functions applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(slice,row,column),other.get(slice,row,column)) ) and terminators are a(1) == f(get(0,0,0),other.get(0,0,0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x = 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 y = 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 // sum( x[slice,row,col] y[slice,row,col] ) x.aggregate(y, f.plus, f.mult); --> 140 // sum( (x[slice,row,col] + y[slice,row,col])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 560  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() @see cern.jet.math.functions sets all cells to the state specified by values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[slice,row,col] = function(x[slice,row,col]).  example:  matrix = 1 x 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 1 x 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of slices, rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 1 x 2 x 2 matrix 0 1 2 3 m2 = 1 x 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 x 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() @see cern.jet.math.functions returns the number of cells having non-zero values; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. returns whether all cells are equal to the given value. value the value to test against. true if all cells are equal to the given value, false otherwise. compares this object against the specified object. the result is true if and only if the argument is not null and is at least a doublematrix3d object that has the same number of slices, rows and columns as the receiver and has exactly the same values at the same coordinates. obj the object to compare with. true if the objects are the same; false otherwise. returns the matrix cell value at coordinate [slice,row,column]. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value of the specified cell. @throws indexoutofboundsexception if slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fill like: for (slice = 0..slices-1) for (row = 0..rows-1) for (column = 0..colums-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell). for an example, see {@link doublematrix2d#getnonzeros(intarraylist,intarraylist,doublearraylist)}. the list to be filled with slice indexes, can have any size. the list to be filled with row indexes, can have any size. the list to be filled with column indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. @throws indexoutofboundsexception if row&lt;0 || row&gt;=rows() || slice&lt;0 || slice&gt;=slices() || column&lt;0 || column&gt;=column(). sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. constructs and returns a 2-dimensional array containing the cell values. the returned array values has the form values[slice][row][column] and has the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. array filled with the values of the cells. returns a string representation using default formatting. @see cern.colt.matrix.doublealgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} if you want to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new flip view along the column axis. what used to be column 0 is now column columns()-1, ..., what used to be column columns()-1 is now column 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewsliceflip() @see #viewrowflip() constructs and returns a new dice view; swaps dimensions (axes); example: 3 x 4 x 5 matrix --> 4 x 3 x 5 matrix. the view has dimensions exchanged; what used to be one axis is now another, in all desired permutations. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 0 the axis that shall become axis 0 (legal values 0..2). 1 the axis that shall become axis 1 (legal values 0..2). 2 the axis that shall become axis 2 (legal values 0..2). new dice view. @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new sub-range view that is a depth x height x width sub matrix starting at [slice,row,column]; equivalent to view().part(slice,row,column,depth,height,width); provided for convenience only. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. depth the depth of the box. height the height of the box. width the width of the box. @throws indexoutofboundsexception if sliceslices() || rowrows() || columncolumns() new view. constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) constructs and returns a new flip view along the row axis. what used to be row 0 is now row rows()-1, ..., what used to be row rows()-1 is now row 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewsliceflip() @see #viewcolumnflip() constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.slices() == sliceindexes.length, view.rows() == rowindexes.length, view.columns() == columnindexes.length and view.get(k,i,j) == this.get(sliceindexes[k],rowindexes[i],columnindexes[j]). indexes can occur multiple times and can be in arbitrary order. for an example see {@link doublematrix2d#viewselection(int[],int[])}.  note that modifying the index arguments after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. sliceindexes the slices of the cells that shall be visible in the new view. to indicate that all slices shall be visible, simply set this parameter to null. rowindexes the rows of the cells that shall be visible in the new view. to indicate that all rows shall be visible, simply set this parameter to null. columnindexes the columns of the cells that shall be visible in the new view. to indicate that all columns shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..sliceindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..rowindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..columnindexes.length()-1. constructs and returns a new selection view that is a matrix holding all slices matching the given condition. applies the condition to each slice and takes only those where condition.apply(viewslice(i)) yields true. to match rows or columns, use a dice view.  example:   // extract and view all slices which have an aggregate sum > 1000 matrix.viewselection( &nbsp;&nbsp;&nbsp;new doublematrix2dprocedure() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(doublematrix2d m) { return m.zsum > 1000; } &nbsp;&nbsp;&nbsp;} );  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) constructs and returns a new flip view along the slice axis. what used to be slice 0 is now slice slices()-1, ..., what used to be slice slices()-1 is now slice 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewrowflip() @see #viewcolumnflip() sorts the matrix slices into ascending order, according to the natural ordering of the matrix values in the given [row,column] position. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.doublealgo.sorting#sort(doublematrix3d,int,int)}. for more advanced sorting functionality, see {@link cern.colt.matrix.doublealgo.sorting}. new sorted vector (matrix) view. @throws indexoutofboundsexception if row = rows() || column = columns(). constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has this.slices()/slicestride slices and this.rows()/rowstride rows and this.columns()/columnstride columns holding cells this.get(kslicestride,irowstride,jcolumnstride) for all k = 0..slices()/slicestride - 1, i = 0..rows()/rowstride - 1, j = 0..columns()/columnstride - 1. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the slice step factor. the row step factor. the column step factor. new view. @throws indexoutofboundsexception if slicestride. applies a procedure to each cell's value. iterates downwards from [slices()-1,rows()-1,columns()-1] to [0,0,0], as demonstrated by this snippet:  for (int slice=slices; --slice >=0;) { for (int row=rows; --row >= 0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(get(slice,row,column))) return false; } } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. applies a procedure to each cell's coordinate. iterates downwards from [slices()-1,rows()-1,columns()-1] to [0,0,0], as demonstrated by this snippet:  for (int slice=slices; --slice >=0;) { for (int row=rows; --row >= 0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(slice,row,column)) return false; } } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as first argument the current slice, as second argument the current row, and as third argument the current column. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. 27 neighbor stencil transformation. for efficient finite difference operations. applies a function to a moving 3 x 3 x 3 window. does nothing if rows() .  b[k,i,j] = function.apply( &nbsp;&nbsp;&nbsp;a[k-1,i-1,j-1], a[k-1,i-1,j], a[k-1,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k-1,i, j-1], a[k-1,i, j], a[k-1,i, j+1], &nbsp;&nbsp;&nbsp;a[k-1,i+1,j-1], a[k-1,i+1,j], a[k-1,i+1,j+1], &nbsp;&nbsp;&nbsp;a[k ,i-1,j-1], a[k ,i-1,j], a[k ,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k ,i, j-1], a[k ,i, j], a[k ,i, j+1], &nbsp;&nbsp;&nbsp;a[k ,i+1,j-1], a[k ,i+1,j], a[k ,i+1,j+1], &nbsp;&nbsp;&nbsp;a[k+1,i-1,j-1], a[k+1,i-1,j], a[k+1,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k+1,i, j-1], a[k+1,i, j], a[k+1,i, j+1], &nbsp;&nbsp;&nbsp;a[k+1,i+1,j-1], a[k+1,i+1,j], a[k+1,i+1,j+1] &nbsp;&nbsp;&nbsp;) x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x  make sure that cells of this and b do not overlap. in case of overlapping views, behaviour is unspecified.   example:  final double alpha = 0.25; final double beta = 0.75; cern.colt.function.double27function f = new cern.colt.function.double27function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a000, double a001, double a002, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a010, double a011, double a012, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a020, double a021, double a022, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a100, double a101, double a102, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a110, double a111, double a112, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a120, double a121, double a122, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a200, double a201, double a202, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a210, double a211, double a212, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a220, double a221, double a222) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa111 + alpha(a000 + ... + a222); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} }; a.zassign27neighbors(b,f);  the matrix to hold the results. the function to be applied to the 27 cells. @throws nullpointerexception if function==null. @throws illegalargumentexception if rows() != b.rows() || columns() != b.columns() || slices() != b.slices() . returns the sum of all cells; sum( x[i,j,k] ). sum. sum( x[slice,row,col]x[slice,row,col] ) last cell already done sum( x[slice,row,col] y[slice,row,col] ) sum( (x[slice,row,col] + y[slice,row,col])^2 ) last cell already done change each cell to its sine assign x[row,col] = x[row,col]y[row,col] int sliceoffset = index(0,0,column); int sliceoffset = index(0,row,0); check for "all" extract and view all slices which have an aggregate sum > 1000 take all rows and columns int sliceoffset = index(slice,0,0); nothing to do in each step 18 cells can be remembered in registers - they don't need to be reread from slow memory in each step 9 instead of 27 cells need to be read from memory."
cern.colt.matrix.DoubleMatrix3DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.matrix.impl.AbstractFormatter "abstract base class for flexible, well human readable matrix print formatting. value type independent. a single cell is formatted via a format string. columns can be aligned left, centered, right and by decimal point. a column can be broader than specified by the parameter mincolumnwidth (because a cell may not fit into that width) but a column is never smaller than mincolumnwidth. normally one does not need to specify mincolumnwidth. cells in a row are separated by a separator string, similar separators can be set for rows and slices. for more info, see the concrete subclasses. the alignment string aligning the cells of a column to the left. the alignment string aligning the cells of a column to its center. the alignment string aligning the cells of a column to the right. the alignment string aligning the cells of a column to the decimal point. the default minimum number of characters a column may have; currently 1. the default string separating any two columns from another; currently " ". the default string separating any two rows from another; currently "\n". the default string separating any two slices from another; currently "\n\n". the default format string for formatting a single cell value; currently "%g". the default format string for formatting a single cell value; currently "%g". the default minimum number of characters a column may have; currently 1. the default string separating any two columns from another; currently " ". the default string separating any two rows from another; currently "\n". the default string separating any two slices from another; currently "\n\n". tells whether string representations are to be preceded with summary of the shape; currently true. makes this class non instantiable, but still let's others inherit from it. modifies the strings in a column of the string matrix to be aligned (left,centered,right,decimal). converts a row into a string. modifies the strings the string matrix to be aligned (left,centered,right,decimal). returns a string with length blanks. demonstrates how to use this class. // parameters object[][] values = { {3, 0, -3.4, 0}, {5.1 ,0, +3.0123456789, 0}, {16.37, 0.0, 2.5, 0}, {-16.3, 0, -3.012345678e-4, -1}, {1236.3456789, 0, 7, -1.2} }; string[] formats = {"%g", "%1.10g", "%f", "%1.2f", "%0.2e", null}; // now the processing int size = formats.length; objectmatrix2d matrix = cern.colt.matrix.objectfactory2d.dense.make(values); string[] strings = new string[size]; string[] sourcecodes = new string[size]; string[] htmlstrings = new string[size]; string[] htmlsourcecodes = new string[size]; for (int i=0; i= 0; ) { for (int j=size; --j >= 0; ) { buf.append(matrix.getquick(i,j)); } } buf = null; timer.stop().display(); timer.reset().start(); corejava.format format = new corejava.format("%g"); buf = new stringbuffer(); for (int i=size; --i >= 0; ) { for (int j=size; --j >= 0; ) { buf.append(format.form(matrix.getquick(i,j))); } } buf = null; timer.stop().display(); timer.reset().start(); s = formatting.tostring(matrix, null); //system.out.println(s); s = null; timer.stop().display(); timer.reset().start(); s = formatting.tostring(matrix, "%g"); //system.out.println(s); s = null; timer.stop().display(); converts a given cell to a string; no alignment considered. returns a string representations of all cells; no alignment considered. returns a string representations of all cells; no alignment considered. returns the number of characters or the number of characters before the decimal point. returns a string with the given character repeated length times. sets the column alignment (left,center,right,decimal). the new alignment to be used; must be one of {left,center,right,decimal}. sets the string separating any two columns from another. the new columnseparator to be used. sets the way a single cell value is to be formatted. the new format to be used. sets the minimum number of characters a column may have. the new mincolumnwidth to be used. specifies whether a string representation of a matrix is to be preceded with a summary of its shape. true shape summary is printed, otherwise not printed. sets the string separating any two rows from another. the new rowseparator to be used. sets the string separating any two slices from another. the new sliceseparator to be used. cache for faster string processing. returns a short string representation describing the shape of the matrix. returns a short string representation describing the shape of the matrix. returns a short string representation describing the shape of the matrix. returns a single string representation of the given string matrix. the matrix to be converted to a single string. returns a string representation of the given matrix. the matrix to convert. for efficient string manipulations int[] maxcoltrail = new int[columns]; for each column, determine alignment parameters int maxtrail = integer.min_value; maxtrail = math.max(maxtrail, trail(s)); maxcoltrail[column] = maxtrail; format each row according to alignment parameters stringbuffer total = new stringbuffer(); {-1,0,1,2} = {left,centered,right,decimal point} {-1,0,1,2} = {left,centered,right,decimal point} if (alignment==1) { else if (alignment==2) { else if (align==0) { else if (align somewhat smaller static memory footprint system.out.println(i+"-"+blankscache[i]+"-"); return "matrix1d of size="+matrix.size(); return matrix.size()+" element matrix"; return "matrix("+matrix.size()+")";"
cern.colt.matrix.impl.AbstractMatrix "abstract base class for arbitrary-dimensional matrices holding objects or primitive data types such as int, float, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. ensures that the receiver can hold at least the specified number of non-zero (non-null) cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this default implementation does nothing. override this method if necessary. minnonzeros the desired minimum number of non-zero (non-null) cells. returns whether the receiver is a view or not. returns the number of cells. releases any superfluous internal memory. an application can use this operation to minimize the storage of the receiver.  this default implementation does nothing. override this method if necessary. public static boolean debug = true;"
cern.colt.matrix.impl.AbstractMatrix1D "abstract base class for 1-d matrices (aka vectors) holding objects or primitive data types such as int, double, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. the number of cells this matrix (view) has the index of the first element the number of indexes between any two elements, i.e. index(i+1) - index(i). indicates non-flipped state (flip==1) or flipped state (flip==-1). see _setflip() for further info. indicates non-flipped state or flipped state. see _setflip() for further info. makes this class non instantiable, but still let's others inherit from it. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. sanity check for operations requiring an index to be within bounds. @throws indexoutofboundsexception if index = size(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. checks whether the receiver contains the given range and throws an exception, if necessary. @throws indexoutofboundsexception if indexsize(). sanity check for operations requiring two matrices with the same size. @throws illegalargumentexception if size() != b.size(). sanity check for operations requiring two matrices with the same size. @throws illegalargumentexception if size() != b.size(). returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. sets up a matrix with a given number of cells. the number of cells the matrix shall have. @throws illegalargumentexception if size. sets up a matrix with the given parameters. the number of elements the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). @throws illegalargumentexception if size. returns the number of cells. returns the stride of the given dimension (axis, rank). @dimension the index of the dimension. stride in the given dimension. @throws illegalargumentexception if dimension != 0. returns a string representation of the receiver's shape. self modifying version of viewflip(). what used to be index 0 is now index size()-1, ..., what used to be index size()-1 is now index 0. self modifying version of viewpart(). @throws indexoutofboundsexception if indexsize(). self modifying version of viewstrides(). @throws indexoutofboundsexception if stride . protected int flip; protected int flipmask; this.isnoview implies: offset==0, stride==1 return zero + ((rank+flipmask)^flipmask); return zero + rankflip; // slower"
cern.colt.matrix.impl.AbstractMatrix2D "abstract base class for 2-d matrices holding objects or primitive data types such as int, double, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. the number of colums and rows this matrix (view) has the number of elements between two rows, i.e. index(i+1,j,k) - index(i,j,k). the number of elements between two columns, i.e. index(i,j+1,k) - index(i,j,k). the index of the first element indicates non-flipped state (flip==1) or flipped state (flip==-1). see _setflip() for further info. indicates non-flipped state or flipped state. see _setflip() for further info. makes this class non instantiable, but still let's others inherit from it. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. checks whether the receiver contains the given box and throws an exception, if necessary. @throws indexoutofboundsexception if columncolumns() || rowrows() sanity check for operations requiring a column index to be within bounds. @throws indexoutofboundsexception if column = columns(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. sanity check for operations requiring a row index to be within bounds. @throws indexoutofboundsexception if row = rows(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. sanity check for operations requiring two matrices with the same number of columns and rows. @throws illegalargumentexception if columns() != b.columns() || rows() != b.rows(). sanity check for operations requiring matrices with the same number of columns and rows. @throws illegalargumentexception if columns() != b.columns() || rows() != b.rows() || columns() != c.columns() || rows() != c.rows(). returns the number of columns. returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. returns the number of rows. sets up a matrix with a given number of rows and columns. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. sets up a matrix with a given number of rows and columns and the given strides. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). @throws illegalargumentexception if rows integer.max_value or flip's are illegal. returns the number of cells which is rows()columns(). returns a string representation of the receiver's shape. self modifying version of viewcolumnflip(). self modifying version of viewdice(). self modifying version of viewpart(). @throws indexoutofboundsexception if columncolumns() || rowrows() self modifying version of viewrowflip(). self modifying version of viewstrides(). @throws indexoutofboundsexception if rowstride. protected int rowflip, columnflip; protected int rowflipmask, columnflipmask; return columnzero + ((rank+columnflipmask)^columnflipmask); return columnzero + rankcolumnflip; // slower return rowzero + ((rank+rowflipmask)^rowflipmask); return rowzero + rankrowflip; // slower swap; flips stay unaffected"
cern.colt.matrix.impl.AbstractMatrix3D "abstract base class for 3-d matrices holding objects or primitive data types such as int, double, etc. first see the package summary and javadoc tree view to get the broad picture.  note that this implementation is not synchronized. the number of slices this matrix (view) has the number of rows this matrix (view) has the number of columns this matrix (view) has the number of elements between two slices, i.e. index(k+1,i,j) - index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j) - index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1) - index(k,i,j). the index of the first element makes this class non instantiable, but still let's others inherit from it. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the absolute rank of the given relative rank. rank the relative rank of the element. absolute rank of the element. checks whether the receiver contains the given box and throws an exception, if necessary. @throws indexoutofboundsexception if rowrows || sliceslices || columncolumns sanity check for operations requiring a column index to be within bounds. @throws indexoutofboundsexception if column = columns(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. sanity check for operations requiring a row index to be within bounds. @throws indexoutofboundsexception if row = rows(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. sanity check for operations requiring two matrices with the same number of slices, rows and columns. @throws illegalargumentexception if slices() != b.slices() || rows() != b.rows() || columns() != b.columns(). sanity check for operations requiring matrices with the same number of slices, rows and columns. @throws illegalargumentexception if slices() != b.slices() || rows() != b.rows() || columns() != b.columns() || slices() != c.slices() || rows() != c.rows() || columns() != c.columns(). sanity check for operations requiring a slice index to be within bounds. @throws indexoutofboundsexception if slice = slices(). checks whether indexes are legal and throws an exception, if necessary. @throws indexoutofboundsexception if ! (0  for any i=0..indexes.length()-1. returns the number of columns. returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. returns the number of rows. sets up a matrix with a given number of slices and rows. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)rowsslices > integer.max_value. @throws illegalargumentexception if slices. sets up a matrix with a given number of slices and rows and the given strides. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the position of the first element. the number of elements between two slices, i.e. index(k+1,i,j)-index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j)-index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1)-index(k,i,j). @throws illegalargumentexception if (double)slicesrowscolumnss > integer.max_value. @throws illegalargumentexception if slices. returns the number of cells which is slices()rows()columns(). returns the number of slices. returns a string representation of the receiver's shape. self modifying version of viewcolumnflip(). self modifying version of viewdice(). @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. self modifying version of viewpart(). @throws indexoutofboundsexception if sliceslices() || rowrows() || columncolumns() self modifying version of viewrowflip(). self modifying version of viewsliceflip(). self modifying version of viewstrides(). @throws indexoutofboundsexception if slicestride. this.isnoview implies: offset==0, slicestride==rowsslices, rowstride==columns, columnstride==1 swap shape swap strides"
cern.colt.matrix.impl.Benchmark "benchmarks the performance of matrix algorithms. makes this class non instantiable, but still let's others inherit from it. runs a bench on matrices holding double elements. long nn = matrix.size(); int nn = (int) (nnpercentnonzero); long[] nonzeroindexes = new long[nn]; cern.jet.random.sampling.randomsampler sampler = new cern.jet.random.sampling.randomsampler(nn,nn,0,new cern.jet.random.engine.mersennetwister()); sampler.nextblock(nn,nonzeroindexes,0); for (int i=nn; --i >=0; ) { int row = (int) (nonzeroindexes[i]/size); int column = (int) (nonzeroindexes[i]%size); matrix.set(row,column, value); } timer1.start(); for (int i=0; i<runs; i++) { ludecomposition lu = new ludecomposition(matrix); } timer1.stop(); timer1.display(); { jama.matrix jmatrix = new jama.matrix(matrix.toarray()); timer2.start(); for (int i=0; i<runs; i++) { jama.ludecomposition lu = new jama.ludecomposition(jmatrix); } timer2.stop(); timer2.display(); } { timer6.start(); double a = cubicloop(runs,size); timer6.stop(); timer6.display(); system.out.println(a); } { doublematrix2d a = matrix.like().assign(value); doublematrix2d b = matrix.like().assign(value); doublematrix2d c = basic.product(a,b); timer5.start(); for (int i=0; i<runs; i++) { cern.colt.matrix.blas.matrixmultiply(a,b,c); } timer5.stop(); timer5.display(); } { jama.matrix a = new jama.matrix(size,size); jama.matrix b = new jama.matrix(size,size); jama.matrix c; timer4.start(); for (int i=0; i<runs; i++) { c = a.times(b); } timer4.stop(); timer4.display(); }  benchmarks various matrix methods. certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops else if (kind.equals("densearray")) matrix = new doublearraymatrix2d(size,size); matrix aj = new matrix(columnwise,3); basic.random(matrix, new cern.jet.random.uniform(new cern.jet.random.engine.mersennetwister())); doublematrix2d c = basic.product(a,b); int size = integer.parseint(args[3]); boolean issparse = args[4].equals("sparse");"
cern.colt.matrix.impl.BenchmarkMatrix2D "benchmarks the performance of matrices. here are the results of some encouraging measurements. note that all benchmarks only measure the time spent in accessing a matrix element; they exclude the loop itself.      iteration performance [million method calls per second] pentium pro 200 mhz, sunjdk 1.2.2, nt, java -classic, 60 times repeating the same iteration      element type   matrix2d type      .   densedoublematrix2d 1000 x 1000   &nbsp;  sparsedoublematrix2d 100 x 1000,  minloadfactor=0.2, maxloadfactor=0.5, initialcapacity = 0     getquick  setquick &nbsp; &nbsp;  getquick setquick   double 5 5 &nbsp; &nbsp; 1 0.27    int 5  5.5  &nbsp; &nbsp; 1  0.3     as can be seen, sparse matrices are certainly not quite as quick as dense ones, but not really slow either. considering their minimal footprint they can be a real alternative.  comparing the oo abstractions to zero-abstraction primitive java arrays may or may not be useful. still, the table below provides some interesting information. for example, access to type_t_matrix2d is quicker than naive usage of type_t_[]. primitive arrays should only be considered if the optimized form can be applied. note again that all benchmarks only measure the time spent in accessing a matrix element; they exclude the loop itself.      iteration performance [million element accesses per second] pentium pro 200 mhz, sunjdk 1.2.2, nt, java -classic, 200 times repeating the same iteration      element type   matrix2d type = java array double[][]      .   unoptimized form 1000 x 1000    for (int row=0; row      optimized form 1000 x 1000    for (int row=0; row        getting  setting  getting  setting   double 1.6 1.8 18 11    int 1.5  1.8 28 26     makes this class non instantiable, but still let's others inherit from it. runs a bench on matrices holding double elements. if (kind.equals("sparse")) { int hashcollisions = ((sparsedoublematrix2d)matrix).elements.hashcollisions; system.out.println("hashcollisions="+hashcollisions); system.out.println("--> "+ ((double)hashcollisions / (rowscolumns)) +" hashcollisions/element on average."); } runs a bench on matrices holding double elements. if (kind.equals("sparse")) { int hashcollisions = ((sparsedoublematrix2d)matrix).elements.hashcollisions; system.out.println("hashcollisions="+hashcollisions); system.out.println("--> "+ ((double)hashcollisions / (rowscolumns)) +" hashcollisions/element on average."); } if (kind.equals("sparse")) { int hashcollisions = ((sparsedoublematrix2d)matrix).elements.hashcollisions; system.out.println("hashcollisions="+hashcollisions); system.out.println("--> "+ ((double)hashcollisions / (rowscolumns)) +" hashcollisions/element on average."); } runs a bench on matrices holding double elements. // initializing for (int column=0; column  "+ ((double)hashcollisions / (rowscolumns)) +" probes/element on average."); } system.out.println("\nnow reading..."); if (kind.equals("sparse")) ((sparseintmatrix2d)matrix).elements.hashcollisions = 0; timer2.start(); int element=0; for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { element += matrix.getquick(row,column); } } } timer2.stop().display(); timer2.minus(emptyloop2).display(); system.out.println(size / timer2.minus(emptyloop2).seconds() +" elements / sec"); if (print) system.out.println(matrix); if (kind.equals("sparse")) system.out.println("hashcollisions="+((sparseintmatrix2d)matrix).elements.hashcollisions); system.out.println(element); // !!! so that the jitter can't optimize away the whole loop system.out.println("\nnow removing..."); before = runtime.getruntime().freememory(); if (kind.equals("sparse")) ((sparseintmatrix2d)matrix).elements.hashcollisions = 0; for (int i=0; i<runs; i++) { // initializing for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { matrix.setquick(row,column,1); } } timer3.start(); for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { matrix.setquick(row,column,0); } } timer3.stop(); } timer3.display(); timer3.minus(emptyloop).display(); system.out.println(size / timer3.minus(emptyloop).seconds() +" elements / sec"); runtime.getruntime().gc(); // invite gc try { thread.currentthread().sleep(1000); } catch (interruptedexception exc) {}; after = runtime.getruntime().freememory(); system.out.println("kb needed="+(before-after)/1024); system.out.println("kb free="+(after/1024)); if (print) system.out.println(matrix); if (kind.equals("sparse")) system.out.println("hashcollisions="+((sparseintmatrix2d)matrix).elements.hashcollisions); system.out.println("bye bye."); runs a bench on matrices holding int elements. // certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. // this involves primarly read-loops cern.colt.timer timer1 = new cern.colt.timer(); cern.colt.timer timer2 = new cern.colt.timer(); cern.colt.timer timer3 = new cern.colt.timer(); cern.colt.timer emptyloop = new cern.colt.timer(); cern.colt.timer emptyloop2 = new cern.colt.timer(); emptyloop.start(); int dummy = 0; for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { dummy++; } } } emptyloop.stop(); system.out.println(dummy); // !!! so that the jitter can't optimize away the whole loop emptyloop2.start(); dummy = 3; int dummy2 = 0; for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { dummy2 += dummy; } } } emptyloop2.stop(); system.out.println(dummy2); // !!! so that the jitter can't optimize away the whole loop long before = runtime.getruntime().freememory(); long size = (((long)rows)columns)runs; int[][] matrix = new int[rows][columns]; system.out.println("\nnow filling..."); for (int i=0; i<runs; i++) { timer1.start(); int value = 0; for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { matrix[row][column] = value++; } } timer1.stop(); } timer1.display(); timer1.minus(emptyloop).display(); system.out.println(size / timer1.minus(emptyloop).seconds() +" elements / sec"); runtime.getruntime().gc(); // invite gc try { thread.currentthread().sleep(1000); } catch (interruptedexception exc) {}; long after = runtime.getruntime().freememory(); system.out.println("kb needed="+(before-after) / 1024); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println("\nnow reading..."); timer2.start(); int element=0; for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { element += matrix[row][column]; } } } timer2.stop().display(); timer2.minus(emptyloop2).display(); system.out.println(size / timer2.minus(emptyloop2).seconds() +" elements / sec"); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println(element); // !!! so that the jitter can't optimize away the whole loop system.out.println("\nnow removing..."); before = runtime.getruntime().freememory(); for (int i=0; i<runs; i++) { timer3.start(); for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { matrix[row][column] = 0; } } timer3.stop(); } timer3.display(); timer3.minus(emptyloop).display(); system.out.println(size / timer3.minus(emptyloop).seconds() +" elements / sec"); runtime.getruntime().gc(); // invite gc try { thread.currentthread().sleep(1000); } catch (interruptedexception exc) {}; after = runtime.getruntime().freememory(); system.out.println("kb needed="+(before-after)/1024); system.out.println("kb free="+(after/1024)); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println("bye bye."); runs a bench on matrices holding int elements. // certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. // this involves primarly read-loops cern.colt.timer timer1 = new cern.colt.timer(); cern.colt.timer timer2 = new cern.colt.timer(); cern.colt.timer timer3 = new cern.colt.timer(); cern.colt.timer emptyloop = new cern.colt.timer(); cern.colt.timer emptyloop2 = new cern.colt.timer(); emptyloop.start(); int dummy = 0; for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { dummy++; } } } emptyloop.stop(); system.out.println(dummy); // !!! so that the jitter can't optimize away the whole loop int[][] matrix = new int[rows][columns]; emptyloop2.start(); dummy = 3; int dummy2 = 7; system.out.println(dummy2); // !!! so that the jitter can't optimize away the whole loop for (int i=0; i<runs; i++) { for (int column=0; column < columns; column++) { for (int row=0; row < rows; row++) { dummy2 += dummy; //matrix[row][column]; } } } emptyloop2.stop(); system.out.println(dummy2); // !!! so that the jitter can't optimize away the whole loop long before = runtime.getruntime().freememory(); long size = (((long)rows)columns)runs; system.out.println("\nnow filling..."); for (int i=0; i<runs; i++) { timer1.start(); int value = 0; for (int row=0; row < rows; row++) { int[] r = matrix[row]; for (int column=0; column < columns; column++) { r[column] = value++; //matrix[row][column] = value++; } } timer1.stop(); } timer1.display(); timer1.minus(emptyloop).display(); system.out.println(size / timer1.minus(emptyloop).seconds() +" elements / sec"); runtime.getruntime().gc(); // invite gc try { thread.currentthread().sleep(1000); } catch (interruptedexception exc) {}; long after = runtime.getruntime().freememory(); system.out.println("kb needed="+(before-after) / 1024); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println("\nnow reading..."); timer2.start(); int element=0; for (int i=0; i<runs; i++) { for (int row=0; row < rows; row++) { int[] r = matrix[row]; for (int column=0; column < columns; column++) { element += r[column]; //element += matrix[row][column]; } } } timer2.stop().display(); timer2.minus(emptyloop2).display(); system.out.println(size / timer2.minus(emptyloop2).seconds() +" elements / sec"); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println(element); // !!! so that the jitter can't optimize away the whole loop system.out.println("\nnow removing..."); before = runtime.getruntime().freememory(); for (int i=0; i<runs; i++) { timer3.start(); for (int row=0; row < rows; row++) { int[] r = matrix[row]; for (int column=0; column < columns; column++) { r[column] = 0; //matrix[row][column] = 0; } } timer3.stop(); } timer3.display(); timer3.minus(emptyloop).display(); system.out.println(size / timer3.minus(emptyloop).seconds() +" elements / sec"); runtime.getruntime().gc(); // invite gc try { thread.currentthread().sleep(1000); } catch (interruptedexception exc) {}; after = runtime.getruntime().freememory(); system.out.println("kb needed="+(before-after)/1024); system.out.println("kb free="+(after/1024)); if (print) { denseintmatrix2d m = new denseintmatrix2d(rows,columns); m.assign(matrix); system.out.println(m); } system.out.println("bye bye."); benchmarks various methods of this class. certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop else if (kind.equals("densearray")) matrix = new doublearraymatrix2d(rows,columns); if (kind.equals("sparse")) ((sparsedoublematrix2d)matrix).elements.hashcollisions = 0; invite gc if (kind.equals("sparse")) ((sparsedoublematrix2d)matrix).elements.hashcollisions = 0; if (kind.equals("sparse")) system.out.println("hashcollisions="+((sparsedoublematrix2d)matrix).elements.hashcollisions); !!! so that the jitter can't optimize away the whole loop if (kind.equals("sparse")) system.out.println("hashcollisions="+((sparsedoublematrix2d)view).elements.hashcollisions); !!! so that the jitter can't optimize away the whole loop if (kind.equals("sparse")) ((sparsedoublematrix2d)matrix).elements.hashcollisions = 0; initializing invite gc if (kind.equals("sparse")) system.out.println("hashcollisions"+((sparsedoublematrix2d)matrix).elements.hashcollisions); certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops else if (kind.equals("densearray")) matrix = new doublearraymatrix2d(rows,columns); if (kind.equals("sparse")) ((sparsedoublematrix2d)matrix).elements.hashcollisions = 0; if (kind.equals("sparse")) ((sparsedoublematrix2d)matrix).elements.hashcollisions = 0; certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop invite gc !!! so that the jitter can't optimize away the whole loop initializing invite gc certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop matrix[row][column] = value++; invite gc element += matrix[row][column]; !!! so that the jitter can't optimize away the whole loop matrix[row][column] = 0; invite gc certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop else if (kind.equals("densearray")) matrix = new doublearraymatrix2d(rows,columns); invite gc !!! so that the jitter can't optimize away the whole loop initializing invite gc certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop invite gc !!! so that the jitter can't optimize away the whole loop invite gc certain loops need to be constructed so that the jitter can't optimize them away and we get fantastic numbers. this involves primarly read-loops !!! so that the jitter can't optimize away the whole loop !!! so that the jitter can't optimize away the whole loop matrix[row][column]; !!! so that the jitter can't optimize away the whole loop matrix[row][column] = value++; invite gc element += matrix[row][column]; !!! so that the jitter can't optimize away the whole loop matrix[row][column] = 0; invite gc int size = integer.parseint(args[3]); boolean issparse = args[4].equals("sparse");"
cern.colt.matrix.impl.DelegateDoubleMatrix1D "1-d matrix holding double elements; either a view wrapping another 2-d matrix and therefore delegating calls to it. the elements of the matrix. the row this view is bound to. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell."
cern.colt.matrix.impl.DenseDoubleMatrix1D "dense 1-d matrix (aka vector) holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8size(). thus, a 1000000 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  the elements of this matrix. constructs a matrix with a copy of the given values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix with a given number of cells. all entries are initially 0. the number of cells the matrix shall have. @throws illegalargumentexception if size. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). @throws illegalargumentexception if size. sets all cells to the state specified by values. values is required to have the same number of cells as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != size(). sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[i] = function(x[i]). (iterates downwards from [size()-1] to [0]).  example:  // change each cell to its sine matrix = 0.5 1.5 2.5 3.5 matrix.assign(cern.jet.math.functions.sin); --> matrix == 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same size. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if size() != other.size(). assigns the result of a function to each cell; x[i] = function(x[i],y[i]). (iterates downwards from [size()-1] to [0]).  example:  // assign x[i] = x[i]y[i] m1 = 0 1 2 3; m2 = 0 2 4 6; m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 1 16 729 // for non-standard functions there is no shortcut: m1.assign(m2, &nbsp;&nbsp;&nbsp;new doubledoublefunction() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public double apply(double x, double y) { return math.pow(x,y); } &nbsp;&nbsp;&nbsp;} );  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if size() != y.size(). @see cern.jet.math.functions returns the number of cells having non-zero values, but at most maxcardinality; ignores tolerance. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. swaps each element this[i] with other[i]. @throws illegalargumentexception if size() != other.size(). fills the cell values into the specified 1-dimensional array. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. after this call returns the array values has the form  for (int i=0; i  @throws illegalargumentexception if values.length . construct and returns a new selection view. the offsets of the visible elements. a new view. returns the dot product of two vectors x and y, which is sum(x[i]y[i]). where x == this. operates on cells at indexes from .. min(size(),y.size(),from+length)-1. the second vector. the first index to be considered. the number of cells to be considered. sum of products; zero if from. // unoptimized for (int k = min; --k >= 0;) { sum += elems[i] yelems[j]; i += s; j += ys; } returns the sum of all cells; sum( x[i] ). sum. change each cell to its sine specialization for speed x[i] = multx[i] the general case x[i] = f(x[i]) overriden for performance only quickest should not happen assign x[i] = x[i]y[i] for non-standard functions there is no shortcut: overriden for performance only specialized for speed x[i] = x[i] y[i] x[i] = x[i] / y[i] x[i] = x[i] + 0y[i] x[i] = x[i] + y[i] x[i] = x[i] - y[i] the general case x[i] = x[i] + multy[i] the general case x[i] = f(x[i],y[i]) if (debug) if (index=size) checkindex(index); return elements[index(index)]; manually inlined: overriden for manual inlining only return _offset(_rank(rank)); if (debug) if (index=size) checkindex(index); elements[index(index)] = value; manually inlined: overriden for performance only unoptimized optimized loop unrolling"
cern.colt.matrix.impl.DenseDoubleMatrix2D "dense 2-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array, addressed in row major. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8rows()columns(). thus, a 10001000 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  cells are internally addressed in row-major. applications demanding utmost speed can exploit this fact. setting/getting values in a loop row-by-row is quicker than column-by-column. thus  for (int row=0; row  is quicker than  for (int column=0; column  the elements of this matrix. elements are stored in row major, i.e. index==rowcolumns + column columnof(index)==index%columns rowof(index)==index/columns i.e. {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m} constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. constructs a view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). @throws illegalargumentexception if rows integer.max_value or flip's are illegal. sets all cells to the state specified by values. values is required to have the form values[row][column] and have exactly the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns(). sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[row,col] = function(x[row,col]).  example:  matrix = 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != source.columns() || rows() != source.rows() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 2 x 2 matrix 0 1 2 3 m2 = 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. 8 neighbor stencil transformation. for efficient finite difference operations. applies a function to a moving 3 x 3 window. does nothing if rows() .  b[i,j] = function.apply( &nbsp;&nbsp;&nbsp;a[i-1,j-1], a[i-1,j], a[i-1,j+1], &nbsp;&nbsp;&nbsp;a[i, j-1], a[i, j], a[i, j+1], &nbsp;&nbsp;&nbsp;a[i+1,j-1], a[i+1,j], a[i+1,j+1] &nbsp;&nbsp;&nbsp;) x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x  make sure that cells of this and b do not overlap. in case of overlapping views, behaviour is unspecified.   example:  final double alpha = 0.25; final double beta = 0.75; // 8 neighbors cern.colt.function.double9function f = new cern.colt.function.double9function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa11 + alpha(a00+a01+a02 + a10+a12 + a20+a21+a22); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} }; a.zassign8neighbors(b,f); // 4 neighbors cern.colt.function.double9function g = new cern.colt.function.double9function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a00, double a01, double a02, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a10, double a11, double a12, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a20, double a21, double a22) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa11 + alpha(a01+a10+a12+a21); &nbsp;&nbsp;&nbsp;} c.zassign8neighbors(b,g); // fast, even though it doesn't look like it };  the matrix to hold the results. the function to be applied to the 9 cells. @throws nullpointerexception if function==null. @throws illegalargumentexception if rows() != b.rows() || columns() != b.columns(). // not loop unrolled for (int i=indexa, j=indexy, column=columns; --column >= 0; ) { sum += aelems[i] yelems[j]; i += as; j += ys; } final rcdoublematrix2d transb = new rcdoublematrix2d(b.columns,b.rows); b.foreachnonzero( new cern.colt.function.intintdoublefunction() { public double apply(int i, int j, double value) { transb.setquick(j,i,value); return value; } } ); return transb.zmult(this.viewdice(),c.viewdice()).viewdice(); a is blocked to hide memory latency xxxxxxx b xxxxxxx xxxxxxx a xxx xxxxxxx c xxx xxxxxxx --- ------- xxx xxxxxxx xxx xxxxxxx --- ------- xxx xxxxxxx // not unrolled: for (int k = n; --k >= 0; ) { //s += getquick(i,k) b.getquick(k,j); s += aelems[ka] belems[kb]; kb += rb; ka += ca; } returns the sum of all cells; sum( x[i,j] ). sum. change each cell to its sine specialization for speed x[i] = multx[i] the general case the general case x[i] = f(x[i]) overriden for performance only nothing to do quickest should not happen assign x[row,col] = x[row,col]y[row,col] overriden for performance only specialized for speed x[i] = x[i] y[i] x[i] = x[i] / y[i] x[i] = x[i] + 0y[i] x[i] = x[i] + y[i] x[i] = x[i] - y[i] the general case x[i] = x[i] + multy[i] the general case x[i] = f(x[i],y[i]) if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements[index(row,column)]; manually inlined: return super.index(row,column); manually inlined for speed: if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); elements[index(row,column)] = value; manually inlined: 8 neighbors 4 neighbors fast, even though it doesn't look like it 1. using only 4-5 out of the 9 cells in "function" is not the limiting factor for performance. 2. if the "function" would be hardwired into the innermost loop, a speedup of 1.5-2.0 would be seen but then the multi-purpose interface is gone... nothing to do in each step six cells can be remembered in registers - they don't need to be reread from slow memory a02+=a_cs; a12+=a_cs; a22+=a_cs; in each step 3 instead of 9 cells need to be read from memory. move remembered cells not loop unrolled loop unrolled overriden for performance only exploit quick sparse mult ab = (b' a')' 8 == level 2 cache in bytes if (n+p == 0) return c; int m_optimal = (block_size - np) / (n+p); not unrolled: s += getquick(i,k) b.getquick(k,j); loop unrolled"
cern.colt.matrix.impl.DenseDoubleMatrix3D "dense 3-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array, addressed in (in decreasing order of significance): slice major, row major, column major. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8slices()rows()columns(). thus, a 100100100 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  applications demanding utmost speed can exploit knowledge about the internal addressing. setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice. thus  for (int slice=0; slice  is quicker than  for (int column=0; column  the elements of this matrix. elements are stored in slice major, then row major, then column major, in order of significance, i.e. index==sliceslicestride+ rowrowstride + columncolumnstride i.e. {slice0 row0..m}, {slice1 row0..m}, ..., {slicen row0..m} with each row storead as {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m} constructs a matrix with a copy of the given values. values is required to have the form values[slice][row][column] and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= slice &lt; values.length: values[slice].length != values[slice-1].length. @throws illegalargumentexception if for any 1 &lt;= row &lt; values[0].length: values[slice][row].length != values[slice][row-1].length. constructs a matrix with a given number of slices, rows and columns. all entries are initially 0. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a view with the given parameters. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the position of the first element. the number of elements between two slices, i.e. index(k+1,i,j)-index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j)-index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1)-index(k,i,j). @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. sets all cells to the state specified by values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of slices, rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if slices() != source.slices() || rows() != source.rows() || columns() != source.columns() returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. 27 neighbor stencil transformation. for efficient finite difference operations. applies a function to a moving 3 x 3 x 3 window. does nothing if rows() .  b[k,i,j] = function.apply( &nbsp;&nbsp;&nbsp;a[k-1,i-1,j-1], a[k-1,i-1,j], a[k-1,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k-1,i, j-1], a[k-1,i, j], a[k-1,i, j+1], &nbsp;&nbsp;&nbsp;a[k-1,i+1,j-1], a[k-1,i+1,j], a[k-1,i+1,j+1], &nbsp;&nbsp;&nbsp;a[k ,i-1,j-1], a[k ,i-1,j], a[k ,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k ,i, j-1], a[k ,i, j], a[k ,i, j+1], &nbsp;&nbsp;&nbsp;a[k ,i+1,j-1], a[k ,i+1,j], a[k ,i+1,j+1], &nbsp;&nbsp;&nbsp;a[k+1,i-1,j-1], a[k+1,i-1,j], a[k+1,i-1,j+1], &nbsp;&nbsp;&nbsp;a[k+1,i, j-1], a[k+1,i, j], a[k+1,i, j+1], &nbsp;&nbsp;&nbsp;a[k+1,i+1,j-1], a[k+1,i+1,j], a[k+1,i+1,j+1] &nbsp;&nbsp;&nbsp;) x x x - &nbsp;&nbsp;&nbsp; - x x x &nbsp;&nbsp;&nbsp; - - - - x o x - &nbsp;&nbsp;&nbsp; - x o x &nbsp;&nbsp;&nbsp; - - - - x x x - &nbsp;&nbsp;&nbsp; - x x x ... - x x x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x o x - - - - &nbsp;&nbsp;&nbsp; - - - - &nbsp;&nbsp;&nbsp; - x x x  make sure that cells of this and b do not overlap. in case of overlapping views, behaviour is unspecified.   example:  final double alpha = 0.25; final double beta = 0.75; cern.colt.function.double27function f = new cern.colt.function.double27function() { &nbsp;&nbsp;&nbsp;public final double apply( &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a000, double a001, double a002, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a010, double a011, double a012, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a020, double a021, double a022, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a100, double a101, double a102, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a110, double a111, double a112, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a120, double a121, double a122, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a200, double a201, double a202, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a210, double a211, double a212, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double a220, double a221, double a222) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return betaa111 + alpha(a000 + ... + a222); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} }; a.zassign27neighbors(b,f);  the matrix to hold the results. the function to be applied to the 27 cells. @throws nullpointerexception if function==null. @throws illegalargumentexception if rows() != b.rows() || columns() != b.columns() || slices() != b.slices() . overriden for performance only should not happen quickest if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements[index(slice,row,column)]; manually inlined: return _sliceoffset(_slicerank(slice)) + _rowoffset(_rowrank(row)) + _columnoffset(_columnrank(column)); manually inlined: if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); elements[index(slice,row,column)] = value; manually inlined: overridden for performance only nothing to do in each step 18 cells can be remembered in registers - they don't need to be reread from slow memory in each step 9 instead of 27 cells need to be read from memory. move remembered cells"
cern.colt.matrix.impl.DenseObjectMatrix1D "dense 1-d matrix (aka vector) holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8size(). thus, a 1000000 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  the elements of this matrix. constructs a matrix with a copy of the given values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix with a given number of cells. all entries are initially 0. the number of cells the matrix shall have. @throws illegalargumentexception if size. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). @throws illegalargumentexception if size. sets all cells to the state specified by values. values is required to have the same number of cells as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != size(). assigns the result of a function to each cell; x[i] = function(x[i]). (iterates downwards from [size()-1] to [0]).  example:  // change each cell to its sine matrix = 0.5 1.5 2.5 3.5 matrix.assign(cern.jet.math.functions.sin); --> matrix == 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same size. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if size() != other.size(). assigns the result of a function to each cell; x[i] = function(x[i],y[i]). (iterates downwards from [size()-1] to [0]).  example:  // assign x[i] = x[i]y[i] m1 = 0 1 2 3; m2 = 0 2 4 6; m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 1 16 729 // for non-standard functions there is no shortcut: m1.assign(m2, &nbsp;&nbsp;&nbsp;new objectobjectfunction() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public object apply(object x, object y) { return math.pow(x,y); } &nbsp;&nbsp;&nbsp;} );  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if size() != y.size(). @see cern.jet.math.functions returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. swaps each element this[i] with other[i]. @throws illegalargumentexception if size() != other.size(). fills the cell values into the specified 1-dimensional array. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. after this call returns the array values has the form  for (int i=0; i  @throws illegalargumentexception if values.length . construct and returns a new selection view. the offsets of the visible elements. a new view. change each cell to its sine the general case x[i] = f(x[i]) overriden for performance only quickest should not happen assign x[i] = x[i]y[i] for non-standard functions there is no shortcut: overriden for performance only the general case x[i] = f(x[i],y[i]) if (debug) if (index=size) checkindex(index); return elements[index(index)]; manually inlined: overriden for manual inlining only return _offset(_rank(rank)); if (debug) if (index=size) checkindex(index); elements[index(index)] = value; manually inlined: overriden for performance only"
cern.colt.matrix.impl.DenseObjectMatrix2D "dense 2-d matrix holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array, addressed in row major. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8rows()columns(). thus, a 10001000 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  cells are internally addressed in row-major. applications demanding utmost speed can exploit this fact. setting/getting values in a loop row-by-row is quicker than column-by-column. thus  for (int row=0; row  is quicker than  for (int column=0; column  the elements of this matrix. elements are stored in row major, i.e. index==rowcolumns + column columnof(index)==index%columns rowof(index)==index/columns i.e. {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m} constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. constructs a view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). @throws illegalargumentexception if rows integer.max_value or flip's are illegal. sets all cells to the state specified by values. values is required to have the form values[row][column] and have exactly the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns(). assigns the result of a function to each cell; x[row,col] = function(x[row,col]).  example:  matrix = 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != source.columns() || rows() != source.rows() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 2 x 2 matrix 0 1 2 3 m2 = 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. change each cell to its sine the general case x[i] = f(x[i]) overriden for performance only nothing to do quickest should not happen assign x[row,col] = x[row,col]y[row,col] overriden for performance only the general case x[i] = f(x[i],y[i]) if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements[index(row,column)]; manually inlined: return super.index(row,column); manually inlined for speed: if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); elements[index(row,column)] = value; manually inlined:"
cern.colt.matrix.impl.DenseObjectMatrix3D "dense 3-d matrix holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally holds one single contigous one-dimensional array, addressed in (in decreasing order of significance): slice major, row major, column major. note that this implementation is not synchronized.  memory requirements:  memory [bytes] = 8slices()rows()columns(). thus, a 100100100 matrix uses 8 mb.  time complexity:  o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size,  applications demanding utmost speed can exploit knowledge about the internal addressing. setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice. thus  for (int slice=0; slice  is quicker than  for (int column=0; column  the elements of this matrix. elements are stored in slice major, then row major, then column major, in order of significance, i.e. index==sliceslicestride+ rowrowstride + columncolumnstride i.e. {slice0 row0..m}, {slice1 row0..m}, ..., {slicen row0..m} with each row storead as {row0 column0..m}, {row1 column0..m}, ..., {rown column0..m} constructs a matrix with a copy of the given values. values is required to have the form values[slice][row][column] and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= slice &lt; values.length: values[slice].length != values[slice-1].length. @throws illegalargumentexception if for any 1 &lt;= row &lt; values[0].length: values[slice][row].length != values[slice][row-1].length. constructs a matrix with a given number of slices, rows and columns. all entries are initially 0. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (object)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a view with the given parameters. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the position of the first element. the number of elements between two slices, i.e. index(k+1,i,j)-index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j)-index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1)-index(k,i,j). @throws illegalargumentexception if (object)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. sets all cells to the state specified by values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of slices, rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if slices() != source.slices() || rows() != source.rows() || columns() != source.columns() returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. overriden for performance only should not happen quickest if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements[index(slice,row,column)]; manually inlined: return _sliceoffset(_slicerank(slice)) + _rowoffset(_rowrank(row)) + _columnoffset(_columnrank(column)); manually inlined: if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); elements[index(slice,row,column)] = value; manually inlined:"
cern.colt.matrix.impl.Former "formats a double into a string (like sprintf in c). formats a double into a string (like sprintf in c). the number to format formatted string @exception illegalargumentexception if bad argument"
cern.colt.matrix.impl.FormerFactory "factory producing implementations of {@link cern.colt.matrix.impl.former} via method create(); implementations of can use existing libraries such as corejava.printfformat or corejava.format or other. serves to isolate the interface of string formatting from the actual implementation. if you want to plug in a different string formatting implementation, simply replace this class with your alternative. constructs and returns a new format instance. the format string following printf conventions. the string has a prefix, a format code and a suffix. the prefix and suffix become part of the formatted output. the format code directs the formatting of the (single) parameter to be formatted. the code has the following structure   a % (required)  a modifier (optional)   +  forces display of + for positive numbers  0  show leading zeroes  -  align left in the field  space  prepend a space in front of positive numbers  #  use "alternate" format. add 0 or 0x for octal or hexadecimal numbers. don't suppress trailing zeroes in general floating point format.   an integer denoting field width (optional)  a period followed by an integer denoting precision (optional)  a format descriptor (required)  f  floating point number in fixed format e, e  floating point number in exponential notation (scientific format). the e format results in an uppercase e for the exponent (1.14130e+003), the e format in a lowercase e. g, g  floating point number in general format (fixed format for small numbers, exponential format for large numbers). trailing zeroes are suppressed. the g format results in an uppercase e for the exponent (if any), the g format in a lowercase e. d, i  integer in decimal x  integer in hexadecimal o  integer in octal s  string c  character   @exception illegalargumentexception if bad format private formatstringbuffer f = (format!=null ? new corejava.formatstringbuffer(format) : null); private corejava.printfformat f = (format!=null ? new corejava.printfformat(format) : null); value != value  double.isnan(value) work around bug in corejava.format.form() for inf, -inf, nan return f.format(value).tostring(); return f.sprintf(value);"
cern.colt.matrix.impl.NormInfinityTest ""
cern.colt.matrix.impl.QRTest "constructor for qrtest. // for jama matrix amatrix,bmatrix,cmatrix; amatrix = new matrix(8,2); bmatrix = new matrix(8,1); amatrix.set(0,0,1); amatrix.set(1,0,1); amatrix.set(2,0,1); amatrix.set(3,0,1); amatrix.set(4,0,1); amatrix.set(5,0,1); amatrix.set(6,0,1); amatrix.set(7,0,1); amatrix.set(0,1,80); amatrix.set(1,1,220); amatrix.set(2,1,140); amatrix.set(3,1,120); amatrix.set(4,1,180); amatrix.set(5,1,100); amatrix.set(6,1,200); amatrix.set(7,1,160); bmatrix.set(0,0,0.6); bmatrix.set(1,0,6.70); bmatrix.set(2,0,5.30); bmatrix.set(3,0,4.00); bmatrix.set(4,0,6.55); bmatrix.set(5,0,2.15); bmatrix.set(6,0,6.60); bmatrix.set(7,0,5.75); cmatrix = amatrix.solve(bmatrix); amatrix.print(8,5); bmatrix.print(8,5); cmatrix.print(8,5); import jama.matrix.; import jama.; for colt for jama"
cern.colt.matrix.impl.RCDoubleMatrix2D "sparse row-compressed 2-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  internally uses the standard sparse row-compressed format, with two important differences that broaden the applicability of this storage format:  we use a {@link cern.colt.list.intarraylist} and {@link cern.colt.list.doublearraylist} to hold the column indexes and nonzero values, respectively. this improves set(...) performance, because the standard way of using non-resizable primitive arrays causes excessive memory allocation, garbage collection and array copying. the small downside of this is that set(...,0) does not free memory (the capacity of an arraylist does not shrink upon element removal). column indexes are kept sorted within a row. this both improves get and set performance on rows with many non-zeros, because we can use a binary search. (experiments show that this hurts   note that this implementation is not synchronized.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. their memory is not automatically reclaimed (because of the lists vs. arrays). reclamation can be triggered via {@link #trimtosize()}.   memory [bytes] = 4rows + 12 nonzeros. where nonzeros = cardinality() is the number of non-zero cells. thus, a 1000 x 1000 matrix with 1000000 non-zero cells consumes 11.5 mb. the same 1000 x 1000 matrix with 1000 non-zero cells consumes 15 kb.  time complexity:  getting a cell value takes time o(log nzr) where nzr is the number of non-zeros of the touched row. this is usually quick, because typically there are only few nonzeros per row. so, in practice, get has expected constant time. setting a cell value takes  worst-case time o(nz) where nzr is the total number of non-zeros in the matrix. this can be extremely slow, but if you traverse coordinates properly (i.e. upwards), each write is done much quicker:    // rather quick matrix.assign(0); for (int row=0; row = 0; ) { &nbsp;&nbsp;&nbsp;for (int column=columns; --column >= 0; ) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (somecondition) matrix.setquick(row,column,somevalue); &nbsp;&nbsp;&nbsp;} }    if for whatever reasons you can't iterate properly, consider to create an empty dense matrix, store your non-zeros in it, then call sparse.assign(dense). under the circumstances, this is still rather quick.  fast iteration over non-zeros can be done via {@link #foreachnonzero}, which supplies your function with row, column and value of each nonzero. although the internally implemented version is a bit more sophisticated, here is how a quite efficient the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). foreachnonzero( new cern.colt.function.intintdoublefunction() { public double apply(int i, int j, double value) { return function.apply(value); } } ); replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != source.columns() || rows() != source.rows() indexes.clear(); values.clear(); int nonzeros=0; for (int row=0; rowthis otherwise. override this method in wrappers. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. foreachnonzero( new cern.colt.function.intintdoublefunction() { public double apply(int i, int j, double value) { zelements[zi + zstridei] += value yelements[yi + ystridej]; //z.setquick(row,z.getquick(row) + value y.getquick(column)); //system.out.println("["+i+","+j+"]-->"+value); return value; } } ); rather quick poor linear algebraic y = a x elementwise a = a + alphab protected int n; we can hold rowscolumns>integer.max_value cells ! overriden for performance only x[i] = multx[i] the funny definition of isnan(). this should better not happen. nothing to do overriden for performance only return super.assign(source); even quicker x[i] = x[i] + alphay[i] nothing to do x[i] = x[i] y[i] x[i] = x[i] / y[i] found z.setquick(row,z.getquick(row) + value y.getquick(column)); system.out.println("["+i+","+j+"]-->"+value); cache views"
cern.colt.matrix.impl.RCMDoubleMatrix2D "sparse row-compressed-modified 2-d matrix holding double elements. the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. linear algebraic matrix-vector multiplication; z = a y. z[i] = alphasum(a[i,j] y[j]) + betaz[i], i=0..a.rows()-1, j=0..y.size()-1. where a == this. the source vector. the vector where results are to be stored. @throws illegalargumentexception if a.columns() != y.size() || a.rows() > z.size()). overriden for performance only found not found"
cern.colt.matrix.impl.SelectedDenseDoubleMatrix1D "selection view on dense 1-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of visible indexes of this matrix. the offset. constructs a matrix view with the given parameters. the cells. indexes the indexes of the cells that shall be visible. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). the offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. sets up a matrix with a given number of cells. the number of cells the matrix shall have. construct and returns a new selection view. the offsets of the visible elements. a new view. if (debug) if (index=size) checkindex(index); return elements[index(index)]; manually inlined: return this.offset + super.index(rank); manually inlined: if (debug) if (index=size) checkindex(index); elements[index(index)] = value; manually inlined:"
cern.colt.matrix.impl.SelectedDenseDoubleMatrix2D "selection view on dense 2-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset constructs a matrix view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of rows and columns. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)columnsrows > integer.max_value. self modifying version of viewdice(). constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   column to fix. new slice view. @throws illegalargumentexception if column = columns(). @see #viewrow(int) constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. be sure parameters are valid, we do not check... if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements[index(row,column)]; manually inlined: return this.offset + super.index(row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); elements[index(row,column)] = value; manually inlined: swap flips stay unaffected"
cern.colt.matrix.impl.SelectedDenseDoubleMatrix3D "selection view on dense 3-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. sliceoffsets the slice offsets of the cells that shall be visible. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of slices and rows. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)rowsslices > integer.max_value. self modifying version of viewdice(). @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) be sure parameters are valid, we do not check... if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements[index(slice,row,column)]; manually inlined: return this.offset + super.index(slice,row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); elements[index(slice,row,column)] = value; manually inlined: swap offsets"
cern.colt.matrix.impl.SelectedDenseObjectMatrix1D "selection view on dense 1-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of visible indexes of this matrix. the offset. constructs a matrix view with the given parameters. the cells. indexes the indexes of the cells that shall be visible. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). the offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. sets up a matrix with a given number of cells. the number of cells the matrix shall have. construct and returns a new selection view. the offsets of the visible elements. a new view. if (debug) if (index=size) checkindex(index); return elements[index(index)]; manually inlined: return this.offset + super.index(rank); manually inlined: if (debug) if (index=size) checkindex(index); elements[index(index)] = value; manually inlined:"
cern.colt.matrix.impl.SelectedDenseObjectMatrix2D "selection view on dense 2-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset constructs a matrix view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of rows and columns. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (object)columnsrows > integer.max_value. self modifying version of viewdice(). constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   column to fix. new slice view. @throws illegalargumentexception if column = columns(). @see #viewrow(int) constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. be sure parameters are valid, we do not check... if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements[index(row,column)]; manually inlined: return this.offset + super.index(row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); elements[index(row,column)] = value; manually inlined: swap flips stay unaffected"
cern.colt.matrix.impl.SelectedDenseObjectMatrix3D "selection view on dense 3-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. sliceoffsets the slice offsets of the cells that shall be visible. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of slices and rows. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (object)rowsslices > integer.max_value. self modifying version of viewdice(). @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) be sure parameters are valid, we do not check... if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements[index(slice,row,column)]; manually inlined: return this.offset + super.index(slice,row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); elements[index(slice,row,column)] = value; manually inlined: swap offsets"
cern.colt.matrix.impl.SelectedSparseDoubleMatrix1D "selection view on sparse 1-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of the matrix. the offsets of visible indexes of this matrix. the offset. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). the offsets of the cells that shall be visible. constructs a matrix view with the given parameters. the cells. indexes the indexes of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. sets up a matrix with a given number of cells. the number of cells the matrix shall have. construct and returns a new selection view. the offsets of the visible elements. a new view. if (debug) if (index=size) checkindex(index); return elements.get(index(index)); manually inlined: return this.offset + super.index(rank); manually inlined: if (debug) if (index=size) checkindex(index); int i = index(index); manually inlined:"
cern.colt.matrix.impl.SelectedSparseDoubleMatrix2D "selection view on sparse 2-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of the matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset constructs a matrix view with the given parameters. the cells. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of rows and columns. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)columnsrows > integer.max_value. self modifying version of viewdice(). constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   column to fix. new slice view. @throws illegalargumentexception if column = columns(). @see #viewrow(int) constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. be sure parameters are valid, we do not check... if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements.get(index(row,column)); manually inlined: return this.offset + super.index(row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); int index = index(row,column); manually inlined: swap flips stay unaffected"
cern.colt.matrix.impl.SelectedSparseDoubleMatrix3D "selection view on sparse 3-d matrices holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. sliceoffsets the slice offsets of the cells that shall be visible. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of slices and rows. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)rowsslices > integer.max_value. self modifying version of viewdice(). @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) be sure parameters are valid, we do not check... if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements.get(index(slice,row,column)); manually inlined: return this.offset + super.index(slice,row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); int index = index(slice,row,column); manually inlined: swap offsets"
cern.colt.matrix.impl.SelectedSparseObjectMatrix1D "selection view on sparse 1-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of the matrix. the offsets of visible indexes of this matrix. the offset. constructs a matrix view with the given parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). the offsets of the cells that shall be visible. constructs a matrix view with the given parameters. the cells. indexes the indexes of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. sets up a matrix with a given number of cells. the number of cells the matrix shall have. construct and returns a new selection view. the offsets of the visible elements. a new view. if (debug) if (index=size) checkindex(index); return elements.get(index(index)); manually inlined: return this.offset + super.index(rank); manually inlined: if (debug) if (index=size) checkindex(index); int i = index(index); manually inlined:"
cern.colt.matrix.impl.SelectedSparseObjectMatrix2D "selection view on sparse 2-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of the matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset constructs a matrix view with the given parameters. the cells. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. offset returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of rows and columns. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (object)columnsrows > integer.max_value. self modifying version of viewdice(). constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   column to fix. new slice view. @throws illegalargumentexception if column = columns(). @see #viewrow(int) constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. be sure parameters are valid, we do not check... if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return elements.get(index(row,column)); manually inlined: return this.offset + super.index(row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); int index = index(row,column); manually inlined: swap flips stay unaffected"
cern.colt.matrix.impl.SelectedSparseObjectMatrix3D "selection view on sparse 3-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  objects of this class are typically constructed via viewindexes methods on some source matrix. the interface introduced in abstract super classes defines everything a the elements of this matrix. the offsets of the visible cells of this matrix. the offset. constructs a matrix view with the given parameters. the cells. sliceoffsets the slice offsets of the cells that shall be visible. rowoffsets the row offsets of the cells that shall be visible. columnoffsets the column offsets of the cells that shall be visible. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the position of the given absolute rank within the (virtual or non-virtual) internal 1-dimensional array. default implementation. override, if necessary. rank the absolute rank of the element. position. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if other != null and at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. sets up a matrix with a given number of slices and rows. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (object)rowsslices > integer.max_value. self modifying version of viewdice(). @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) be sure parameters are valid, we do not check... if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements.get(index(slice,row,column)); manually inlined: return this.offset + super.index(slice,row,column); manually inlined: this method is never called since viewrow() and viewcolumn are overridden properly. if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); int index = index(slice,row,column); manually inlined: swap offsets"
cern.colt.matrix.impl.SparseDoubleMatrix1D "sparse hashed 1-d matrix (aka vector) holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintdoublehashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 1000000 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 1000000 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link densedoublematrix1d}. however, constant factors are considerably larger. the elements of the matrix. constructs a matrix with a copy of the given values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix with a given number of cells. all entries are initially 0. the number of cells the matrix shall have. @throws illegalargumentexception if size. constructs a matrix with a given number of parameters. all entries are initially 0. for details related to memory usage see {@link cern.colt.map.openintdoublehashmap}. the number of cells the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if size. constructs a matrix view with a given number of parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). @throws illegalargumentexception if size. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. a new view. overriden for performance only if (debug) if (index=size) checkindex(index); return this.elements.get(index(index)); manually inlined: overriden for manual inlining only return _offset(_rank(rank)); if (debug) if (index=size) checkindex(index); int i = index(index); manually inlined:"
cern.colt.matrix.impl.SparseDoubleMatrix2D "sparse hashed 2-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintdoublehashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 1000 x 1000 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 1000 x 1000 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link densedoublematrix2d}. however, constant factors are considerably larger.  cells are internally addressed in row-major. performance sensitive applications can exploit this fact. setting values in a loop row-by-row is quicker than column-by-column, because fewer hash collisions occur. thus  for (int row=0; row  is quicker than  for (int column=0; column  @see cern.colt.map @see cern.colt.map.openintdoublehashmap the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns and default memory usage. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. constructs a matrix with a given number of rows and columns using memory as specified. all entries are initially 0. for details related to memory usage see {@link cern.colt.map.openintdoublehashmap}. the number of rows the matrix shall have. the number of columns the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if rows integer.max_value. constructs a view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). @throws illegalargumentexception if rows integer.max_value or flip's are illegal. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). assigns the result of a function to each cell; x[row,col] = function(x[row,col]).  example:  matrix = 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != source.columns() || rows() != source.rows() returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. foreachnonzero( new cern.colt.function.intintdoublefunction() { public double apply(int i, int j, double value) { if (transposea) { int tmp=i; i=j; j=tmp; } zelements[zi + zstridei] += value yelements[yi + ystridej]; //z.setquick(row,z.getquick(row) + value y.getquick(column)); //system.out.println("["+i+","+j+"]-->"+value); return value; } } ); overriden for performance only change each cell to its sine x[i] = multx[i] overriden for performance only nothing to do quickest x[i] = x[i] + alphay[i] nothing to do x[i] = x[i] y[i] x[i] = x[i] / y[i] if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return this.elements.get(index(row,column)); manually inlined: return super.index(row,column); manually inlined for speed: if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); int index = index(row,column); manually inlined: if (value == 0 || math.abs(value) "+value); z.setquick(row,z.getquick(row) + value y.getquick(column)); system.out.println("["+i+","+j+"]-->"+value); cache views"
cern.colt.matrix.impl.SparseDoubleMatrix3D "sparse hashed 3-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintdoublehashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 100 x 100 x 100 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 100 x 100 x 100 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link densedoublematrix2d}. however, constant factors are considerably larger.  cells are internally addressed in (in decreasing order of significance): slice major, row major, column major. applications demanding utmost speed can exploit this fact. setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice. thus  for (int slice=0; slice  is quicker than  for (int column=0; column  @see cern.colt.map @see cern.colt.map.openintdoublehashmap the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[slice][row][column] and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= slice &lt; values.length: values[slice].length != values[slice-1].length. @throws illegalargumentexception if for any 1 &lt;= row &lt; values[0].length: values[slice][row].length != values[slice][row-1].length. constructs a matrix with a given number of slices, rows and columns and default memory usage. all entries are initially 0. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a matrix with a given number of slices, rows and columns using memory as specified. all entries are initially 0. for details related to memory usage see {@link cern.colt.map.openintdoublehashmap}. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if (double)columnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a view with the given parameters. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the position of the first element. the number of elements between two slices, i.e. index(k+1,i,j)-index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j)-index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1)-index(k,i,j). @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix3d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix3d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix3d the new matrix must also be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. overriden for performance only if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements.get(index(slice,row,column)); manually inlined: return _sliceoffset(_slicerank(slice)) + _rowoffset(_rowrank(row)) + _columnoffset(_columnrank(column)); manually inlined: if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); int index = index(slice,row,column); manually inlined:"
cern.colt.matrix.impl.SparseObjectMatrix1D "sparse hashed 1-d matrix (aka vector) holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintobjecthashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 1000000 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 1000000 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link denseobjectmatrix1d}. however, constant factors are considerably larger. the elements of the matrix. constructs a matrix with a copy of the given values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix with a given number of cells. all entries are initially null. the number of cells the matrix shall have. @throws illegalargumentexception if size. constructs a matrix with a given number of parameters. all entries are initially null. for details related to memory usage see {@link cern.colt.map.openintobjecthashmap}. the number of cells the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if size. constructs a matrix view with a given number of parameters. the number of cells the matrix shall have. the cells. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). @throws illegalargumentexception if size. returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns the position of the element with the given relative rank within the (virtual or non-virtual) internal 1-dimensional array. you may want to override this method for performance. rank the rank of the element. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. a new view. if (debug) if (index=size) checkindex(index); return this.elements.get(index(index)); manually inlined: overriden for manual inlining only return _offset(_rank(rank)); if (debug) if (index=size) checkindex(index); int i = index(index); manually inlined:"
cern.colt.matrix.impl.SparseObjectMatrix2D "sparse hashed 2-d matrix holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintobjecthashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 1000 x 1000 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 1000 x 1000 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link denseobjectmatrix2d}. however, constant factors are considerably larger.  cells are internally addressed in row-major. performance sensitive applications can exploit this fact. setting values in a loop row-by-row is quicker than column-by-column, because fewer hash collisions occur. thus  for (int row=0; row  is quicker than  for (int column=0; column  @see cern.colt.map @see cern.colt.map.openintobjecthashmap the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns and default memory usage. all entries are initially null. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. constructs a matrix with a given number of rows and columns using memory as specified. all entries are initially null. for details related to memory usage see {@link cern.colt.map.openintobjecthashmap}. the number of rows the matrix shall have. the number of columns the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if rows integer.max_value. constructs a view with the given parameters. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). @throws illegalargumentexception if rows integer.max_value or flip's are illegal. returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share common cells. more formally, returns true if at least one of the following conditions is met  the receiver is a view of the other matrix the other matrix is a view of the receiver this == other  returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. row the index of the row-coordinate. column the index of the column-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); return this.elements.get(index(row,column)); manually inlined: return super.index(row,column); manually inlined for speed: if (debug) if (column=columns || row=rows) throw new indexoutofboundsexception("row:"+row+", column:"+column); int index = index(row,column); manually inlined:"
cern.colt.matrix.impl.SparseObjectMatrix3D "sparse hashed 3-d matrix holding object elements. first see the package summary and javadoc tree view to get the broad picture.  implementation:  note that this implementation is not synchronized. uses a {@link cern.colt.map.openintobjecthashmap}, which is a compact and performant hashing technique.  memory requirements:  cells that  are never set to non-zero values do not use any memory. switch from zero to non-zero state do use memory. switch back from non-zero to zero state also do use memory. however, their memory is automatically reclaimed from time to time. it can also manually be reclaimed by calling {@link #trimtosize()}.   worst case: memory [bytes] = (1/minloadfactor) nonzeros 13. best case: memory [bytes] = (1/maxloadfactor) nonzeros 13. where nonzeros = cardinality() is the number of non-zero cells. thus, a 100 x 100 x 100 matrix with minloadfactor=0.25 and maxloadfactor=0.5 and 1000000 non-zero cells consumes between 25 mb and 50 mb. the same 100 x 100 x 100 matrix with 1000 non-zero cells consumes between 25 and 50 kb.  time complexity:  this class offers expected time complexity o(1) (i.e. constant time) for the basic operations get, getquick, set, setquick and size assuming the hash function disperses the elements properly among the buckets. otherwise, pathological cases, although highly improbable, can occur, degrading performance to o(n) in the worst case. as such this sparse class is expected to have no worse time complexity than its dense counterpart {@link denseobjectmatrix2d}. however, constant factors are considerably larger.  cells are internally addressed in (in decreasing order of significance): slice major, row major, column major. applications demanding utmost speed can exploit this fact. setting/getting values in a loop slice-by-slice, row-by-row, column-by-column is quicker than, for example, column-by-column, row-by-row, slice-by-slice. thus  for (int slice=0; slice  is quicker than  for (int column=0; column  @see cern.colt.map @see cern.colt.map.openintobjecthashmap the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[slice][row][column] and have exactly the same number of rows in in every slice and exactly the same number of columns in in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= slice &lt; values.length: values[slice].length != values[slice-1].length. @throws illegalargumentexception if for any 1 &lt;= row &lt; values[0].length: values[slice][row].length != values[slice][row-1].length. constructs a matrix with a given number of slices, rows and columns and default memory usage. all entries are initially null. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a matrix with a given number of slices, rows and columns using memory as specified. all entries are initially null. for details related to memory usage see {@link cern.colt.map.openintobjecthashmap}. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the initial capacity of the hash map. if not known, set initialcapacity=0 or small. the minimum load factor of the hash map. the maximum load factor of the hash map. @throws illegalargumentexception if initialcapacity = 1.0) || (maxloadfactor = 1.0) || (minloadfactor >= maxloadfactor). @throws illegalargumentexception if (double)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. constructs a view with the given parameters. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. the cells. the position of the first element. the position of the first element. the position of the first element. the number of elements between two slices, i.e. index(k+1,i,j)-index(k,i,j). the number of elements between two rows, i.e. index(k,i+1,j)-index(k,i,j). the number of elements between two columns, i.e. index(k,i,j+1)-index(k,i,j). @throws illegalargumentexception if (object)slicescolumnsrows > integer.max_value. @throws illegalargumentexception if slices. returns the number of cells having non-zero values. ensures that the receiver can hold at least the specified number of non-zero cells without needing to allocate new internal memory. if necessary, allocates new internal memory and increases the capacity of the receiver.  this method never need be called; it is for performance tuning only. calling this method before tt>set()ing a large number of non-zero values boosts performance, because the receiver will grow only once instead of potentially many times and hash collisions get less probable. minnonzeros the desired minimum number of non-zero cells. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the third-coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. releases any superfluous memory construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); return elements.get(index(slice,row,column)); manually inlined: return _sliceoffset(_slicerank(slice)) + _rowoffset(_rowrank(row)) + _columnoffset(_columnrank(column)); manually inlined: if (debug) if (slice=slices || row=rows || column=columns) throw new indexoutofboundsexception("slice:"+slice+", row:"+row+", column:"+column); int index = index(slice,row,column); manually inlined:"
cern.colt.matrix.impl.TestMatrix2D "quick and dirty tests. makes this class non instantiable, but still let's others inherit from it.         timer.reset().start(); for (int run=0; run=0; ) { // for (int j=size; --j>=0; ) { for (int i=0; i=0; ) { for (int j=size; --j>=0; ) { //for (int i=0; i=0; ) { for (int j=size; --j>=0; ) { //for (int i=0; i description: a program to analyse aeroelestic evects in transonic wings copyright: copyright (c) 1998 company: piersol engineering inc. final int dof = 200; final cern.jet.random.engine.mersennetwister random = new cern.jet.random.engine.mersennetwister(); final algebra algebra = new algebra(); system.out.println("\n\n\nstarting..."); double[][] k = randommatrix(dof, random); doublematrix2d kd = new densedoublematrix2d(k); jama.matrix km = new jama.matrix(k); doublematrix2d coltl = new ludecomposition(kd).getl(); doublematrix2d coltu = new ludecomposition(kd).getu(); jama.matrix jamal = new jama.ludecomposition(km).getl(); jama.matrix jamau = new jama.ludecomposition(km).getu(); system.out.println(coltl.equals(kd.like().assign(jamal.getarraycopy()))); system.out.println(coltl.aggregate(f.plus,f.abs)); double s = 0; double[] temp2 = jamal.getcolumnpackedcopy(); for (int i = 0, n = temp2.length; i  description: a program to analyse aeroelestic evects in transonic wings copyright: copyright (c) 1998 company: piersol engineering inc.  doublematrix2d copypart = master.copypart(2,1,2,3); copypart.assign(3); // modify an independent copy copypart.set(0,0,4); system.out.println("\n"+copypart); // has changed system.out.println("\n"+master); // master has not changed doublematrix2d view1 = master.viewpart(0,3,4,2); // [0,3] .. [3,4] doublematrix2d view2 = view1.viewpart(0,0,4,1); // a view from a view system.out.println("\n"+view1); system.out.println("\n"+view2);  int rows = 4; int columns = 5; // make a 45 matrix doublematrix2d master = new densedoublematrix2d(rows,columns); system.out.println(master); master.assign(1); // set all cells to 1 doublematrix2d view = master.viewpart(2,0,2,3); view.assign(0); for (int i=0; i -1) m[i][j] = random.nextdouble(); } } // create the matrix object doublematrix2d a = new densedoublematrix2d(numpnt, 5); doublematrix2d b = new densedoublematrix2d(numpnt, 1); //fillout the matrix for (int i = 0; i  14 sum( x[i]x[i] ) --> 14 sum( x[i]x[i]x[i] ) --> 36 sum( x[i] ) --> 6 min( x[i] ) --> 0 max( sqrt(x[i]) / 2 ) --> 0.8660254037844386 number of all cells with 0  3 number of all cells with 0.8  1 product( x[i] ) --> 0 product( x[i] ) of all x[i] > limit --> 6 sum( (x[i]+y[i])^2 ) --> 56 othermatrix1d.zmult(3); sum(math.pi math.log(othermatrix1d[i] / matrix[i])) or, perhaps less error prone and more readable: sum( x[slice,row,col]x[slice,row,col] ) --> 140 sum( (x[i]+y[i])^2 ) --> 560 system.out.println(a); system.out.println(b); system.out.println(basic.product(a,b)); doublematrix2d a = factory2d.make(values); doublematrix2d a = factory2d.makeidentity(size,size); doublematrix2d a = factory2d.makeascending(size,size).assign(new cern.jet.random.engine.mersennetwister()); system.out.println("a="+a); system.out.println("inverse(a)="+inv); system.out.println("formatted inverse(a)="+ new jama.matrix(inv.toarray())); doublematrix2d a = factory2d.make(values); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(b.tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(c.tostring())); system.out.println("\n"+cern.colt.matrixpattern.converting.tohtml(factory2d.diagonal(a,b,c).tostring())); doublematrix2d a = factory2d.make(values); a01 = empty; a11 = factory2d.ascending(s,s).assign(f.plus(a10.getquick(s-1,s-1))); a12 = factory2d.ascending(s,s).assign(f.plus(a11.getquick(s-1,s-1))); a21 = factory2d.ascending(s,s).assign(f.plus(a20.getquick(s-1,s-1))); a22 = factory2d.ascending(s,s).assign(f.plus(a21.getquick(s-1,s-1))); b.assign(f.plus(a.zsum())); c.assign(f.plus(b.zsum())); system.out.println("\n"+factory2d.make33(a00,a01,a02,a10,a11,a12,a20,a21,a22)); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); doublematrix2d a = factory2d.make(values); a01 = empty; a11 = factory2d.ascending(s,s).assign(f.plus(a10.getquick(s-1,s-1))); a12 = factory2d.ascending(s,s).assign(f.plus(a11.getquick(s-1,s-1))); a21 = factory2d.ascending(s,s).assign(f.plus(a20.getquick(s-1,s-1))); a22 = factory2d.ascending(s,s).assign(f.plus(a21.getquick(s-1,s-1))); b.assign(f.plus(a.zsum())); c.assign(f.plus(b.zsum())); system.out.println("\n"+factory2d.make33(a00,a01,a02,a10,a11,a12,a20,a21,a22)); using a map system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); exact eigenvalues from westlake (1968), p.150 (ei'vectors given too): system.out.println("\n\n"+linearalgebra.toverbosestring(a)); system.out.println(new ludecomposition(a)); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); system.out.println("\n\n"+linearalgebra.toverbosestring(a)); system.out.println(new ludecomposition(a)); system.out.println("\n\nbandwidth="+k+" "+cern.colt.matrixpattern.converting.tohtml(a.tostring())); a.assign(random); a.assign(f.rint); // round i = factory2d.identity(size); inv = factory2d.make(size,size); inv.assign(i); lu.decompose(lu); lu.solve(inv); system.out.println("a="+a); system.out.println("lu="+lu); system.out.println("u="+lu.getu()); system.out.println("l="+lu.getl()); a.zsum4neighbors(a,alpha,beta,runs); system.out.println("a="+a); jnt.scimark2.sor.execute(omega, b, runs); form a matrix with the columns as training vectors copy the patterns into the matrix system.out.println(a); for (int i=size; --i>=0; ) { for (int j=size; --j>=0; ) { system.out.println(a); system.out.println(res); make a 45 matrix set all cells to 1 set [2,1] .. [3,3] to 2 modify an independent copy has changed master has not changed [0,3] .. [3,4] a view from a view system.out.println("sum = "+sum); system.out.println(a); for (int i=0; i i="+k+", -i-1="+(-k-1)); system.out.println(a); for (int i=0; i<size; i++) { for (int j=0; j<size; j++ ) { system.out.println(a); doublematrix1d c = b.viewflip(); doublematrix1d d = c.viewflip(); system.out.println("colt="+new ludecomposition(kd).tostring()); system.out.println("jama="+new jama.ludecomposition(km).tostring()); make a 45 matrix set all cells to 1 modify an independent copy has changed master has not changed [0,3] .. [3,4] a view from a view make a 45 matrix set all cells to 1 make a 45 matrix master.assign(1); // set all cells to 1 set [2,1] .. [3,3] to 2 modify an independent copy has changed master has not changed [0,3] .. [3,4] a view from a view make a 45 matrix master.assign(1); // set all cells to 1 master.viewpart(2,0,2,3).assign(2); // set [2,1] .. [3,3] to 2 system.out.println("\n"+master); make a 45 matrix master.assign(1); // set all cells to 1 master.viewpart(2,0,2,3).assign(2); // set [2,1] .. [3,3] to 2 system.out.println("\n"+master); make a 45 matrix master.assign(1); // set all cells to 1 master.viewpart(2,0,2,3).assign(2); // set [2,1] .. [3,3] to 2 system.out.println("\n"+master); test case0... doubletest23(runs, size, nonzerofraction, dense); for (int i = 0; i < dof; ++i) for (int j = 0; j < dof; ++j) m[i][j] = random.nextdouble(); create the matrix object fillout the matrix test the matrix condition using algebra to solve the equation using qrdecomposition to solve the problem.. using jama.qrdecomposition to solve the problem.. see values below... h.zmult( h, hth, 1, 0, true, false ); doublematrix2d res = algebra.default.inverse(hth).zmult(h,null,1,0,false,true); first fill hplus with the transpose of h... .zmult(h,null,1,0,false,true); in matlab... hplus = inv(h' h) h' system.out.println("\nlu="+lud); system.out.println("\nhplus="+hplus); system.out.println("\nperm="+perm); system.out.println("\ninv="+inv); system.out.println("\nres="+res);"
cern.colt.matrix.impl.TridiagonalDoubleMatrix2D "tridiagonal 2-d matrix holding double elements. first see the package summary and javadoc tree view to get the broad picture.  implementation: todo. the non zero elements of the matrix: {lower, diagonal, upper}. the startindexes and number of non zeros: {lowerstart, diagonalstart, upperstart, values.length, lowernonzeros, diagonalnonzeros, uppernonzeros}. lowerstart = 0 diagonalstart = lowerstart + lower.length upperstart = diagonalstart + diagonal.length constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. constructs a matrix with a given number of rows and columns. all entries are initially 0. the number of rows the matrix shall have. the number of columns the matrix shall have. @throws illegalargumentexception if rows integer.max_value. sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). double[] vals = values.elements(); for (int j=values.size(); --j >= 0; ) { vals[j] = alpha; } replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. source the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != source.columns() || rows() != source.rows() returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. protected double diagonal[]; protected double lower[]; protected double upper[]; protected int diagonalnonzeros; protected int lowernonzeros; protected int uppernonzeros; protected int n; {lower, diagonal, upper} {lowerstart, diagonalstart, upperstart, values.length, lowernonzeros, diagonalnonzeros, uppernonzeros} diagonal = new double[d]; lower = new double[l]; upper = new double[u]; diagonalnonzeros = 0; lowernonzeros = 0; uppernonzeros = 0; overriden for performance only for (int i=diagonal.length; --i >= 0; ) diagonal[i]=0; for (int i=upper.length; --i >= 0; ) upper[i]=0; for (int i=lower.length; --i >= 0; ) lower[i]=0; diagonalnonzeros = 0; lowernonzeros = 0; uppernonzeros = 0; x[i] = multx[i] the funny definition of isnan(). this should better not happen. overriden for performance only nothing to do quickest x[i] = x[i] + alphay[i] nothing to do x[i] = x[i] y[i] x[i] = x[i] / y[i] lower case 1: { } // diagonal upper one non zero more lower diagonal int k = -1; int q = 0; if (i==j) { k=0; q=i; } if (i==j+1) { k=1; q=j; } if (i==j-1) { k=2; q=i; } if (k0) { int index = dims[k]+q; if (values[index]!=0) { if (iszero) dims[k+nonzero]--; // one nonzero less } else { if (!iszero) dims[k+nonzero]++; // one nonzero more } values[index] = value; return; } if (!iszero) throw new illegalargumentexception("can't store non-zero value to non-tridiagonal coordinate: row="+row+", column="+column+", value="+value); if (i==j) { if (diagonal[i]!=0) { if (iszero) diagonalnonzeros--; } else { if (!iszero) diagonalnonzeros++; } diagonal[i] = value; return; } if (i==j+1) { if (lower[j]!=0) { if (iszero) lowernonzeros--; } else { if (!iszero) lowernonzeros++; } lower[j] = value; return; } if (i==j-1) { if (upper[i]!=0) { if (iszero) uppernonzeros--; } else { if (!iszero) uppernonzeros++; } upper[i] = value; return; } if (!iszero) throw new illegalargumentexception("can't store non-zero value to non-tridiagonal coordinate: row="+row+", column="+column+", value="+value); z.setquick(row,z.getquick(row) + value y.getquick(column)); system.out.println("["+i+","+j+"]-->"+value); cache views"
cern.colt.matrix.impl.WrapperDoubleMatrix1D "1-d matrix holding double elements; either a view wrapping another matrix or a matrix whose views are wrappers. the elements of the matrix. returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must also be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must also be of type sparsedoublematrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix1d the new matrix must be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix1d the new matrix must be of type sparsedoublematrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. constructs and returns a new flip view. what used to be index 0 is now index size()-1, ..., what used to be index size()-1 is now index 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. constructs and returns a new sub-range view that is a width sub matrix starting at index. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from index..index+width-1. and has view.size() == width. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view are 0 .. view.size()-1==width-1. as usual, any attempt to access a cell at other coordinates will throw an indexoutofboundsexception. index the index of the first cell. width the width of the range. @throws indexoutofboundsexception if indexsize(). new view. constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.size() == indexes.length and view.get(i) == this.get(indexes[i]). indexes can occur multiple times and can be in arbitrary order.  example:   this = (0,0,8,0,7) indexes = (0,2,4,2) --> view = (0,8,7,8)  note that modifying indexes after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. indexes the indexes of the cells that shall be visible in the new view. to indicate that all cells shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..indexes.length()-1. construct and returns a new selection view. the offsets of the visible elements. a new view. constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has size this.size()/stride holding cells this.get(istride) for all i = 0..size()/stride - 1. stride the step factor. @throws indexoutofboundsexception if stride . new view. check for "all" should never get called"
cern.colt.matrix.impl.WrapperDoubleMatrix2D "2-d matrix holding double elements; either a view wrapping another matrix or a matrix whose views are wrappers. the elements of the matrix. constructs a matrix with a copy of the given values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must also be of type densedoublematrix2d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must also be of type sparsedoublematrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type densedoublematrix2d the new matrix must be of type densedoublematrix1d, if the receiver is an instance of type sparsedoublematrix2d the new matrix must be of type sparsedoublematrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   the column to fix. new slice view. @throws indexoutofboundsexception if column = columns(). @see #viewrow(int) constructs and returns a new flip view along the column axis. what used to be column 0 is now column columns()-1, ..., what used to be column columns()-1 is now column 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  columnflip ==> 2 x 3 matrix: 3, 2, 1  6, 5, 4 columnflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewrowflip() constructs and returns a new dice (transposition) view; swaps axes; example: 3 x 4 matrix --> 4 x 3 matrix. the view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns. in other words: view.get(row,column)==this.get(column,row). this is a zero-copy transposition, taking o(1), i.e. constant time. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. use idioms like result = viewdice(a).copy() to generate an independent transposed matrix.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  transpose ==> 3 x 2 matrix: 1, 4  2, 5  3, 6 transpose ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new dice view. constructs and returns a new sub-range view that is a height x width sub matrix starting at [row,column]. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from [row,column] to [row+height-1,column+width-1], all inclusive. and has view.rows() == height; view.columns() == width;. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view range from [0,0] to [view.rows()-1==height-1,view.columns()-1==width-1]. as usual, any attempt to access a cell at a coordinate column&lt;0 || column&gt;=view.columns() || row&lt;0 || row&gt;=view.rows() will throw an indexoutofboundsexception. row the index of the row-coordinate. column the index of the column-coordinate. height the height of the box. width the width of the box. @throws indexoutofboundsexception if columncolumns() || rowrows() new view. constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   the row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) constructs and returns a new flip view along the row axis. what used to be row 0 is now row rows()-1, ..., what used to be row rows()-1 is now row 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  rowflip ==> 2 x 3 matrix: 4, 5, 6  1, 2, 3 rowflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewcolumnflip() constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.rows() == rowindexes.length, view.columns() == columnindexes.length and view.get(i,j) == this.get(rowindexes[i],columnindexes[j]). indexes can occur multiple times and can be in arbitrary order.  example:  this = 2 x 3 matrix: 1, 2, 3 4, 5, 6 rowindexes = (0,1) columnindexes = (1,0,1,0) --> view = 2 x 4 matrix: 2, 1, 2, 1 5, 4, 5, 4  note that modifying the index arguments after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to indicate "all" rows or "all columns", simply set the respective parameter rowindexes the rows of the cells that shall be visible in the new view. to indicate that all rows shall be visible, simply set this parameter to null. columnindexes the columns of the cells that shall be visible in the new view. to indicate that all columns shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..rowindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..columnindexes.length()-1. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has this.rows()/rowstride rows and this.columns()/columnstride columns holding cells this.get(irowstride,jcolumnstride) for all i = 0..rows()/rowstride - 1, j = 0..columns()/columnstride - 1. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the row step factor. the column step factor. new view. @throws indexoutofboundsexception if rowstride. should never get called check for "all" should never be called"
cern.colt.matrix.linalg.Algebra "linear algebraic matrix operations operating on {@link doublematrix2d}; concentrates most functionality of this package. a default algebra object; has {@link property#default} attached for tolerance. allows ommiting to construct an algebra object time and again. note that this algebra object is immutable. any attempt to assign a new property object to it (via method setproperty), or to alter the tolerance of its property object (via property().settolerance(...)) will throw an exception. a default algebra object; has {@link property#zero} attached for tolerance. allows ommiting to construct an algebra object time and again. note that this algebra object is immutable. any attempt to assign a new property object to it (via method setproperty), or to alter the tolerance of its property object (via property().settolerance(...)) will throw an exception. the property object attached to this instance. constructs a new instance with an equality tolerance given by property.default.tolerance(). constructs a new instance with the given equality tolerance. the tolerance to be used for equality operations. constructs and returns the cholesky-decomposition of the given matrix. returns a copy of the receiver. the attached property object is also copied. hence, the property object of the copy is mutable. copy of the receiver. returns the condition of matrix a, which is the ratio of largest to smallest singular value. returns the determinant of matrix a. determinant. constructs and returns the eigenvalue-decomposition of the given matrix. returns sqrt(a^2 + b^2) without under/overflow. returns sqrt(a^2 + b^2) without under/overflow. returns the inverse or pseudo-inverse of matrix a. new independent matrix; inverse(matrix) if the matrix is square, pseudoinverse otherwise. constructs and returns the lu-decomposition of the given matrix. inner product of two vectors; sum(x[i] y[i]). also known as dot product.  equivalent to x.zdotproduct(y). the first source vector. the second source matrix. inner product. @throws illegalargumentexception if x.size() != y.size(). linear algebraic matrix-vector multiplication; z = a y. z[i] = sum(a[i,j] y[j]), i=0..a.rows()-1, j=0..y.size()-1. the source matrix. the source vector. z; a new vector with z.size()==a.rows(). @throws illegalargumentexception if a.columns() != y.size(). linear algebraic matrix-matrix multiplication; c = a x b. c[i,j] = sum(a[i,k] b[k,j]), k=0..n-1.  matrix shapes: a(m x n), b(n x p), c(m x p). the first source matrix. the second source matrix. c; a new matrix holding the results, with c.rows()=a.rows(), c.columns()==b.columns(). @throws illegalargumentexception if b.rows() != a.columns(). outer product of two vectors; sets a[i,j] = x[i] y[j]. the first source vector. the second source vector. the matrix to hold the results. set this parameter to null to indicate that a new result matrix shall be constructed. (for convenience only). @throws illegalargumentexception if a.rows() != x.size() || a.columns() != y.size(). returns the one-norm of vector x, which is sum(abs(x[i])). returns the one-norm of matrix a, which is the maximum absolute column sum. returns the two-norm (aka euclidean norm) of vector x; equivalent to mult(x,x). returns the two-norm of matrix a, which is the maximum singular value; obtained from svd. returns the frobenius norm of matrix a, which is sqrt(sum(a[i,j]2)). returns the infinity norm of vector x, which is max(abs(x[i])). returns the infinity norm of matrix a, which is the maximum absolute row sum. modifies the given vector a such that it is permuted as specified; useful for pivoting. cell a[i] will go into cell a[indexes[i]].  example:  reordering [a,b,c,d,e] with indexes [0,4,2,3,1] yields [a,e,c,d,b] in other words a[0] a the vector to permute. indexes the permutation indexes, must satisfy indexes.length==a.size() && indexes[i] >= 0 && indexes[i] ; work the working storage, must satisfy work.length >= a.size(); set work==null if you don't care about performance. modified a (for convenience only). @throws indexoutofboundsexception if indexes.length != a.size(). int i=size; int a; while (--i >= 0 && (a=indexes[i])==i) if (a = size) throw new indexoutofboundsexception("invalid permutation"); if (iselection view of matrix a; equivalent to {@link doublematrix2d#viewselection(int[],int[])}. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. use idioms like result = permute(...).copy() to generate an independent sub matrix. new permuted selection view. modifies the given matrix a such that it's columns are permuted as specified; useful for pivoting. column a[i] will go into column a[indexes[i]]. equivalent to permuterows(transpose(a), indexes, work). a the matrix to permute. indexes the permutation indexes, must satisfy indexes.length==a.columns() && indexes[i] >= 0 && indexes[i] ; work the working storage, must satisfy work.length >= a.columns(); set work==null if you don't care about performance. modified a (for convenience only). @throws indexoutofboundsexception if indexes.length != a.columns(). modifies the given matrix a such that it's rows are permuted as specified; useful for pivoting. row a[i] will go into row a[indexes[i]].  example:  reordering [a,b,c,d,e] with indexes [0,4,2,3,1] yields [a,e,c,d,b] in other words a[0] a the matrix to permute. indexes the permutation indexes, must satisfy indexes.length==a.rows() && indexes[i] >= 0 && indexes[i] ; work the working storage, must satisfy work.length >= a.rows(); set work==null if you don't care about performance. modified a (for convenience only). @throws indexoutofboundsexception if indexes.length != a.rows(). int i=size; int a; while (--i >= 0 && (a=indexes[i])==i) if (a = size) throw new indexoutofboundsexception("invalid permutation"); if (ib = ak  b = aa...a.  p &gt;= 1: b = aa...a. p == 0: b = identity matrix. p &lt; 0: b = pow(inverse(a),-p).  implementation: based on logarithms of 2, memory usage minimized. the source matrix; must be square; stays unaffected by this operation. the exponent, can be any number. b, a newly constructed result matrix; storage-independent of a. @throws illegalargumentexception if !property().issquare(a). this is the naive version: doublematrix2d b = a.copy(); for (int i=0; ia, obtained from singular value decomposition. attaches the given property object to this algebra, defining tolerance. property object to be attached. @throws unsupportedoperationexception if this==default && property!=this.property() - the default algebra object is immutable. @throws unsupportedoperationexception if this==zero && property!=this.property() - the zero algebra object is immutable. @see #property solves ax = b. ; a new independent matrix; solution if a is square, least squares solution otherwise. solves xa = b, which is also a'x' = b'. ; a new independent matrix; solution if a is square, least squares solution otherwise. copies the columns of the indicated rows into a new sub matrix. sub[0..rowindexes.length-1,0..columnto-columnfrom] = a[rowindexes(:),columnfrom..columnto]; the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a the source matrix to copy from. rowindexes the indexes of the rows to copy. may be unsorted. columnfrom the index of the first column to copy (inclusive). columnto the index of the last column to copy (inclusive). a new sub matrix; with sub.rows()==rowindexes.length; sub.columns()==columnto-columnfrom+1. @throws indexoutofboundsexception if columnfrommatrix.columns() || for any row=rowindexes[i]: row = matrix.rows(). copies the rows of the indicated columns into a new sub matrix. sub[0..rowto-rowfrom,0..columnindexes.length-1] = a[rowfrom..rowto,columnindexes(:)]; the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a the source matrix to copy from. rowfrom the index of the first row to copy (inclusive). rowto the index of the last row to copy (inclusive). columnindexes the indexes of the columns to copy. may be unsorted. a new sub matrix; with sub.rows()==rowto-rowfrom+1; sub.columns()==columnindexes.length. @throws indexoutofboundsexception if rowfrommatrix.rows() || for any col=columnindexes[i]: col = matrix.columns(). constructs and returns a new sub-range view which is the sub matrix a[fromrow..torow,fromcolumn..tocolumn]. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa. use idioms like result = submatrix(...).copy() to generate an independent sub matrix. the source matrix. the index of the first row (inclusive). the index of the last row (inclusive). the index of the first column (inclusive). the index of the last column (inclusive). new sub-range view. @throws indexoutofboundsexception if fromcolumn=a.columns() || fromrow=a.rows() constructs and returns the singularvalue-decomposition of the given matrix. returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  cond : 14.073264490042144 det : illegal operation or error: matrix must be square. norm1 : 0.9620244354009628 norm2 : 3.0 normf : 1.304841791648992 norminfinity : 1.5406551198102534 rank : 3 trace : 0  returns the results of tostring(a) and additionally the results of all sorts of decompositions applied to the given matrix. useful for debugging or to quickly get the rough picture. for example,  a = 3 x 3 matrix 249 66 68 104 214 108 144 146 293 cond : 3.931600417472078 det : 9638870.0 norm1 : 497.0 norm2 : 473.34508217011404 normf : 516.873292016525 norminfinity : 583.0 rank : 3 trace : 756.0 density : 1.0 isdiagonal : false isdiagonallydominantbycolumn : true isdiagonallydominantbyrow : true isidentity : false islowerbidiagonal : false islowertriangular : false isnonnegative : true isorthogonal : false ispositive : true issingular : false isskewsymmetric : false issquare : true isstrictlylowertriangular : false isstrictlytriangular : false isstrictlyuppertriangular : false issymmetric : false istriangular : false istridiagonal : false isunittriangular : false isupperbidiagonal : false isuppertriangular : false iszero : false lowerbandwidth : 2 semibandwidth : 3 upperbandwidth : 2 ----------------------------------------------------------------------------- ludecompositionquick(a) --> isnonsingular(a), det(a), pivot, l, u, inverse(a) ----------------------------------------------------------------------------- isnonsingular = true det = 9638870.0 pivot = [0, 1, 2] l = 3 x 3 matrix 1 0 0 0.417671 1 0 0.578313 0.57839 1 u = 3 x 3 matrix 249 66 68 0 186.433735 79.598394 0 0 207.635819 inverse(a) = 3 x 3 matrix 0.004869 -0.000976 -0.00077 -0.001548 0.006553 -0.002056 -0.001622 -0.002786 0.004816 ----------------------------------------------------------------- qrdecomposition(a) --> hasfullrank(a), h, q, r, pseudo inverse(a) ----------------------------------------------------------------- hasfullrank = true h = 3 x 3 matrix 1.814086 0 0 0.34002 1.903675 0 0.470797 0.428218 2 q = 3 x 3 matrix -0.814086 0.508871 0.279845 -0.34002 -0.808296 0.48067 -0.470797 -0.296154 -0.831049 r = 3 x 3 matrix -305.864349 -195.230337 -230.023539 0 -182.628353 467.703164 0 0 -309.13388 pseudo inverse(a) = 3 x 3 matrix 0.006601 0.001998 -0.005912 -0.005105 0.000444 0.008506 -0.000905 -0.001555 0.002688 -------------------------------------------------------------------------- choleskydecomposition(a) --> issymmetricpositivedefinite(a), l, inverse(a) -------------------------------------------------------------------------- issymmetricpositivedefinite = false l = 3 x 3 matrix 15.779734 0 0 6.590732 13.059948 0 9.125629 6.573948 12.903724 inverse(a) = illegal operation or error: matrix is not symmetric positive definite. --------------------------------------------------------------------- eigenvaluedecomposition(a) --> d, v, realeigenvalues, imageigenvalues --------------------------------------------------------------------- realeigenvalues = 1 x 3 matrix 462.796507 172.382058 120.821435 imageigenvalues = 1 x 3 matrix 0 0 0 d = 3 x 3 matrix 462.796507 0 0 0 172.382058 0 0 0 120.821435 v = 3 x 3 matrix -0.398877 -0.778282 0.094294 -0.500327 0.217793 -0.806319 -0.768485 0.66553 0.604862 --------------------------------------------------------------------- singularvaluedecomposition(a) --> cond(a), rank(a), norm2(a), u, s, v --------------------------------------------------------------------- cond = 3.931600417472078 rank = 3 norm2 = 473.34508217011404 u = 3 x 3 matrix 0.46657 -0.877519 0.110777 0.50486 0.161382 -0.847982 0.726243 0.45157 0.51832 s = 3 x 3 matrix 473.345082 0 0 0 169.137441 0 0 0 120.395013 v = 3 x 3 matrix 0.577296 -0.808174 0.116546 0.517308 0.251562 -0.817991 0.631761 0.532513 0.563301  stringbuffer buf = new stringbuffer(); string unknown = "illegal operation or error: "; string constructionexception = "illegal operation or error upon construction: "; buf.append("------------------------------------------------------------------\n"); buf.append("ludecomposition(a) --> isnonsingular, det, pivot, l, u, inverse(a)\n"); buf.append("------------------------------------------------------------------\n"); returns the sum of the diagonal elements of matrix a; sum(a[i,i]). constructs and returns a new view which is the transposition of the given matrix a. equivalent to {@link doublematrix2d#viewdice a.viewdice()}. this is a zero-copy transposition, taking o(1), i.e. constant time. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. use idioms like result = transpose(a).copy() to generate an independent matrix.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  transpose ==> 3 x 2 matrix: 1, 4  2, 5  3, 6 transpose ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new transposed view. modifies the matrix to be a lower trapezoidal matrix. a (for convenience only). @see #triangulatelower(doublematrix2d) outer product of two vectors; returns a matrix with a[i,j] = x[i] y[j]. the first source vector. the second source vector. outer product a. linear algebraic matrix power; b = ak  b = aa...a. the source matrix; must be square. the exponent, can be any number. new result matrix. @throws illegalargumentexception if !testing.issquare(a). don't use new algebra(property.default.tolerance()), because then property object would be mutable. immutable property object immutable property object fix for bug reported by t.j.hunt@open.ac.uk if (x.size()==0) return 0; return x.aggregate(cern.jet.math.functions.plus,cern.jet.math.functions.abs); double max = 0; for (int i = x.size(); --i >= 0; ) { max = math.max(max, x.getquick(i)); } return max; max = math.max(max, norminfinity(a.viewrow(row))); check validity nothing to permute check validity nothing to permute quicker matrix multiplication based on log2 method: aa....a is slow, ((a a)^2)^2 ... is faster allocates two auxiliary matrices as work space for parallel matrix mult; if not initialized defaults to sequential blas temporary safes one auxiliary matrix allocation mult(a,a); // safes one auxiliary matrix allocation index of highest bit in state "true" here comes the optimized version: cern.colt.timer timer = new cern.colt.timer().start(); while (bit i of p == false) a = mult(a,a); would allocate a lot of temporary memory a.zmult(a,t); swap a with t a = mult(a,a); would allocate a lot of temporary memory a.zmult(a,t); swap a with t if (bit i of p == true) b = mult(b,a); would allocate a lot of temporary memory b.zmult(a,t); swap b with t timer.stop().display(); determine properties sort ascending by property name determine padding for nice formatting finally, format properties cern.colt.timer timer = new cern.colt.timer().start(); timer.stop().display();"
cern.colt.matrix.linalg.Blas " subset of the blas (basic linear algebra system); high quality "building block" routines for performing basic vector and matrix operations. because the blas are efficient, portable, and widely available, they're commonly used in the development of high quality linear algebra software.  mostly for compatibility with legacy notations. most operations actually just delegate to the appropriate methods directly defined on matrices and vectors.   this class implements the blas functions for operations on matrices from the matrix package. it follows the spirit of the draft proposal for java blas interface, by roldan pozo of the national institute of standards and technology. interface definitions are also identical to the ninja interface. because the matrix package supports sections, the interface is actually simpler.  currently, the following operations are supported:   blas level 1: vector-vector operations   ddot : dot product of two vectors  daxpy : scalar times a vector plus a vector  drotg : construct a givens plane rotation  drot : apply a plane rotation  dcopy : copy vector x into vector y  dswap : interchange vectors x and y  dnrm2 : euclidean norm of a vector  dasum : sum of absolute values of vector components  dscal : scale a vector by a scalar  idamax: index of element with maximum absolute value   2.blas level 2: matrix-vector operations   dgemv : matrix-vector multiply with general matrix  dger : rank-1 update on general matrix  dsymv : matrix-vector multiply with symmetric matrix  dtrmv : matrix-vector multiply with triangular matrix   3.blas level 3: matrix-matrix operations  dgemm : matrix-matrix multiply with general matrices     assigns the result of a function to each cell; x[row,col] = function(x[row,col]). the matrix to modify. a function object taking as argument the current cell's value. @see cern.jet.math.functions assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]). the matrix to modify. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if x.columns() != y.columns() || x.rows() != y.rows() @see cern.jet.math.functions returns the sum of absolute values; |x[0]| + |x[1]| + ... . in fact equivalent to x.aggregate(cern.jet.math.functions.plus, cern.jet.math.functions.abs). the first vector. combined vector scaling; y = y + alphax. in fact equivalent to y.assign(x,cern.jet.math.functions.plusmult(alpha)). a scale factor. the first source vector. the second source vector, this is also the vector where results are stored. @throws illegalargumentexception x.size() != y.size().. combined matrix scaling; b = b + alphaa. in fact equivalent to b.assign(a,cern.jet.math.functions.plusmult(alpha)). a scale factor. the first source matrix. the second source matrix, this is also the matrix where results are stored. @throws illegalargumentexception if a.columns() != b.columns() || a.rows() != b.rows(). vector assignment (copying); y = x. in fact equivalent to y.assign(x). the source vector. the destination vector. @throws illegalargumentexception x.size() != y.size(). matrix assignment (copying); b = a. in fact equivalent to b.assign(a). the source matrix. the destination matrix. @throws illegalargumentexception if a.columns() != b.columns() || a.rows() != b.rows(). returns the dot product of two vectors x and y, which is sum(x[i]y[i]). in fact equivalent to x.zdotproduct(y). the first vector. the second vector. sum of products. @throws illegalargumentexception if x.size() != y.size(). generalized linear algebraic matrix-matrix multiply; c = alphaab + betac. in fact equivalent to a.zmult(b,c,alpha,beta,transposea,transposeb). note: matrix shape conformance is checked after potential transpositions. set this flag to indicate that the multiplication shall be performed on a'. set this flag to indicate that the multiplication shall be performed on b'. a scale factor. the first source matrix. the second source matrix. a scale factor. the third source matrix, this is also the matrix where results are stored. @throws illegalargumentexception if b.rows() != a.columns(). @throws illegalargumentexception if c.rows() != a.rows() || c.columns() != b.columns(). @throws illegalargumentexception if a == c || b == c. generalized linear algebraic matrix-vector multiply; y = alphaax + betay. in fact equivalent to a.zmult(x,y,alpha,beta,transposea). note: matrix shape conformance is checked after potential transpositions. set this flag to indicate that the multiplication shall be performed on a'. a scale factor. the source matrix. the first source vector. a scale factor. the second source vector, this is also the vector where results are stored. @throws illegalargumentexception a.columns() != x.size() || a.rows() != y.size()).. performs a rank 1 update; a = a + alphaxy'. example:  a = { {6,5}, {7,6} }, x = {1,2}, y = {3,4}, alpha = 1 --> a = { {9,9}, {13,14} }  a scalar. an m element vector. an n element vector. an m by n matrix. return the 2-norm; sqrt(x[0]^2 + x[1]^2 + ...). in fact equivalent to math.sqrt(algebra.default.norm2(x)). the vector. applies a givens plane rotation to (x,y); x = cx + sy; y = cy - sx. the first vector. the second vector. the cosine of the angle of rotation. the sine of the angle of rotation. constructs a givens plane rotation for (a,b). taken from the linpack translation from fortran to java, interface slightly modified. in the linpack listing drotg is attributed to jack dongarra a rotational elimination parameter a. b rotational elimination parameter b. rotvec[] must be at least of length 4. on output contains the values {a,b,c,s}. vector scaling; x = alphax. in fact equivalent to x.assign(cern.jet.math.functions.mult(alpha)). a scale factor. the first vector. matrix scaling; a = alphaa. in fact equivalent to a.assign(cern.jet.math.functions.mult(alpha)). a scale factor. the matrix. swaps the elements of two vectors; y  x. in fact equivalent to y.swap(x). the first vector. the second vector. @throws illegalargumentexception x.size() != y.size(). swaps the elements of two matrices; b  a. the first matrix. the second matrix. @throws illegalargumentexception if a.columns() != b.columns() || a.rows() != b.rows(). symmetric matrix-vector multiplication; y = alphaax + betay. where alpha and beta are scalars, x and y are n element vectors and a is an n by n symmetric matrix. a can be in upper or lower triangular format. is a upper triangular or lower triangular part to be used? scaling factor. the source matrix. the first source vector. scaling factor. the second vector holding source and destination. triangular matrix-vector multiplication; x = ax or x = a'x. where x is an n element vector and a is an n by n unit, or non-unit, upper or lower triangular matrix. is a upper triangular or lower triangular? set this flag to indicate that the multiplication shall be performed on a'. true --> a is assumed to be unit triangular; false --> a is not assumed to be unit triangular the source matrix. the vector holding source and destination. returns the index of largest absolute value; i such that |x[i]| == max(|x[0]|,|x[1]|,...).. the vector to search through. index of largest absolute value (-1 if x is empty). netlib2.cs.utk.edu/blas/faq.html">blas (basic linear algebra system); math.nist.gov/javanumerics/blas.html">draft proposal for java blas interface,"
cern.colt.matrix.linalg.CholeskyDecomposition "for a symmetric, positive definite matrix a, the cholesky decomposition is a lower triangular matrix l so that a = ll'; if the matrix is not symmetric or positive definite, the constructor returns a partial decomposition and sets an internal flag that may be queried by the issymmetricpositivedefinite() method. array for internal storage of decomposition. @serial internal array storage. row and column dimension (square matrix). @serial matrix dimension. symmetric and positive definite flag. @serial is symmetric and positive definite flag. constructs and returns a new cholesky decomposition object for a symmetric and positive definite matrix; the decomposed matrices can be retrieved via instance methods of the returned decomposition object. a square, symmetric matrix. structure to access l and issymmetricpositivedefinite flag. @throws illegalargumentexception if a is not square. doublematrix1d lrowk = l.viewrow(k); double s = 0.0; for (int i = 0; i l. l returns whether the matrix a is symmetric and positive definite. true if a is symmetric and positive definite; false otherwise solves ax = b; returns x. b a matrix with as many rows as a and any number of columns. x so that ll'x = b. @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if !issymmetricpositivedefinite(). solves ax = b; returns x. b a matrix with as many rows as a and any number of columns. x so that ll'x = b. @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if !issymmetricpositivedefinite(). returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  private double[][] l; initialize. double[][] a = arg.getarray(); l = new double[n][n]; precompute and cache some views to avoid regenerating them time and again main loop. double[] lrowj = l[j]; doublematrix1d lrowj = l.viewrow(j); double[] lrowk = l[k]; copy right hand side. fix by mg ferreira  old code is in method xxxsolvebuggy() solve ly = b; solve l'x = y; copy right hand side. precompute and cache some views to avoid regenerating them time and again solve ly = b; x[i,j] -= x[k,j]l[i,k] solve l'x = y; x[i,j] -= x[k,j]l[k,i]"
cern.colt.matrix.linalg.Diagonal "for diagonal matrices we can often do better. makes this class non instantiable, but still let's others inherit from it. modifies a to hold its inverse. the first vector. the second vector. . @throws illegalargumentexception if x.size() != y.size()."
cern.colt.matrix.linalg.EigenvalueDecomposition "eigenvalues and eigenvectors of a real matrix a.  if a is symmetric, then a = vdv' where the eigenvalue matrix d is diagonal and the eigenvector matrix v is orthogonal. i.e. a = v.mult(d.mult(transpose(v))) and v.mult(transpose(v)) equals the identity matrix.  if a is not symmetric, then the eigenvalue matrix d is block diagonal with the real eigenvalues in 1-by-1 blocks and any complex eigenvalues, lambda + imu, in 2-by-2 blocks, [lambda, mu; -mu, lambda]. the columns of v represent the eigenvectors in the sense that av = vd, i.e. a.mult(v) equals v.mult(d). the matrix v may be badly conditioned, or even singular, so the validity of the equation a = vdinverse(v) depends upon algebra.cond(v). row and column dimension (square matrix). @serial matrix dimension. symmetry flag. @serial internal symmetry flag. arrays for internal storage of eigenvalues. @serial internal storage of eigenvalues. array for internal storage of eigenvectors. @serial internal storage of eigenvectors. array for internal storage of nonsymmetric hessenberg form. @serial internal storage of nonsymmetric hessenberg form. working storage for nonsymmetric algorithm. @serial working storage for nonsymmetric algorithm. constructs and returns a new eigenvalue decomposition object; the decomposed matrices can be retrieved via instance methods of the returned decomposition object. checks for symmetry, then constructs the eigenvalue decomposition. a square matrix. a decomposition object to access d and v. @throws illegalargumentexception if a is not square. returns the block diagonal eigenvalue matrix, d. d returns the imaginary parts of the eigenvalues. imag(diag(d)) returns the real parts of the eigenvalues. real(diag(d)) returns the eigenvector matrix, v v nonsymmetric reduction from hessenberg to real schur form. nonsymmetric reduction to hessenberg form. returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  symmetric tridiagonal ql algorithm. symmetric householder reduction to tridiagonal form. complex scalar division. tridiagonalize. diagonalize. reduce to hessenberg form. reduce hessenberg to real schur form. this is derived from the algol procedure hqr2, by martin and wilkinson, handbook for auto. comp., vol.ii-linear algebra, and the corresponding fortran subroutine in eispack. initialize store roots isolated by balanc and compute matrix norm outer loop over eigenvalue index look for single small sub-diagonal element check for convergence one root found two roots found real pair row modification column modification accumulate transformations complex pair no convergence yet form shift wilkinson's original ad hoc shift matlab's new ad hoc shift (could check iteration count here.) look for two consecutive small sub-diagonal elements double qr step involving rows l:n and columns m:n row modification column modification accumulate transformations (s != 0) k loop check convergence while (n >= low) backsubstitute to find vectors of upper triangular form real vector solve real equations overflow control complex vector last vector component imaginary so matrix is triangular solve complex equations overflow control vectors of isolated roots back transformation to get eigenvectors of original matrix this is derived from the algol procedures orthes and ortran, by martin and wilkinson, handbook for auto. comp., vol.ii-linear algebra, and the corresponding fortran subroutines in eispack. scale column. compute householder transformation. apply householder similarity transformation h = (i-uu'/h)h(i-uu')/h) accumulate transformations (algol's ortran). double division avoids possible underflow this is derived from the algol procedures tql2, by bowdler, martin, reinsch, and wilkinson, handbook for auto. comp., vol.ii-linear algebra, and the corresponding fortran subroutine in eispack. find small subdiagonal element if m == l, d[l] is an eigenvalue, otherwise, iterate. (could check iteration count here.) compute implicit shift implicit ql transformation. accumulate transformation. check for convergence. sort eigenvalues and corresponding vectors. this is derived from the algol procedures tred2 by bowdler, martin, reinsch, and wilkinson, handbook for auto. comp., vol.ii-linear algebra, and the corresponding fortran subroutine in eispack. householder reduction to tridiagonal form. scale to avoid under/overflow. generate householder vector. apply similarity transformation to remaining columns. accumulate transformations."
cern.colt.matrix.linalg.LUDecomposition "for an m x n matrix a with m >= n, the lu decomposition is an m x n unit lower triangular matrix l, an n x n upper triangular matrix u, and a permutation vector piv of length m so that a(piv,:) = lu; if m , then l is m x m and u is m x n.  the lu decomposition with pivoting always exists, even if the matrix is singular, so the constructor will never fail. the primary use of the lu decomposition is in the solution of square systems of simultaneous linear equations. this will fail if isnonsingular() returns false. constructs and returns a new lu decomposition object; the decomposed matrices can be retrieved via instance methods of the returned decomposition object. a rectangular matrix structure to access l, u and piv. returns the determinant, det(a). @exception illegalargumentexception matrix must be square returns pivot permutation vector as a one-dimensional double array (double) piv returns the lower triangular factor, l. l returns a copy of the pivot permutation vector. piv returns the upper triangular factor, u. u returns whether the matrix is nonsingular (has an inverse). if u, and hence a, is nonsingular; false otherwise. solves ax = b. b a matrix with as many rows as a and any number of columns. x so that lux = b(piv,:). @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if a is singular, that is, if !this.isnonsingular(). @exception illegalargumentexception if a.rows() . returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  import cern.colt.matrix.densedoublematrix1d; zero tolerance for compatibility with jama"
cern.colt.matrix.linalg.LUDecompositionQuick "a low level version of {@link ludecomposition}, avoiding unnecessary memory allocation and copying. the input to decompose methods is overriden with the result (lu). the input to solve methods is overriden with the result (x). in addition to ludecomposition, this class also includes a faster variant of the decomposition, specialized for tridiagonal (and hence also diagonal) matrices, as well as a solver tuned for vectors. its disadvantage is that it is a bit more difficult to use than ludecomposition. thus, you may want to disregard this class and come back later, if a need for speed arises.  an instance of this class remembers the result of its last decomposition. usage pattern is as follows: create an instance of this class, call a decompose method, then retrieve the decompositions, determinant, and/or solve as many equation problems as needed. once another matrix needs to be lu-decomposed, you need not create a new instance of this class. start again by calling a decompose method, then retrieve the decomposition and/or solve your equations, and so on. in case a lu matrix is already available, call method setlu instead of decompose and proceed with solving et al.  if a matrix shall not be overriden, use matrix.copy() and hand the the copy to methods.  for an m x n matrix a with m >= n, the lu decomposition is an m x n unit lower triangular matrix l, an n x n upper triangular matrix u, and a permutation vector piv of length m so that a(piv,:) = lu; if m , then l is m x m and u is m x n.  the lu decomposition with pivoting always exists, even if the matrix is singular, so the decompose methods will never fail. the primary use of the lu decomposition is in the solution of square systems of simultaneous linear equations. attempting to solve such a system will throw an exception if isnonsingular() returns false.  array for internal storage of decomposition. @serial internal array storage. pivot sign. @serial pivot sign. internal storage of pivot vector. @serial pivot vector. constructs and returns a new lu decomposition object with default tolerance 1.0e-9 for singularity detection. constructs and returns a new lu decomposition object which uses the given tolerance for singularity detection; decomposes matrix a into l and u (in-place). upon return a is overridden with the result lu, such that lu = a. uses a "left-looking", dot-product, crout/doolittle algorithm. a any matrix. decomposes the banded and square matrix a into l and u (in-place). upon return a is overridden with the result lu, such that lu = a. currently supports diagonal and tridiagonal matrices, all other cases fall through to {@link #decompose(doublematrix2d)}. == 1 --> a is diagonal, == 2 --> a is tridiagonal. a any matrix. returns the determinant, det(a). @exception illegalargumentexception if a.rows() != a.columns() (matrix must be square). returns pivot permutation vector as a one-dimensional double array (double) piv returns the lower triangular factor, l. l returns a copy of the combined lower and upper triangular factor, lu. lu returns the pivot permutation vector (not a copy of it). piv returns the upper triangular factor, u. u returns whether the matrix is nonsingular (has an inverse). if u, and hence a, is nonsingular; false otherwise. returns whether the matrix is nonsingular. if matrix is nonsingular; false otherwise. modifies the matrix to be a lower triangular matrix.  examples:   3 x 5 matrix: 9, 9, 9, 9, 9 9, 9, 9, 9, 9 9, 9, 9, 9, 9  triang.upper ==> 3 x 5 matrix: 9, 9, 9, 9, 9 0, 9, 9, 9, 9 0, 0, 9, 9, 9   5 x 3 matrix: 9, 9, 9 9, 9, 9 9, 9, 9 9, 9, 9 9, 9, 9  triang.upper ==> 5 x 3 matrix: 9, 9, 9 0, 9, 9 0, 0, 9 0, 0, 0 0, 0, 0   3 x 5 matrix: 9, 9, 9, 9, 9 9, 9, 9, 9, 9 9, 9, 9, 9, 9  triang.lower ==> 3 x 5 matrix: 1, 0, 0, 0, 0 9, 1, 0, 0, 0 9, 9, 1, 0, 0   5 x 3 matrix: 9, 9, 9 9, 9, 9 9, 9, 9 9, 9, 9 9, 9, 9  triang.lower ==> 5 x 3 matrix: 1, 0, 0 9, 1, 0 9, 9, 1 9, 9, 9 9, 9, 9   a (for convenience only). @see #triangulateupper(doublematrix2d)   sets the combined lower and upper triangular factor, lu. the parameter is not checked; make sure it is indeed a proper lu decomposition. solves the system of equations ax = b (in-place). upon return b is overridden with the result x, such that lux = b(piv). b a vector with b.size() == a.rows(). @exception illegalargumentexception if b.size() != a.rows(). @exception illegalargumentexception if a is singular, that is, if !isnonsingular(). @exception illegalargumentexception if a.rows() . solves the system of equations ax = b (in-place). upon return b is overridden with the result x, such that lux = b(piv,:). b a matrix with as many rows as a and any number of columns. @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if a is singular, that is, if !isnonsingular(). @exception illegalargumentexception if a.rows() . solves ax = b. b a matrix with as many rows as a and any number of columns. x so that lux = b(piv,:). @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if a is singular, that is, if !this.isnonsingular(). @exception illegalargumentexception if a.rows() . returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  modifies the matrix to be an upper triangular matrix. a (for convenience only). @see #triangulatelower(doublematrix2d) returns pivot permutation vector as a one-dimensional double array (double) piv setup setup pivot vector nothing to do precompute and cache some views to avoid regenerating them time and again sparsity blocked column j outer loop. blocking (make copy of j-th column to localize references) sparsity detection == heuristic depending on speedup apply previous transformations. lucolj is a copy this is the original nasty bug fixed! find pivot and exchange if necessary. compute multipliers. setup setup pivot vector nothing to do if (semibandwidth == 1) { // a is diagonal; nothing to do a is tridiagonal currently no pivoting ! avoid rounding errors consider numerical instability if (matrix.getquick(j,j) == 0) return false; right hand side with pivoting matrix xmat = b.getmatrix(piv,0,nx-1); nothing to do solve ly = b(piv,:) b[i] -= b[k]lu[i][k]; solve ub = y; b[k] /= lu[k,k] b[i] -= b[k]lu[i][k]; right hand side with pivoting matrix xmat = b.getmatrix(piv,0,nx-1); if (this.work2 == null || this.work2.length  y (y is modified b) b[i][j] -= b[k][j]lu[i,k]; solve ux = y; --> x (x is modified b) b[k][j] /= lu[k][k]; b[i][j] -= b[k][j]lu[i][k];"
cern.colt.matrix.linalg.Matrix2DMatrix2DFunction "interface that represents a function object: a function that takes two arguments and returns a single value. applies a function to two arguments. the first argument passed to the function. the second argument passed to the function. result of the function."
cern.colt.matrix.linalg.Property "tests matrices for linear algebraic properties (equality, tridiagonality, symmetry, singularity, etc).  except where explicitly indicated, all methods involving equality tests (==) allow for numerical instability, to a degree specified upon instance construction and returned by method {@link #tolerance()}. the public static final variable default represents a default property object with a tolerance of 1.0e-9. the public static final variable zero represents a property object with a tolerance of 0.0. the public static final variable twelve represents a property object with a tolerance of 1.0e-12. as long as you are happy with these tolerances, there is no need to construct property objects. simply use idioms like property.default.equals(a,b), property.zero.equals(a,b), property.twelve.equals(a,b).  to work with a different tolerance (e.g. 1.0e-15 or 1.0e-5) use the constructor and/or method {@link #settolerance(double)}. note that the public static final property objects are immutable: is is not possible to alter their tolerance. any attempt to do so will throw an exception.  note that this implementation is not synchronized.  example: equals(doublematrix2d a, doublematrix2d b) is defined as follows    { some other tests not related to tolerance go here } double epsilon = tolerance(); for (int row=rows; --row >= 0;) { &nbsp;&nbsp;&nbsp;for (int column=columns; --column >= 0;) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//if (!(a.getquick(row,column) == b.getquick(row,column))) return false; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (math.abs(a.getquick(row,column) - b.getquick(row,column)) > epsilon) return false; &nbsp;&nbsp;&nbsp;} } return true;    here are some example properties   matrix  4&nbsp;x&nbsp;4&nbsp; 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0  4&nbsp;x&nbsp;4 1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;1  4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;0&nbsp;1&nbsp;1   4&nbsp;x&nbsp;4 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;0&nbsp;0&nbsp;1 0&nbsp;0&nbsp;0&nbsp;1   4&nbsp;x&nbsp;4 0&nbsp;0&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;1&nbsp;1  4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;0&nbsp;0 0&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;0&nbsp;1 1&nbsp;0&nbsp;1&nbsp;1    4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;1 0&nbsp;0&nbsp;1&nbsp;1     upperbandwidth  0   0   1  3 0  1   2    lowerbandwidth  0   0   1  0 3  3   2    semibandwidth  1   1   2  4 4  4   3    description  zero   diagonal   tridiagonal  upper triangular lower triangular  unstructured   unstructured    the default property object; currently has tolerance()==1.0e-9. a property object with tolerance()==0.0. a property object with tolerance()==1.0e-12. not instantiable by no-arg constructor. constructs an instance with a tolerance of math.abs(newtolerance). returns a string with length blanks. checks whether the given matrix a is rectangular. @throws illegalargumentexception if a.rows() . checks whether the given matrix a is square. @throws illegalargumentexception if a.rows() != a.columns(). returns the matrix's fraction of non-zero cells; a.cardinality() / a.size(). returns whether all cells of the given matrix a are equal to the given value. the result is true if and only if a != null and ! (math.abs(value - a[i]) > tolerance()) holds for all coordinates. a the first matrix to compare. value the value to compare against. true if the matrix is equal to the value; false otherwise. returns whether both given matrices a and b are equal. the result is true if a==b. otherwise, the result is true if and only if both arguments are != null, have the same size and ! (math.abs(a[i] - b[i]) > tolerance()) holds for all indexes. a the first matrix to compare. b the second matrix to compare. true if both matrices are equal; false otherwise. returns whether all cells of the given matrix a are equal to the given value. the result is true if and only if a != null and ! (math.abs(value - a[row,col]) > tolerance()) holds for all coordinates. a the first matrix to compare. value the value to compare against. true if the matrix is equal to the value; false otherwise. returns whether both given matrices a and b are equal. the result is true if a==b. otherwise, the result is true if and only if both arguments are != null, have the same number of columns and rows and ! (math.abs(a[row,col] - b[row,col]) > tolerance()) holds for all coordinates. a the first matrix to compare. b the second matrix to compare. true if both matrices are equal; false otherwise. returns whether all cells of the given matrix a are equal to the given value. the result is true if and only if a != null and ! (math.abs(value - a[slice,row,col]) > tolerance()) holds for all coordinates. a the first matrix to compare. value the value to compare against. true if the matrix is equal to the value; false otherwise. returns whether both given matrices a and b are equal. the result is true if a==b. otherwise, the result is true if and only if both arguments are != null, have the same number of columns, rows and slices, and ! (math.abs(a[slice,row,col] - b[slice,row,col]) > tolerance()) holds for all coordinates. a the first matrix to compare. b the second matrix to compare. true if both matrices are equal; false otherwise. modifies the given matrix square matrix a such that it is diagonally dominant by row and column, hence non-singular, hence invertible. for testing purposes only. the square matrix to modify. @throws illegalargumentexception if !issquare(a).  a matrix a is diagonal if a[i,j] == 0 whenever i != j. matrix may but need not be square. a matrix a is diagonally dominant by column if the absolute value of each diagonal element is larger than the sum of the absolute values of the off-diagonal elements in the corresponding column. returns true if for all i: abs(a[i,i]) &gt; sum(abs(a[j,i])); j != i. matrix may but need not be square.  note: ignores tolerance. a matrix a is diagonally dominant by row if the absolute value of each diagonal element is larger than the sum of the absolute values of the off-diagonal elements in the corresponding row. returns true if for all i: abs(a[i,i]) &gt; sum(abs(a[i,j])); j != i. matrix may but need not be square.  note: ignores tolerance. a matrix a is an identity matrix if a[i,i] == 1 and all other cells are zero. matrix may but need not be square. a matrix a is lower bidiagonal if a[i,j]==0 unless i==j || i==j+1. matrix may but need not be square. a matrix a is lower triangular if a[i,j]==0 whenever i &lt; j. matrix may but need not be square. a matrix a is non-negative if a[i,j] &gt;= 0 holds for all cells.  note: ignores tolerance. a square matrix a is orthogonal if atranspose(a) = i. @throws illegalargumentexception if !issquare(a). a matrix a is positive if a[i,j] &gt; 0 holds for all cells.  note: ignores tolerance. a matrix a is singular if it has no inverse, that is, iff det(a)==0. a square matrix a is skew-symmetric if a = -transpose(a), that is a[i,j] == -a[j,i]. @throws illegalargumentexception if !issquare(a). a matrix a is square if it has the same number of rows and columns. a matrix a is strictly lower triangular if a[i,j]==0 whenever i &lt;= j. matrix may but need not be square. a matrix a is strictly triangular if it is triangular and its diagonal elements all equal 0. matrix may but need not be square. a matrix a is strictly upper triangular if a[i,j]==0 whenever i &gt;= j. matrix may but need not be square. a matrix a is symmetric if a = tranpose(a), that is a[i,j] == a[j,i]. @throws illegalargumentexception if !issquare(a). a matrix a is triangular iff it is either upper or lower triangular. matrix may but need not be square. a matrix a is tridiagonal if a[i,j]==0 whenever math.abs(i-j) > 1. matrix may but need not be square. a matrix a is unit triangular if it is triangular and its diagonal elements all equal 1. matrix may but need not be square. a matrix a is upper bidiagonal if a[i,j]==0 unless i==j || i==j-1. matrix may but need not be square. a matrix a is upper triangular if a[i,j]==0 whenever i &gt; j. matrix may but need not be square. a matrix a is zero if all its cells are zero. the lower bandwidth of a square matrix a is the maximum i-j for which a[i,j] is nonzero and i &gt; j. a banded matrix has a "band" about the diagonal. diagonal, tridiagonal and triangular matrices are special cases. the square matrix to analyze. lower bandwith. @throws illegalargumentexception if !issquare(a). @see #semibandwidth(doublematrix2d) @see #upperbandwidth(doublematrix2d) returns the semi-bandwidth of the given square matrix a. a banded matrix has a "band" about the diagonal. it is a matrix with all cells equal to zero, with the possible exception of the cells along the diagonal line, the k diagonal lines above the diagonal, and the k diagonal lines below the diagonal. the semi-bandwith l is the number k+1. the bandwidth p is the number 2k + 1. for example, a tridiagonal matrix corresponds to k=1, l=2, p=3, a diagonal or zero matrix corresponds to k=0, l=1, p=1,  the upper bandwidth is the maximum j-i for which a[i,j] is nonzero and j &gt; i. the lower bandwidth is the maximum i-j for which a[i,j] is nonzero and i &gt; j. diagonal, tridiagonal and triangular matrices are special cases.  examples:   matrix  4&nbsp;x&nbsp;4&nbsp; 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0  4&nbsp;x&nbsp;4 1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;1  4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;0&nbsp;1&nbsp;1   4&nbsp;x&nbsp;4 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;1&nbsp;1&nbsp;1 0&nbsp;0&nbsp;0&nbsp;1 0&nbsp;0&nbsp;0&nbsp;1   4&nbsp;x&nbsp;4 0&nbsp;0&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;1&nbsp;1  4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;0&nbsp;0 0&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;0&nbsp;1 1&nbsp;0&nbsp;1&nbsp;1    4&nbsp;x&nbsp;4 1&nbsp;1&nbsp;1&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0 1&nbsp;1&nbsp;0&nbsp;1 0&nbsp;0&nbsp;1&nbsp;1     upperbandwidth  0   0   1  3 0  1   2    lowerbandwidth  0   0   1  0 3  3   2    semibandwidth  1   1   2  4 4  4   3    description  zero   diagonal   tridiagonal  upper triangular lower triangular  unstructured   unstructured    the square matrix to analyze. semi-bandwith l. @throws illegalargumentexception if !issquare(a). @see #lowerbandwidth(doublematrix2d) @see #upperbandwidth(doublematrix2d) sets the tolerance to math.abs(newtolerance). @throws unsupportedoperationexception if this==default || this==zero || this==twelve. returns the current tolerance. returns summary information about the given matrix a. that is a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture of a matrix. for example,  density : 0.9 isdiagonal : false isdiagonallydominantbyrow : false isdiagonallydominantbycolumn : false isidentity : false islowerbidiagonal : false islowertriangular : false isnonnegative : true isorthogonal : illegal operation or error: matrix must be square. ispositive : true issingular : illegal operation or error: matrix must be square. isskewsymmetric : illegal operation or error: matrix must be square. issquare : false isstrictlylowertriangular : false isstrictlytriangular : false isstrictlyuppertriangular : false issymmetric : illegal operation or error: matrix must be square. istriangular : false istridiagonal : false isunittriangular : false isupperbidiagonal : false isuppertriangular : false iszero : false lowerbandwidth : illegal operation or error: matrix must be square. semibandwidth : illegal operation or error: matrix must be square. upperbandwidth : illegal operation or error: matrix must be square.  the upper bandwidth of a square matrix a is the maximum j-i for which a[i,j] is nonzero and j &gt; i. a banded matrix has a "band" about the diagonal. diagonal, tridiagonal and triangular matrices are special cases. the square matrix to analyze. upper bandwith. @throws illegalargumentexception if !issquare(a). @see #semibandwidth(doublematrix2d) @see #lowerbandwidth(doublematrix2d) if (!(a.getquick(row,column) == b.getquick(row,column))) return false; just to be on the safe side if (!(a.getquick(i) == value)) return false; if (math.abs(value - a.getquick(i)) > epsilon) return false; if (!(getquick(i) == b.getquick(i))) return false; if (math.abs(a.getquick(i) - b.getquick(i)) > epsilon) return false; if (!(a.getquick(row,column) == value)) return false; if (math.abs(value - a.getquick(row,column)) > epsilon) return false; if (!(a.getquick(row,column) == b.getquick(row,column))) return false; if (math.abs((a.getquick(row,column) - b.getquick(row,column)) > epsilon) return false; if (!(a.getquick(slice,row,column) == value)) return false; if (math.abs(value - a.getquick(slice,row,column)) > epsilon) return false; if (!(a.getquick(slice,row,column) == b.getquick(slice,row,column))) return false; if (math.abs(a.getquick(slice,row,column) - b.getquick(slice,row,column)) > epsilon) return false; if (row!=column && a.getquick(row,column) != 0) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(row,column) != -a.getquick(column,row)) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(i,i) != 0) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(i,i) != 1) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(row,column) != 0) return false; if (a.getquick(j,i) != 0) return k; if (a.getquick(j,i) != 0) return k+1; if (a.getquick(i,j) != 0) return k+1; throw new unsupportedoperationexception("attempted to modify object."); // since jdk1.2 determine properties determine properties determine properties determine properties sort ascending by property name determine padding for nice formatting finally, format properties if (a.getquick(i,j) != 0) return k;"
cern.colt.matrix.linalg.QRDecomposition "for an m x n matrix a with m >= n, the qr decomposition is an m x n orthogonal matrix q and an n x n upper triangular matrix r so that a = qr.  the qr decompostion always exists, even if the matrix does not have full rank, so the constructor will never fail. the primary use of the qr decomposition is in the least squares solution of nonsquare systems of simultaneous linear equations. this will fail if isfullrank() returns false. array for internal storage of decomposition. @serial internal array storage. row and column dimensions. @serial column dimension. @serial row dimension. array for internal storage of diagonal of r. @serial diagonal of r. constructs and returns a new qr decomposition object; computed by householder reflections; the decomposed matrices can be retrieved via instance methods of the returned decomposition object. a rectangular matrix. a decomposition object to access r and the householder vectors h, and to compute q. @throws illegalargumentexception if a.rows() . for (int i = k; i h. lower trapezoidal matrix whose columns define the householder reflections. generates and returns the (economy-sized) orthogonal factor q. q returns the upper triangular factor, r. r returns whether the matrix a has full rank. if r, and hence a, has full rank. least squares solution of ax = b; returns x. a matrix with as many rows as a and any number of columns. x that minimizes the two norm of qrx - b. @exception illegalargumentexception if b.rows() != a.rows(). @exception illegalargumentexception if !this.hasfullrank() (a is rank deficient). returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  private double[][] qr; initialize. rdiag = new double[n]; precompute and cache some views to avoid regenerating them time and again main loop. doublematrix1d qrcolk = qr.viewcolumn(k).viewpart(k,m-k); compute 2-norm of k-th column without under/overflow. if (k<m) nrm = qrcolumnspart[k].aggregate(hypot,f.identity); fixes bug reported by hong.44@osu.edu form k-th householder vector. apply transformation to remaining columns. fixes bug reported by john chambers qrcolumnspart[j].assign(qrcolumns[k], f.plusmult(s)); double[][] q = x.getarray(); copy right hand side compute y = transpose(q)b solve rx = y;"
cern.colt.matrix.linalg.SeqBlas "sequential implementation of the basic linear algebra system. little trick to allow for "aliasing", that is, renaming this class. time and again writing code like  seqblas.blas.dgemm(...);  is a bit awkward. using the aliasing you can instead write  blas b = seqblas.blas;  b.dgemm(...); makes this class non instantiable, but still let's others inherit from it. implements the fortran sign (not sin) function. see the code for details. a a b b b.swap(a); not yet implemented"
cern.colt.matrix.linalg.SingularValueDecomposition "for an m x n matrix a with m >= n, the singular value decomposition is an m x n orthogonal matrix u, an n x n diagonal matrix s, and an n x n orthogonal matrix v so that a = usv'.  the singular values, sigma[k] = s[k][k], are ordered so that sigma[0] >= sigma[1] >= ... >= sigma[n-1].  the singular value decomposition always exists, so the constructor will never fail. the matrix condition number and the effective numerical rank can be computed from this decomposition. arrays for internal storage of u and v. @serial internal storage of u. @serial internal storage of v. array for internal storage of singular values. @serial internal storage of singular values. row and column dimensions. @serial row dimension. @serial column dimension. constructs and returns a new singular value decomposition object; the decomposed matrices can be retrieved via instance methods of the returned decomposition object. a rectangular matrix. a decomposition object to access u, s and v. @throws illegalargumentexception if a.rows() . returns the two norm condition number, which is max(s) / min(s). returns the diagonal matrix of singular values. s returns the diagonal of s, which is a one-dimensional array of singular values diagonal of s. returns the left singular vectors u. u returns the right singular vectors v. v returns the two norm, which is max(s). returns the effective numerical matrix rank, which is the number of nonnegligible singular values. returns a string with (propertyname, propertyvalue) pairs. useful for debugging or to quickly get the rough picture. for example,  rank : 3 trace : 0  derived from linpack code. initialize. reduce a to bidiagonal form, storing the diagonal elements in s and the super-diagonal elements in e. compute the transformation for the k-th column and place the k-th diagonal in s[k]. compute 2-norm of k-th column without under/overflow. apply the transformation. place the k-th row of a into e for the subsequent calculation of the row transformation. place the transformation in u for subsequent back multiplication. compute the k-th row transformation and place the k-th super-diagonal in e[k]. compute 2-norm without under/overflow. apply the transformation. place the transformation in v for subsequent back multiplication. set up the final bidiagonal matrix or order p. if required, generate u. if required, generate v. main iteration loop for the singular values. here is where a test for too many iterations would go. this section of the program inspects for negligible elements in the s and e arrays. on completion the variables kase and k are set as follows. kase = 1 if s(p) and e[k-1] are negligible and k<p kase = 2 if s(k) is negligible and k<p kase = 3 if e[k-1] is negligible, k<p, and s(k), ..., s(p) are not negligible (qr step). kase = 4 if e(p-1) is negligible (convergence). perform the task indicated by kase. deflate negligible s(p). split at negligible s(k). perform one qr step. calculate the shift. chase zeros. convergence. make the singular values positive. order the singular values. return new doublematrix2d(u,m,math.min(m+1,n));"
cern.colt.matrix.linalg.Smp "constructs a new smp using a maximum of maxthreads threads. clean up deamon threads, if necessary. determine how to split and parallelize best into blocks if more b.columns than tasks --> split b.columns, as follows: xx|xx|xxx b xx|xx|xxx xx|xx|xxx a xxx xx|xx|xxx c xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx if less b.columns than tasks --> split a.rows, as follows: xxxxxxx b xxxxxxx xxxxxxx a xxx xxxxxxx c xxx xxxxxxx --- ------- xxx xxxxxxx xxx xxxxxxx --- ------- xxx xxxxxxx determine how to split and parallelize best into blocks if more b.columns than tasks --> split b.columns, as follows: xx|xx|xxx b xx|xx|xxx xx|xx|xxx a xxx xx|xx|xxx c xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx if less b.columns than tasks --> split a.rows, as follows: xxxxxxx b xxxxxxx xxxxxxx a xxx xxxxxxx c xxx xxxxxxx --- ------- xxx xxxxxxx xxx xxxxxxx --- ------- xxx xxxxxxx prints various snapshot statistics to system.out; simply delegates to {@link edu.oswego.cs.dl.util.concurrent.fjtaskrunnergroup#stats}. a very efficient and light weight thread pool avoid parallel overhead system.out.print("."); run tasks and wait for completion long flops = 2la.rows()a.columns()a.columns(); each thread should process at least 30000 flops boolean splithoriz = (a.columns() >= nooftasks); parallelization doesn't pay off (too much start up overhead) set up concurrent tasks last span may be a bit larger split b along columns into blocks split a along rows into blocks long flops = 2la.rows()a.columns()a.columns(); each thread should process at least 30000 flops boolean splithoriz = (a.columns() >= nooftasks); parallelization doesn't pay off (too much start up overhead) set up concurrent tasks last span may be a bit larger split b along columns into blocks split a along rows into blocks"
cern.colt.matrix.linalg.SmpBlas "parallel implementation of the basic linear algebra system for symmetric multi processing boxes. currently only a few algorithms are parallelised; the others are fully functional, but run in sequential mode. parallelised are:  {@link #dgemm dgemm} (matrix-matrix multiplication) {@link #dgemv dgemv} (matrix-vector multiplication) {@link #assign(doublematrix2d,cern.colt.function.doublefunction) assign(a,function)} (generalized matrix scaling/transform): strong speedup only for expensive functions like logarithm, sin, etc. {@link #assign(doublematrix2d,doublematrix2d,cern.colt.function.doubledoublefunction) assign(a,b,function)} (generalized matrix scaling/transform): strong speedup only for expensive functions like pow etc.  in all cases, no or only marginal speedup is seen for small problem sizes; they are detected and the sequential algorithm is used. usage call the static method {@link #allocateblas} at the very beginning of your program, supplying the main parameter for smpblas, the number of available cpus. the method sets the public global variable smpblas.smpblas to a blas using a maximum of cpus threads, each concurrently processing matrix blocks with the given sequential blas algorithms. normally there is no need to call allocateblas more than once. then use smpblas.smpblas.someroutine(...) to run someroutine in parallel. e.g.    int cpu_s = 4; smpblas.allocateblas(cpu_s, seqblas.seqblas); ... smpblas.smpblas.dgemm(...) smpblas.smpblas.dgemv(...)    even if you don't call a blas routine yourself, it often makes sense to allocate a smpblas, because other matrix library routines sometimes call the blas. so if you're lucky, you get parallel performance for free. notes  unfortunately, there is no portable means of automatically detecting the number of cpus on a jvm, so there is no good way to automate defaults. only improves performance on boxes with > 1 cpus and vms with native threads. currently only improves performance when working on dense matrix types. on sparse types, performance is likely to degrade (because of the implementation of sub-range views)! implemented using doug lea's fast lightweight task framework ({@link edu.oswego.cs.dl.util.concurrent}) built upon java threads, and geared for parallel computation.  @see edu.oswego.cs.dl.util.concurrent.fjtaskrunnergroup @see edu.oswego.cs.dl.util.concurrent.fjtask the public global parallel blas; initialized via {@link #allocateblas}. do not modify this variable via other means (it is public). constructs a blas using a maximum of maxthreads threads; each executing the given sequential algos. sets the public global variable smpblas.smpblas to a blas using a maximum of maxthreads threads, each executing the given sequential algorithm; maxthreads is normally the number of cpus. call this method at the very beginning of your program. normally there is no need to call this method more than once. the maximum number of threads (= cpus) to be used the sequential blas algorithms to be used on concurrently processed matrix blocks. determine how to split and parallelize best into blocks if more b.columns than tasks --> split b.columns, as follows: xx|xx|xxx b xx|xx|xxx xx|xx|xxx a xxx xx|xx|xxx c xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx xxx xx|xx|xxx if less b.columns than tasks --> split a.rows, as follows: xxxxxxx b xxxxxxx xxxxxxx a xxx xxxxxxx c xxx xxxxxxx --- ------- xxx xxxxxxx xxx xxxxxxx --- ------- xxx xxxxxxx split a, as follows: x x x x a xxx x y xxx x --- - xxx x xxx x --- - xxx x prints various snapshot statistics to system.out; simply delegates to {@link edu.oswego.cs.dl.util.concurrent.fjtaskrunnergroup#stats}. blocks are operated on in parallel; for each block this seq algo is used. smp.smp = new smp(maxthreads); no need to change anything? each thread should process at least 30000 flops parallelization doesn't pay off (too much start up overhead) set up concurrent tasks last span may be a bit larger split b along columns into blocks split a along rows into blocks system.out.println("hello "+offset); run tasks and wait for completion each thread should process at least 30000 flops parallelization doesn't pay off (too much start up overhead) set up concurrent tasks last span may be a bit larger split a along rows into blocks system.out.println("hello "+offset); run tasks and wait for completion blocks = this.smp.splitstridednn(a, b, nn_threshold, a.rows()a.columns()); too small --> sequential parallel blocks = this.smp.splitstridednn(a, nn_threshold, a.rows()a.columns()); too small -> sequential parallel"
cern.colt.matrix.objectalgo.Formatter "flexible, well human readable matrix print formatting. each cell is converted using {@link object#tostring()}. for examples see {@link cern.colt.matrix.doublealgo.formatter doublealgo.formatter} which is just the same except that it operates on doubles. constructs and returns a matrix formatter with alignment left. constructs and returns a matrix formatter. the given alignment used to align a column. converts a given cell to a string; no alignment considered. converts a given cell to a string; no alignment considered. returns a string representations of all cells; no alignment considered. returns a string representations of all cells; no alignment considered. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string s such that object[] m = s is a legal java statement. the matrix to format. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix. the matrix to convert. returns a string representation of the given matrix with axis as well as rows and columns labeled. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. matrix converted to a string. returns a string representation of the given matrix with axis as well as rows and columns labeled. pass null to one or more parameters to indicate that the corresponding decoration element shall not appear in the string converted matrix. the matrix to format. the headers of all slices (to be put above each slice). the headers of all rows (to be put to the left of the matrix). the headers of all columns (to be put to above the matrix). the label of the z-axis (to be put above each slice). the label of the y-axis. the label of the x-axis. the overall title of the matrix to be formatted. matrix converted to a string. determine how many rows and columns are needed make larger matrix holding original matrix and naming strings insert original matrix into larger matrix insert column axis name in leading row insert row axis name in leading column insert row names in next leading columns insert vertical "---------" separator line in next leading column convert the large matrix to a string insert horizontal "--------------" separator line insert line for column axis name insert title"
cern.colt.matrix.objectalgo.ObjectMatrix1DComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.matrix.objectalgo.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.matrix.objectalgo.ObjectMatrix2DComparator "a comparison function which imposes a total ordering on some collection of elements. comparators can be passed to a sort method (such as cern.colt.matrix.objectalgo.sorting.quicksort) to allow precise control over the sort order. note: it is generally a good idea for comparators to implement java.io.serializable, as they may be used as ordering methods in serializable data structures. in order for the data structure to serialize successfully, the comparator (if provided) must implement serializable. compares its two arguments for order. returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. the implementor must ensure that sgn(compare(x, y)) == -sgn(compare(y, x)) for all x and y. (this implies that compare(x, y) must throw an exception if and only if compare(y, x) throws an exception.) the implementor must also ensure that the relation is transitive: ((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0. finally, the implementer must ensure that compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z. negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second. indicates whether some other object is &quot;equal to&quot; this comparator. this method must obey the general contract of object.equals(object). additionally, this method can return true only if the specified object is also a comparator and it imposes the same ordering as this comparator. thus, comp1.equals(comp2) implies that sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2)) for every element o1 and o2. note that it is always safe not to override object.equals(object). however, overriding this method may, in some cases, improve performance by allowing programs to determine that two distinct comparators impose the same order. obj the reference object with which to compare. true only if the specified object is also a comparator and it imposes the same ordering as this comparator. @see java.lang.object#equals(java.lang.object) @see java.lang.object#hashcode()"
cern.colt.matrix.objectalgo.Partitioning "given some interval boundaries, partitions matrices such that cell values falling into an interval are placed next to each other.  performance  partitioning into two intervals is o( n ). partitioning into k intervals is o( n log(k)). constants factors are minimized. @see cern.colt.partitioning "partitioning arrays (provides more documentation)" makes this class non instantiable, but still let's others inherit from it. same as {@link cern.colt.partitioning#partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = 0; rowindexes = {0,1,2,..,matrix.rows()-1}; rowfrom = 0; rowto = matrix.rows()-1; splitters = {5,10,12} c = 0;  d = splitters.length-1; partition(matrix,rowindexes,rowfrom,rowto,column,splitters,c,d,splitindexes); ==> splitindexes == {0, 2, 3} rowindexes == {7, 6, 5, 4, 0, 1, 2, 3}   the matrix is not reordered. here is how it would look like, if it would be reordered accoring to rowindexes. 8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    the matrix to be partitioned. the index of the i-th row; is modified by this method to reflect partitioned indexes. the index of the first row (inclusive). the index of the last row (inclusive). the index of the column to partition on. the values at which the rows shall be split into intervals. must be sorted ascending and must not contain multiple identical values. these preconditions are not checked; be sure that they are met. the index of the first splitter element to be considered. the index of the last splitter element to be considered. the method considers the splitter elements splitters[splitfrom] .. splitters[splitto]. a list into which this method fills the indexes of rows delimiting intervals. upon return splitindexes[splitfrom..splitto] will be set accordingly. therefore, must satisfy splitindexes.length >= splitters.length. same as {@link cern.colt.partitioning#partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = 0; splitters = {5,10,12} partition(matrix,column,splitters,splitindexes); ==> splitindexes == {0, 2, 3}   the matrix is not reordered. the new view is reordered: 8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    the matrix to be partitioned. the index of the column to partition on. the values at which the rows shall be split into intervals. must be sorted ascending and must not contain multiple identical values. these preconditions are not checked; be sure that they are met. a list into which this method fills the indexes of rows delimiting intervals. therefore, must satisfy splitindexes.length >= splitters.length. new matrix view having rows partitioned by the given column and splitters. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that it synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  of course, the column must not be a column of a different matrix. more formally, there must hold:  there exists an i such that matrix.viewcolumn(i)==column.  note that arguments are not checked for validity.  example:   8 x 3 matrix: 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12 11, 10, 9 8, 7, 6 5, 4, 3 2, 1, 0   column = matrix.viewcolumn(0); a = 0; b = column.size()-1; splitters={5,10,12} c=0;  d=splitters.length-1; partition(matrix,column,a,b,splitters,c,d,splitindexes); ==> splitindexes == {0, 2, 3}  8 x 3 matrix: 2, 1, 0 5, 4, 3 8, 7, 6 11, 10, 9 23, 22, 21 20, 19, 18 17, 16, 15 14, 13, 12    object splitter; // int, object --> template type dependent if (splitfrom>splitto) return; // nothing to do if (from>to) { // all bins are empty from--; for (int i = splitfrom; i small) { int l = from; int n = to; if (len > medium) { // big arrays, pseudomedian of 9 int s = len/8; l = med3(column, l, l+s, l+2s); m = med3(column, m-s, m, m+s); n = med3(column, n-2s, n-s, n); } m = med3(column, l, m, n); // mid-size, pseudomedian of 3 } // find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. medianindex = cern.colt.sorting.binarysearchfromto(splitters,column.getquick(m),splitfrom,splitto); if (medianindex  splitto) medianindex = splitto; // not found, one past the end } splitter = splitters[medianindex]; // partition the list according to the splitter, i.e. // establish invariant: list[i] =splitfrom && (!(splitter = to) { // all elements fall into this bin // all bins with splitters[i] >= splitter are empty int i = medianindex+1; while (i splitters[i]))) splitindexes[i++] = splitindex; splitto = medianindex-1; } // recursively partition left half if (splitfrom synchronously partitions the rows of the given matrix by the values of the given matrix column; this is essentially the same as partitioning a list of composite objects by some instance variable; in other words, two entire rows of the matrix are swapped, whenever two column values indicate so.  let's say, a "row" is an "object" (tuple, d-dimensional point). a "column" is the list of "object" values of a given variable (field, dimension). a "matrix" is a list of "objects" (tuples, points).  now, rows (objects, tuples) are partially sorted according to their values in one given variable (dimension). two entire rows of the matrix are swapped, whenever two column values indicate so.  of course, the column must not be a column of a different matrix. more formally, there must hold:  there exists an i such that matrix.viewcolumn(i)==column. note that arguments are not checked for validity. object element; // int, object --> template type dependent for (int i=from-1; ++i template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, object --> template type dependent swap x[i] with x[from]"
cern.colt.matrix.objectalgo.Sorting "matrix quicksorts and mergesorts. use idioms like sorting.quicksort.sort(...) and sorting.mergesort.sort(...).  this is another case demonstrating one primary goal of this library: delivering easy to use, yet very efficient apis. the sorts return convenient sort views. this enables the usage of algorithms which scale well with the problem size: for example, sorting a 1000000 x 10000 or a 1000000 x 100 x 100 matrix performs just as fast as sorting a 1000000 x 1 matrix. this is so, because internally the algorithms only move around integer indexes, they do not physically move around entire rows or slices. the original matrix is left unaffected.  the quicksort is a derivative of the jdk 1.2 v1.26 algorithms (which are, in turn, based on bentley's and mcilroy's fine work). the mergesort is a derivative of the jal algorithms, with optimisations taken from the jdk algorithms. mergesort is stable (by definition), while quicksort is not. a stable sort is, for example, helpful, if matrices are sorted successively by multiple columns. it preserves the relative position of equal elements. @see cern.colt.genericsorting @see cern.colt.sorting @see java.util.arrays a prefabricated quicksort. a prefabricated mergesort. makes this class non instantiable, but still let's others inherit from it. sorts the vector into ascending order, according to the natural ordering. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort descending, use flip views ...  example:    7, 1, 3, 1    ==&gt; 1, 1, 3, 7 the vector is not sorted. the new view is sorted.    the vector to be sorted. new sorted vector (matrix) view. note that the original matrix is left unaffected. sorts the vector into ascending order, according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two cells at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort descending, use flip views ...  example:  // sort by sinus of cells objectcomparator comp = new objectcomparator() { &nbsp;&nbsp;&nbsp;public int compare(object a, object b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object as = math.sin(a); object bs = math.sin(b); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the vector to be sorted. the comparator to determine the order. new matrix view sorted as specified. note that the original vector (matrix) is left unaffected. sorts the matrix rows into ascending order, according to the natural ordering of the matrix values in the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example:   4 x 2 matrix:  7, 6 5, 4 3, 2 1, 0    column = 0; view = quicksort(matrix,column); system.out.println(view);  ==>    4 x 2 matrix: 1, 0 3, 2 5, 4 7, 6 the matrix is not sorted. the new view is sorted.    the matrix to be sorted. the index of the column inducing the order. new matrix view having rows sorted by the given column. note that the original matrix is left unaffected. @throws indexoutofboundsexception if column = matrix.columns(). sorts the matrix rows according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two rows (1-d matrices) at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort columns by rows, use dice views. to sort descending, use flip views ...  example:  // sort by sum of values in a row objectmatrix1dcomparator comp = new objectmatrix1dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(objectmatrix1d a, objectmatrix1d b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object as = a.zsum(); object bs = b.zsum(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the matrix to be sorted. the comparator to determine the order. new matrix view having rows sorted as specified. note that the original matrix is left unaffected. sorts the matrix slices into ascending order, according to the natural ordering of the matrix values in the given [row,column] position. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to sort ranges use sub-ranging views. to sort by other dimensions, use dice views. to sort descending, use flip views ...  the algorithm compares two 2-d slices at a time, determinining whether one is smaller, equal or larger than the other. comparison is based on the cell [row,column] within a slice. let a and b be two 2-d slices. then we have the following rules  a &lt; b iff a.get(row,column) &lt; b.get(row,column) a == b iff a.get(row,column) == b.get(row,column) a &gt; b iff a.get(row,column) &gt; b.get(row,column)  the matrix to be sorted. the index of the row inducing the order. the index of the column inducing the order. new matrix view having slices sorted by the values of the slice view matrix.viewrow(row).viewcolumn(column). note that the original matrix is left unaffected. @throws indexoutofboundsexception if row = matrix.rows() || column = matrix.columns(). sorts the matrix slices according to the order induced by the specified comparator. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the algorithm compares two slices (2-d matrices) at a time, determinining whether one is smaller, equal or larger than the other. to sort ranges use sub-ranging views. to sort by other dimensions, use dice views. to sort descending, use flip views ...  example:  // sort by sum of values in a slice objectmatrix2dcomparator comp = new objectmatrix2dcomparator() { &nbsp;&nbsp;&nbsp;public int compare(objectmatrix2d a, objectmatrix2d b) { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object as = a.zsum(); object bs = b.zsum(); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return as  the matrix to be sorted. the comparator to determine the order. new matrix view having slices sorted as specified. note that the original matrix is left unaffected. already has quicksort implemented override quicksort with mergesort row indexes to reorder instead of matrix itself sort by sinus of cells row indexes to reorder instead of matrix itself row indexes to reorder instead of matrix itself view the matrix according to the reordered row indexes take all columns in the original order sort by sum of values in a row row indexes to reorder instead of matrix itself precompute views for speed return c.compare(matrix.viewrow(a), matrix.viewrow(b)); view the matrix according to the reordered row indexes take all columns in the original order indexes to reorder instead of matrix itself view the matrix according to the reordered slice indexes take all rows and columns in the original order sort by sum of values in a slice indexes to reorder instead of matrix itself precompute views for speed return c.compare(matrix.viewslice(a), matrix.viewslice(b)); view the matrix according to the reordered slice indexes take all rows and columns in the original order"
cern.colt.matrix.ObjectFactory1D "factory for convenient construction of 1-d matrices holding object cells. use idioms like objectfactory1d.dense.make(1000) to construct dense matrices, objectfactory1d.sparse.make(1000) to construct sparse matrices. if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:    objectfactory1d f = objectfactory1d.dense; f.make(1000); ...    a factory producing dense matrices. a factory producing sparse matrices. makes this class non instantiable, but still let's others inherit from it. c = a||b; constructs a new matrix which is the concatenation of two other matrices. example: 0 1 append 3 4 --> 0 1 3 4. constructs a matrix which is the concatenation of all given parts. cells are copied. constructs a matrix with the given cell values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value. constructs a matrix from the values of the given list. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. new matrix. c = a||a||..||a; constructs a new matrix which is concatenated repeat times. example:  0 1 repeat(3) --> 0 1 0 1 0 1  constructs a list from the given matrix. the values are copied. so subsequent changes in values are not reflected in the list, and vice-versa. the values to be filled into the new list. new list. concatenate"
cern.colt.matrix.ObjectFactory2D "factory for convenient construction of 2-d matrices holding object cells. also provides convenient methods to compose (concatenate) and decompose (split) matrices from/to constituent blocks.  &nbsp;    construction use idioms like objectfactory2d.dense.make(4,4) to construct dense matrices, objectfactory2d.sparse.make(4,4) to construct sparse matrices.    construction with initial values  use other make methods to construct matrices with given initial values.     appending rows and columns  use methods {@link #appendcolumns(objectmatrix2d,objectmatrix2d) appendcolumns}, {@link #appendcolumns(objectmatrix2d,objectmatrix2d) appendrows} and {@link #repeat(objectmatrix2d,int,int) repeat} to append rows and columns.     general block matrices  use methods {@link #compose(objectmatrix2d[][]) compose} and {@link #decompose(objectmatrix2d[][],objectmatrix2d) decompose} to work with general block matrices.     diagonal block matrices  use method {@link #composediagonal(objectmatrix2d,objectmatrix2d,objectmatrix2d) composediagonal} to work with diagonal block matrices.    &nbsp; if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:     objectfactory2d f = objectfactory2d.dense; f.make(4,4); ...    a factory producing dense matrices. a factory producing sparse matrices. makes this class non instantiable, but still let's others inherit from it. c = a||b; constructs a new matrix which is the column-wise concatenation of two other matrices.  0 1 2 3 4 5 appendcolumns 6 7 8 9 --> 0 1 2 6 7 3 4 5 8 9  c = a||b; constructs a new matrix which is the row-wise concatenation of two other matrices.  0 1 2 3 4 5 appendrows 6 7 8 9 --> 0 1 2 3 4 5 6 7 8 9  checks whether the given array is rectangular, that is, whether all rows have the same number of columns. @throws illegalargumentexception if the array is not rectangular. checks whether the given array is rectangular, that is, whether all rows have the same number of columns. @throws illegalargumentexception if the array is not rectangular. constructs a block matrix made from the given parts. the inverse to method {@link #decompose(objectmatrix2d[][], objectmatrix2d)}.  all matrices of a given column within parts must have the same number of columns. all matrices of a given row within parts must have the same number of rows. otherwise an illegalargumentexception is thrown. note that nulls within parts[row,col] are an exception to this rule: they are ignored. cells are copied. example:   code result     objectmatrix2d[][] parts1 = { &nbsp;&nbsp;&nbsp;{ null, make(2,2,1), null }, &nbsp;&nbsp;&nbsp;{ make(4,4,2), null, make(4,3,3) }, &nbsp;&nbsp;&nbsp;{ null, make(2,2,4), null } }; system.out.println(compose(parts1));   8&nbsp;x&nbsp;9&nbsp;matrix 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;1&nbsp;0&nbsp;0&nbsp;0 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;3&nbsp;3 0&nbsp;0&nbsp;0&nbsp;0&nbsp;4&nbsp;4&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;4&nbsp;4&nbsp;0&nbsp;0&nbsp;0     objectmatrix2d[][] parts3 = { &nbsp;&nbsp;&nbsp;{ identity(3), null, }, &nbsp;&nbsp;&nbsp;{ null, identity(3).viewcolumnflip() }, &nbsp;&nbsp;&nbsp;{ identity(3).viewrowflip(), null } }; system.out.println("\n"+make(parts3));   9&nbsp;x&nbsp;6&nbsp;matrix 1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;1 0&nbsp;0&nbsp;0&nbsp;0&nbsp;1&nbsp;0 0&nbsp;0&nbsp;0&nbsp;1&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;0&nbsp;0&nbsp;0 0&nbsp;1&nbsp;0&nbsp;0&nbsp;0&nbsp;0 1&nbsp;0&nbsp;0&nbsp;0&nbsp;0&nbsp;0      objectmatrix2d a = ascending(2,2); objectmatrix2d b = descending(2,2); objectmatrix2d _ = null; objectmatrix2d[][] parts4 = { &nbsp;&nbsp;&nbsp;{ a, _, a, _ }, &nbsp;&nbsp;&nbsp;{ _, a, _, b } }; system.out.println("\n"+make(parts4));   4&nbsp;x&nbsp;8&nbsp;matrix 1&nbsp;2&nbsp;0&nbsp;0&nbsp;1&nbsp;2&nbsp;0&nbsp;0 3&nbsp;4&nbsp;0&nbsp;0&nbsp;3&nbsp;4&nbsp;0&nbsp;0 0&nbsp;0&nbsp;1&nbsp;2&nbsp;0&nbsp;0&nbsp;3&nbsp;2 0&nbsp;0&nbsp;3&nbsp;4&nbsp;0&nbsp;0&nbsp;1&nbsp;0      objectmatrix2d[][] parts2 = { &nbsp;&nbsp;&nbsp;{ null, make(2,2,1), null }, &nbsp;&nbsp;&nbsp;{ make(4,4,2), null, make(4,3,3) }, &nbsp;&nbsp;&nbsp;{ null, make(2,3,4), null } }; system.out.println("\n"+factory2d.make(parts2));   illegalargumentexception a[0,1].cols != a[2,1].cols (2 != 3)   @throws illegalargumentexception subject to the conditions outlined above. constructs a diagonal block matrix from the given parts (the direct sum of two matrices). that is the concatenation  a 0 0 b  (the direct sum has a.rows()+b.rows() rows and a.columns()+b.columns() columns). cells are copied. new matrix which is the direct sum. constructs a diagonal block matrix from the given parts. the concatenation has the form  a 0 0 0 b 0 0 0 c  from the given parts. cells are copied. splits a block matrix into its constituent blocks; copies blocks of a matrix into the given parts. the inverse to method {@link #compose(objectmatrix2d[][])}.  all matrices of a given column within parts must have the same number of columns. all matrices of a given row within parts must have the same number of rows. otherwise an illegalargumentexception is thrown. note that nulls within parts[row,col] are an exception to this rule: they are ignored. cells are copied. example:   code matrix --&gt; parts      objectmatrix2d matrix = ... ; objectmatrix2d _ = null; objectmatrix2d a,b,c,d; a = make(2,2); b = make (4,4); c = make(4,3); d = make (2,2); objectmatrix2d[][] parts = { &nbsp;&nbsp;&nbsp;{ _, a, _ }, &nbsp;&nbsp;&nbsp;{ b, _, c }, &nbsp;&nbsp;&nbsp;{ _, d, _ } }; decompose(parts,matrix); system.out.println(&quot;\na = &quot;+a); system.out.println(&quot;\nb = &quot;+b); system.out.println(&quot;\nc = &quot;+c); system.out.println(&quot;\nd = &quot;+d);   8&nbsp;x&nbsp;9&nbsp;matrix 9&nbsp;9&nbsp;9&nbsp;9&nbsp;1&nbsp;1&nbsp;9&nbsp;9&nbsp;9 9&nbsp;9&nbsp;9&nbsp;9&nbsp;1&nbsp;1&nbsp;9&nbsp;9&nbsp;9 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 2&nbsp;2&nbsp;2&nbsp;2&nbsp;9&nbsp;9&nbsp;3&nbsp;3&nbsp;3 9&nbsp;9&nbsp;9&nbsp;9&nbsp;4&nbsp;4&nbsp;9&nbsp;9&nbsp;9 9&nbsp;9&nbsp;9&nbsp;9&nbsp;4&nbsp;4&nbsp;9&nbsp;9&nbsp;9  a = 2&nbsp;x&nbsp;2&nbsp;matrix 1&nbsp;1 1&nbsp;1 b = 4&nbsp;x&nbsp;4&nbsp;matrix 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 2&nbsp;2&nbsp;2&nbsp;2 c = 4&nbsp;x&nbsp;3&nbsp;matrix 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 3&nbsp;3&nbsp;3 d = 2&nbsp;x&nbsp;2&nbsp;matrix 4&nbsp;4 4&nbsp;4    @throws illegalargumentexception subject to the conditions outlined above. constructs a new diagonal matrix whose diagonal elements are the elements of vector. cells values are copied. the new matrix is not a view. example:  5 4 3 --> 5 0 0 0 4 0 0 0 3  new matrix. constructs a new vector consisting of the diagonal elements of a. cells values are copied. the new vector is not a view. example:  5 0 0 9 0 4 0 9 0 0 3 9 --> 5 4 3  the matrix, need not be square. new vector. constructs a matrix with the given cell values. values is required to have the form values[row][column] and have exactly the same number of columns in every row.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the values to be filled into the new matrix. @throws illegalargumentexception if for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length. construct a matrix from a one-dimensional column-major packed array, ala fortran. has the form matrix.get(row,column) == values[row + columnrows]. the values are copied. one-dimensional array of objects, packed by columns (ala fortran). the number of rows. @exception illegalargumentexception values.length must be a multiple of rows. constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value. constructs a 1d matrix of the right dynamic type. c = a||a||..||a; constructs a new matrix which is duplicated both along the row and column dimension. example:  0 1 2 3 repeat(2,3) --> 0 1 0 1 0 1 2 3 2 3 2 3 0 1 0 1 0 1 2 3 2 3 2 3  force both to have maximal shared number of rows. concatenate force both to have maximal shared number of columns. concatenate determine maximum column width of each column determine row height of each row shape of result copy determine maximum column width of each column determine row height of each row shape of result parts copy"
cern.colt.matrix.ObjectFactory3D "factory for convenient construction of 3-d matrices holding object cells. use idioms like objectfactory3d.dense.make(4,4,4) to construct dense matrices, objectfactory3d.sparse.make(4,4,4) to construct sparse matrices. if the factory is used frequently it might be useful to streamline the notation. for example by aliasing:    objectfactory3d f = objectfactory3d.dense; f.make(4,4,4); ...    a factory producing dense matrices. a factory producing sparse matrices. makes this class non instantiable, but still let's others inherit from it. constructs a matrix with the given cell values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). constructs a matrix with the given shape, each cell initialized with zero. constructs a matrix with the given shape, each cell initialized with the given value."
cern.colt.matrix.ObjectMatrix1D "abstract base class for 1-d matrices (aka vectors) holding object elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of cells (its size), which are assigned upon instance construction. elements are accessed via zero based indexes. legal indexes are of the form [0..size()-1]. any attempt to access an element at a coordinate index&lt;0 || index&gt;=size() will throw an indexoutofboundsexception. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(i)) ) and terminators are a(1) == f(get(0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; matrix = 0 1 2 3 // sum( x[i]x[i] ) matrix.aggregate(f.plus,f.square); --> 14  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(i),other.get(i)) ) and terminators are a(1) == f(get(0),other.get(0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x = 0 1 2 3 y = 0 1 2 3 // sum( x[i]y[i] ) x.aggregate(y, f.plus, f.mult); --> 14 // sum( (x[i]+y[i])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 56  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if size() != other.size(). sets all cells to the state specified by values. values is required to have the same number of cells as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != size(). assigns the result of a function to each cell; x[i] = function(x[i]). (iterates downwards from [size()-1] to [0]).  example:  // change each cell to its sine matrix = 0.5 1.5 2.5 3.5 matrix.assign(cern.jet.math.functions.sin); --> matrix == 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same size. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if size() != other.size(). assigns the result of a function to each cell; x[i] = function(x[i],y[i]).  example:  // assign x[i] = x[i]y[i] m1 = 0 1 2 3; m2 = 0 2 4 6; m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if size() != y.size(). @see cern.jet.math.functions sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the number of cells having non-zero values; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. compares the specified object with the receiver for equality. equivalent to equals(otherobj,true). the object to be compared for equality with the receiver. if the specified object is equal to the receiver. compares the specified object with the receiver for equality. returns true if and only if the specified object is also at least an objectmatrix1d, both matrices have the same size, and all corresponding pairs of cells in the two matrices are the same. in other words, two matrices are defined to be equal if they contain the same cell values in the same order. tests elements for equality or identity as specified by testforequality. when testing for equality, two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) the object to be compared for equality with the receiver. if true -> tests for equality, otherwise for identity. if the specified object is equal to the receiver. returns the matrix cell value at coordinate index. index the index of the cell. the value of the specified cell. @throws indexoutofboundsexception if index&lt;0 || index&gt;=size(). returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fills like: for (index = 0..size()-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell).  example:   0, 0, 8, 0, 7 --> indexlist = (2,4) valuelist = (8,7)  in other words, get(2)==8, get(4)==7. the list to be filled with indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate index. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. the value of the specified cell. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified size. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must also be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must also be of type sparseobjectmatrix1d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of cell the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix1d the new matrix must be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix1d the new matrix must be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate index to the specified value. index the index of the cell. value the value to be filled into the specified cell. @throws indexoutofboundsexception if index&lt;0 || index&gt;=size(). sets the matrix cell at coordinate index to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): index&lt;0 || index&gt;=size(). index the index of the cell. value the value to be filled into the specified cell. swaps each element this[i] with other[i]. @throws illegalargumentexception if size() != other.size(). constructs and returns a 1-dimensional array containing the cell values. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. the returned array values has the form  for (int i=0; i  array filled with the values of the cells. fills the cell values into the specified 1-dimensional array. the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. after this call returns the array values has the form  for (int i=0; i  @throws illegalargumentexception if values.length . returns a string representation using default formatting. @see cern.colt.matrix.objectalgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new flip view. what used to be index 0 is now index size()-1, ..., what used to be index size()-1 is now index 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. constructs and returns a new sub-range view that is a width sub matrix starting at index. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from index..index+width-1. and has view.size() == width. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view are 0 .. view.size()-1==width-1. as usual, any attempt to access a cell at other coordinates will throw an indexoutofboundsexception. index the index of the first cell. width the width of the range. @throws indexoutofboundsexception if indexsize(). new view. constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.size() == indexes.length and view.get(i) == this.get(indexes[i]). indexes can occur multiple times and can be in arbitrary order.  example:   this = (0,0,8,0,7) indexes = (0,2,4,2) --> view = (0,8,7,8)  note that modifying indexes after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. indexes the indexes of the cells that shall be visible in the new view. to indicate that all cells shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..indexes.length()-1. constructs and returns a new selection view that is a matrix holding the cells matching the given condition. applies the condition to each cell and takes only those cells where condition.apply(get(i)) yields true.  example:   // extract and view all cells with even value matrix = 0 1 2 3 matrix.viewselection( &nbsp;&nbsp;&nbsp;new objectprocedure() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(object a) { return a % 2 == 0; } &nbsp;&nbsp;&nbsp;} ); --> matrix == 0 2  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. a new view. sorts the vector into ascending order, according to the natural ordering. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.objectalgo.sorting#sort(objectmatrix1d)}. for more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.sorting}. new sorted vector (matrix) view. constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has size this.size()/stride holding cells this.get(istride) for all i = 0..size()/stride - 1. stride the step factor. @throws indexoutofboundsexception if stride . new view. applies a procedure to each cell's value. iterates downwards from [size()-1] to [0], as demonstrated by this snippet:  for (int i=size(); --i >=0;) { if (!procedure.apply(getquick(i))) return false; } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. sum( x[i]x[i] ) sum( x[i]y[i] ) sum( (x[i]+y[i])^2 ) change each cell to its sine assign x[i] = x[i]y[i] delta delta check for "all" extract and view all cells with even value"
cern.colt.matrix.ObjectMatrix1DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.matrix.ObjectMatrix2D "abstract base class for 2-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of rows and columns, which are assigned upon instance construction - the matrix's size is then rows()columns(). elements are accessed via [row,column] coordinates. legal coordinates range from [0,0] to [rows()-1,columns()-1]. any attempt to access an element at a coordinate column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() will throw an indexoutofboundsexception.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(row,column)) ) and terminators are a(1) == f(get(0,0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; 2 x 2 matrix 0 1 2 3 // sum( x[row,col]x[row,col] ) matrix.aggregate(f.plus,f.square); --> 14  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. @see cern.jet.math.functions applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(row,column),other.get(row,column)) ) and terminators are a(1) == f(get(0,0),other.get(0,0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x == 2 x 2 matrix 0 1 2 3 y == 2 x 2 matrix 0 1 2 3 // sum( x[row,col] y[row,col] ) x.aggregate(y, f.plus, f.mult); --> 14 // sum( (x[row,col] + y[row,col])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 56  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions sets all cells to the state specified by values. values is required to have the form values[row][column] and have exactly the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != rows() || for any 0 &lt;= row &lt; rows(): values[row].length != columns(). assigns the result of a function to each cell; x[row,col] = function(x[row,col]).  example:  matrix = 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 2 x 2 matrix 0 1 2 3 m2 = 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if columns() != other.columns() || rows() != other.rows() @see cern.jet.math.functions sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the number of cells having non-zero values; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. compares the specified object with the receiver for equality. equivalent to equals(otherobj,true). the object to be compared for equality with the receiver. if the specified object is equal to the receiver. compares the specified object with the receiver for equality. returns true if and only if the specified object is also at least an objectmatrix2d, both matrices have the same size, and all corresponding pairs of cells in the two matrices are the same. in other words, two matrices are defined to be equal if they contain the same cell values in the same order. tests elements for equality or identity as specified by testforequality. when testing for equality, two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) the object to be compared for equality with the receiver. if true -> tests for equality, otherwise for identity. if the specified object is equal to the receiver. returns the matrix cell value at coordinate [row,column]. row the index of the row-coordinate. column the index of the column-coordinate. the value of the specified cell. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fills like for (row = 0..rows-1) for (column = 0..columns-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell).  example:   2 x 3 matrix: 0, 0, 8 0, 7, 0 --> rowlist = (0,1) columnlist = (2,1) valuelist = (8,7)  in other words, get(0,2)==8, get(1,1)==7. the list to be filled with row indexes, can have any size. the list to be filled with column indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate [row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of rows and columns. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must also be of type sparseobjectmatrix2d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, entirelly independent of the receiver. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. a new matrix of the corresponding dynamic type. construct and returns a new 1-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix2d the new matrix must be of type denseobjectmatrix1d, if the receiver is an instance of type sparseobjectmatrix2d the new matrix must be of type sparseobjectmatrix1d, etc. the number of cells the matrix shall have. the index of the first element. the number of indexes between any two elements, i.e. index(i+1)-index(i). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [row,column] to the specified value. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. @throws indexoutofboundsexception if column&lt;0 || column&gt;=columns() || row&lt;0 || row&gt;=rows() sets the matrix cell at coordinate [row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): 0 &lt;= column &lt; columns() && 0 &lt;= row &lt; rows(). row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. constructs and returns a 2-dimensional array containing the cell values. the returned array values has the form values[row][column] and has the same number of rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. array filled with the values of the cells. returns a string representation using default formatting. @see cern.colt.matrix.objectalgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new slice view representing the rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewcolumn(0) ==> matrix1d of size 2: 1, 4   the column to fix. new slice view. @throws indexoutofboundsexception if column = columns(). @see #viewrow(int) constructs and returns a new flip view along the column axis. what used to be column 0 is now column columns()-1, ..., what used to be column columns()-1 is now column 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  columnflip ==> 2 x 3 matrix: 3, 2, 1  6, 5, 4 columnflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewrowflip() constructs and returns a new dice (transposition) view; swaps axes; example: 3 x 4 matrix --> 4 x 3 matrix. the view has both dimensions exchanged; what used to be columns become rows, what used to be rows become columns. in other words: view.get(row,column)==this.get(column,row). this is a zero-copy transposition, taking o(1), i.e. constant time. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. use idioms like result = viewdice(a).copy() to generate an independent transposed matrix.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  transpose ==> 3 x 2 matrix: 1, 4  2, 5  3, 6 transpose ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new dice view. constructs and returns a new sub-range view that is a height x width sub matrix starting at [row,column]. operations on the returned view can only be applied to the restricted range. any attempt to access coordinates not contained in the view will throw an indexoutofboundsexception.  note that the view is really just a range restriction: the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  the view contains the cells from [row,column] to [row+height-1,column+width-1], all inclusive. and has view.rows() == height; view.columns() == width;. a view's legal coordinates are again zero based, as usual. in other words, legal coordinates of the view range from [0,0] to [view.rows()-1==height-1,view.columns()-1==width-1]. as usual, any attempt to access a cell at a coordinate column&lt;0 || column&gt;=view.columns() || row&lt;0 || row&gt;=view.rows() will throw an indexoutofboundsexception. row the index of the row-coordinate. column the index of the column-coordinate. height the height of the box. width the width of the box. @throws indexoutofboundsexception if columncolumns() || rowrows() new view. constructs and returns a new slice view representing the columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. to obtain a slice view on subranges, construct a sub-ranging view (viewpart(...)), then apply this method to the sub-range view.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  viewrow(0) ==> matrix1d of size 3: 1, 2, 3   the row to fix. new slice view. @throws indexoutofboundsexception if row = rows(). @see #viewcolumn(int) constructs and returns a new flip view along the row axis. what used to be row 0 is now row rows()-1, ..., what used to be row rows()-1 is now row 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  example:   2 x 3 matrix:  1, 2, 3 4, 5, 6  rowflip ==> 2 x 3 matrix: 4, 5, 6  1, 2, 3 rowflip ==> 2 x 3 matrix:  1, 2, 3 4, 5, 6    new flip view. @see #viewcolumnflip() constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.rows() == rowindexes.length, view.columns() == columnindexes.length and view.get(i,j) == this.get(rowindexes[i],columnindexes[j]). indexes can occur multiple times and can be in arbitrary order.  example:  this = 2 x 3 matrix: 1, 2, 3 4, 5, 6 rowindexes = (0,1) columnindexes = (1,0,1,0) --> view = 2 x 4 matrix: 2, 1, 2, 1 5, 4, 5, 4  note that modifying the index arguments after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to indicate "all" rows or "all columns", simply set the respective parameter rowindexes the rows of the cells that shall be visible in the new view. to indicate that all rows shall be visible, simply set this parameter to null. columnindexes the columns of the cells that shall be visible in the new view. to indicate that all columns shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..rowindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..columnindexes.length()-1. constructs and returns a new selection view that is a matrix holding all rows matching the given condition. applies the condition to each row and takes only those row where condition.apply(viewrow(i)) yields true. to match columns, use a dice view.  example:   // extract and view all rows which have a value  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. a new view. sorts the matrix rows into ascending order, according to the natural ordering of the matrix values in the given column. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.objectalgo.sorting#sort(objectmatrix2d,int)}. for more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.sorting}. new sorted vector (matrix) view. @throws indexoutofboundsexception if column = columns(). constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has this.rows()/rowstride rows and this.columns()/columnstride columns holding cells this.get(irowstride,jcolumnstride) for all i = 0..rows()/rowstride - 1, j = 0..columns()/columnstride - 1. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the row step factor. the column step factor. new view. @throws indexoutofboundsexception if rowstride. applies a procedure to each cell's value. iterates downwards from [rows()-1,columns()-1] to [0,0], as demonstrated by this snippet:  for (int row=rows; --row >=0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(getquick(row,column))) return false; } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. sum( x[row,col]x[row,col] ) last cell already done sum( x[row,col] y[row,col] ) sum( (x[row,col] + y[row,col])^2 ) last cell already done change each cell to its sine assign x[row,col] = x[row,col]y[row,col] delta delta check for "all" extract and view all rows which have a value < threshold in the first column (representing "age") extract and view all rows with rms < threshold the rms (root-mean-square) is a measure of the average "size" of the elements of a data sequence. take all columns"
cern.colt.matrix.ObjectMatrix2DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.matrix.ObjectMatrix3D "abstract base class for 3-d matrices holding object elements. first see the package summary and javadoc tree view to get the broad picture.  a matrix has a number of slices, rows and columns, which are assigned upon instance construction - the matrix's size is then slices()rows()columns(). elements are accessed via [slice,row,column] coordinates. legal coordinates range from [0,0,0] to [slices()-1,rows()-1,columns()-1]. any attempt to access an element at a coordinate slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column() will throw an indexoutofboundsexception.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. applies a function to each cell and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(slice,row,column)) ) and terminators are a(1) == f(get(0,0,0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 // sum( x[slice,row,col]x[slice,row,col] ) matrix.aggregate(f.plus,f.square); --> 140  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell value. a function transforming the current cell value. aggregated measure. @see cern.jet.math.functions applies a function to each corresponding cell of two matrices and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(get(slice,row,column),other.get(slice,row,column)) ) and terminators are a(1) == f(get(0,0,0),other.get(0,0,0)), a(0)==null.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; x = 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 y = 2 x 2 x 2 matrix 0 1 2 3 4 5 6 7 // sum( x[slice,row,col] y[slice,row,col] ) x.aggregate(y, f.plus, f.mult); --> 140 // sum( (x[slice,row,col] + y[slice,row,col])^2 ) x.aggregate(y, f.plus, f.chain(f.square,f.plus)); --> 560  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current cell values. a function transforming the current cell values. aggregated measure. @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() @see cern.jet.math.functions sets all cells to the state specified by values. values is required to have the form values[slice][row][column] and have exactly the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. values the values to be filled into the cells. this (for convenience only). @throws illegalargumentexception if values.length != slices() || for any 0 &lt;= slice &lt; slices(): values[slice].length != rows(). @throws illegalargumentexception if for any 0 &lt;= column &lt; columns(): values[slice][row].length != columns(). assigns the result of a function to each cell; x[slice,row,col] = function(x[slice,row,col]).  example:  matrix = 1 x 2 x 2 matrix 0.5 1.5 2.5 3.5 // change each cell to its sine matrix.assign(cern.jet.math.functions.sin); --> 1 x 2 x 2 matrix 0.479426 0.997495 0.598472 -0.350783  for further examples, see the package doc. a function object taking as argument the current cell's value. this (for convenience only). @see cern.jet.math.functions replaces all cell values of the receiver with the values of another matrix. both matrices must have the same number of slices, rows and columns. if both matrices share the same cells (as is the case if they are views derived from the same matrix) and intersect in an ambiguous way, then replaces as if using an intermediate auxiliary deep copy of other. other the source matrix to copy from (may be identical to the receiver). this (for convenience only). @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() assigns the result of a function to each cell; x[row,col] = function(x[row,col],y[row,col]).  example:  // assign x[row,col] = x[row,col]y[row,col] m1 = 1 x 2 x 2 matrix 0 1 2 3 m2 = 1 x 2 x 2 matrix 0 2 4 6 m1.assign(m2, cern.jet.math.functions.pow); --> m1 == 1 x 2 x 2 matrix 1 1 16 729  for further examples, see the package doc. the secondary matrix to operate on. a function object taking as first argument the current cell's value of this, and as second argument the current cell's value of y, this (for convenience only). @throws illegalargumentexception if slices() != other.slices() || rows() != other.rows() || columns() != other.columns() @see cern.jet.math.functions sets all cells to the state specified by value. value the value to be filled into the cells. this (for convenience only). returns the number of cells having non-zero values; ignores tolerance. constructs and returns a deep copy of the receiver.  note that the returned matrix is an independent deep copy. the returned matrix is not backed by this matrix, so changes in the returned matrix are not reflected in this matrix, and vice-versa. a deep copy of the receiver. compares the specified object with the receiver for equality. equivalent to equals(otherobj,true). the object to be compared for equality with the receiver. if the specified object is equal to the receiver. compares the specified object with the receiver for equality. returns true if and only if the specified object is also at least an objectmatrix3d, both matrices have the same size, and all corresponding pairs of cells in the two matrices are the same. in other words, two matrices are defined to be equal if they contain the same cell values in the same order. tests elements for equality or identity as specified by testforequality. when testing for equality, two elements e1 and e2 are equal if (e1==null ? e2==null : e1.equals(e2)).) the object to be compared for equality with the receiver. if true -> tests for equality, otherwise for identity. if the specified object is equal to the receiver. returns the matrix cell value at coordinate [slice,row,column]. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value of the specified cell. @throws indexoutofboundsexception if slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). returns the content of this matrix if it is a wrapper; or this otherwise. override this method in wrappers. fills the coordinates and values of cells having non-zero values into the specified lists. fills into the lists, starting at index 0. after this call returns the specified lists all have a new size, the number of non-zero values.  in general, fill order is unspecified. this implementation fill like: for (slice = 0..slices-1) for (row = 0..rows-1) for (column = 0..colums-1) do ... . however, subclasses are free to us any other order, even an order that may change over time as cell values are changed. (of course, result lists indexes are guaranteed to correspond to the same cell). for an example, see {@link objectmatrix2d#getnonzeros(intarraylist,intarraylist,objectarraylist)}. the list to be filled with slice indexes, can have any size. the list to be filled with row indexes, can have any size. the list to be filled with column indexes, can have any size. the list to be filled with values, can have any size. returns the matrix cell value at coordinate [slice,row,column]. provided with invalid parameters this method may return invalid objects without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. the value at the specified coordinate. returns true if both matrices share at least one identical cell. returns true if both matrices share at least one identical cell. construct and returns a new empty matrix of the same dynamic type as the receiver, having the same number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. a new empty matrix of the same dynamic type. construct and returns a new empty matrix of the same dynamic type as the receiver, having the specified number of slices, rows and columns. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix3d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix3d, etc. in general, the new matrix should have internal parametrization as similar as possible. the number of slices the matrix shall have. the number of rows the matrix shall have. the number of columns the matrix shall have. a new empty matrix of the same dynamic type. construct and returns a new 2-d matrix of the corresponding dynamic type, sharing the same cells. for example, if the receiver is an instance of type denseobjectmatrix3d the new matrix must also be of type denseobjectmatrix2d, if the receiver is an instance of type sparseobjectmatrix3d the new matrix must also be of type sparseobjectmatrix2d, etc. the number of rows the matrix shall have. the number of columns the matrix shall have. the position of the first element. the position of the first element. the number of elements between two rows, i.e. index(i+1,j)-index(i,j). the number of elements between two columns, i.e. index(i,j+1)-index(i,j). a new matrix of the corresponding dynamic type. sets the matrix cell at coordinate [slice,row,column] to the specified value. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. @throws indexoutofboundsexception if row&lt;0 || row&gt;=rows() || slice&lt;0 || slice&gt;=slices() || column&lt;0 || column&gt;=column(). sets the matrix cell at coordinate [slice,row,column] to the specified value. provided with invalid parameters this method may access illegal indexes without throwing any exception. you should only use this method when you are absolutely sure that the coordinate is within bounds. precondition (unchecked): slice&lt;0 || slice&gt;=slices() || row&lt;0 || row&gt;=rows() || column&lt;0 || column&gt;=column(). slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. value the value to be filled into the specified cell. constructs and returns a 2-dimensional array containing the cell values. the returned array values has the form values[slice][row][column] and has the same number of slices, rows and columns as the receiver.  the values are copied. so subsequent changes in values are not reflected in the matrix, and vice-versa. array filled with the values of the cells. returns a string representation using default formatting. @see cern.colt.matrix.objectalgo.formatter constructs and returns a new view equal to the receiver. the view is a shallow clone. calls clone() and casts the result.  note that the view is not a deep copy. the returned matrix is backed by this matrix, so changes in the returned matrix are reflected in this matrix, and vice-versa.  use {@link #copy()} if you want to construct an independent deep copy rather than a new view. a new view of the receiver. constructs and returns a new 2-dimensional slice view representing the slices and rows of the given column. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the column to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if column = columns(). @see #viewslice(int) @see #viewrow(int) constructs and returns a new flip view along the column axis. what used to be column 0 is now column columns()-1, ..., what used to be column columns()-1 is now column 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewsliceflip() @see #viewrowflip() constructs and returns a new dice view; swaps dimensions (axes); example: 3 x 4 x 5 matrix --> 4 x 3 x 5 matrix. the view has dimensions exchanged; what used to be one axis is now another, in all desired permutations. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. 0 the axis that shall become axis 0 (legal values 0..2). 1 the axis that shall become axis 1 (legal values 0..2). 2 the axis that shall become axis 2 (legal values 0..2). new dice view. @throws illegalargumentexception if some of the parameters are equal or not in range 0..2. constructs and returns a new sub-range view that is a depth x height x width sub matrix starting at [slice,row,column]; equivalent to view().part(slice,row,column,depth,height,width); provided for convenience only. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. slice the index of the slice-coordinate. row the index of the row-coordinate. column the index of the column-coordinate. depth the depth of the box. height the height of the box. width the width of the box. @throws indexoutofboundsexception if sliceslices() || rowrows() || columncolumns() new view. constructs and returns a new 2-dimensional slice view representing the slices and columns of the given row. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the row to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if row = row(). @see #viewslice(int) @see #viewcolumn(int) constructs and returns a new flip view along the row axis. what used to be row 0 is now row rows()-1, ..., what used to be row rows()-1 is now row 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewsliceflip() @see #viewcolumnflip() constructs and returns a new selection view that is a matrix holding the indicated cells. there holds view.slices() == sliceindexes.length, view.rows() == rowindexes.length, view.columns() == columnindexes.length and view.get(k,i,j) == this.get(sliceindexes[k],rowindexes[i],columnindexes[j]). indexes can occur multiple times and can be in arbitrary order. for an example see {@link objectmatrix2d#viewselection(int[],int[])}.  note that modifying the index arguments after this call has returned has no effect on the view. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. sliceindexes the slices of the cells that shall be visible in the new view. to indicate that all slices shall be visible, simply set this parameter to null. rowindexes the rows of the cells that shall be visible in the new view. to indicate that all rows shall be visible, simply set this parameter to null. columnindexes the columns of the cells that shall be visible in the new view. to indicate that all columns shall be visible, simply set this parameter to null. new view. @throws indexoutofboundsexception if !(0  for any i=0..sliceindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..rowindexes.length()-1. @throws indexoutofboundsexception if !(0  for any i=0..columnindexes.length()-1. constructs and returns a new selection view that is a matrix holding all slices matching the given condition. applies the condition to each slice and takes only those where condition.apply(viewslice(i)) yields true. to match rows or columns, use a dice view.  example:   // extract and view all slices which have an aggregate sum > 1000 matrix.viewselection( &nbsp;&nbsp;&nbsp;new objectmatrix2dprocedure() { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public final boolean apply(objectmatrix2d m) { return m.zsum > 1000; } &nbsp;&nbsp;&nbsp;} );  for further examples, see the package doc. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. condition the condition to be matched. new view. construct and returns a new selection view. the offsets of the visible elements. the offsets of the visible elements. the offsets of the visible elements. a new view. constructs and returns a new 2-dimensional slice view representing the rows and columns of the given slice. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa.  to obtain a slice view on subranges, construct a sub-ranging view (view().part(...)), then apply this method to the sub-range view. to obtain 1-dimensional views, apply this method, then apply another slice view (methods viewcolumn, viewrow) on the intermediate 2-dimensional view. to obtain 1-dimensional views on subranges, apply both steps. the index of the slice to fix. new 2-dimensional slice view. @throws indexoutofboundsexception if slice = slices(). @see #viewrow(int) @see #viewcolumn(int) constructs and returns a new flip view along the slice axis. what used to be slice 0 is now slice slices()-1, ..., what used to be slice slices()-1 is now slice 0. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. new flip view. @see #viewrowflip() @see #viewcolumnflip() sorts the matrix slices into ascending order, according to the natural ordering of the matrix values in the given [row,column] position. this sort is guaranteed to be stable. for further information, see {@link cern.colt.matrix.objectalgo.sorting#sort(objectmatrix3d,int,int)}. for more advanced sorting functionality, see {@link cern.colt.matrix.objectalgo.sorting}. new sorted vector (matrix) view. @throws indexoutofboundsexception if row = rows() || column = columns(). constructs and returns a new stride view which is a sub matrix consisting of every i-th cell. more specifically, the view has this.slices()/slicestride slices and this.rows()/rowstride rows and this.columns()/columnstride columns holding cells this.get(kslicestride,irowstride,jcolumnstride) for all k = 0..slices()/slicestride - 1, i = 0..rows()/rowstride - 1, j = 0..columns()/columnstride - 1. the returned view is backed by this matrix, so changes in the returned view are reflected in this matrix, and vice-versa. the slice step factor. the row step factor. the column step factor. new view. @throws indexoutofboundsexception if slicestride. applies a procedure to each cell's value. iterates downwards from [slices()-1,rows()-1,columns()-1] to [0,0,0], as demonstrated by this snippet:  for (int slice=slices; --slice >=0;) { for (int row=rows; --row >= 0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(get(slice,row,column))) return false; } } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as argument the current cell's value. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. applies a procedure to each cell's coordinate. iterates downwards from [slices()-1,rows()-1,columns()-1] to [0,0,0], as demonstrated by this snippet:  for (int slice=slices; --slice >=0;) { for (int row=rows; --row >= 0;) { for (int column=columns; --column >= 0;) { if (!procedure.apply(slice,row,column)) return false; } } } return true;  note that an implementation may use more efficient techniques, but must not use any other order. a procedure object taking as first argument the current slice, as second argument the current row, and as third argument the current column. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. sum( x[slice,row,col]x[slice,row,col] ) last cell already done sum( x[slice,row,col] y[slice,row,col] ) sum( (x[slice,row,col] + y[slice,row,col])^2 ) last cell already done change each cell to its sine assign x[row,col] = x[row,col]y[row,col] delta delta int sliceoffset = index(0,0,column); int sliceoffset = index(0,row,0); check for "all" extract and view all slices which have an aggregate sum > 1000 take all rows and columns int sliceoffset = index(slice,0,0);"
cern.colt.matrix.ObjectMatrix3DProcedure "interface that represents a condition or procedure object: takes a single argument and returns a boolean value. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure. applies a procedure to an argument. optionally can return a boolean flag to inform the object calling the procedure. example: foreach() methods often use procedure objects. to signal to a foreach() method whether iteration should continue normally or terminate (because for example a matching element has been found), a procedure can return false to indicate termination and true to indicate continuation. element passed to the procedure. flag to inform the object calling the procedure."
cern.colt.Partitioning "given some interval boundaries, partitions arrays such that all elements falling into an interval are placed next to each other.  the algorithms partition arrays into two or more intervals. they distinguish between synchronously partitioning either one, two or three arrays. they further come in templated versions, either partitioning int[] arrays or double[] arrays.  you may want to start out reading about the simplest case: partitioning one int[] array into two intervals. to do so, read {@link #partition(int[],int,int,int)}. next, building upon that foundation comes a method partitioning int[] arrays into multiple intervals. see {@link #partition(int[],int,int,int[],int,int,int[])} for related documentation.  all other methods are no different than the one's you now already understand, except that they operate on slightly different data types.  performance  partitioning into two intervals is o( n ). partitioning into k intervals is o( n log(k)). constants factors are minimized. no temporary memory is allocated; partitioning is in-place. @see cern.colt.matrix.doublealgo.partitioning makes this class non instantiable, but still let's others inherit from it. finds the given key "a" within some generic data using the binary search algorithm. the index of the key to search for. the leftmost search position, inclusive. the rightmost search position, inclusive. the comparator determining the order of the generic data. takes as first argument the index a within the generic splitters s. takes as second argument the index b within the generic data g. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. same as {@link #dualpartition(int[],int[],int,int,int[],int,int,int[])} except that it synchronously partitions double[] rather than int[] arrays. same as {@link #dualpartition(int[],int[],int,int,int)} except that it synchronously partitions double[] rather than int[] arrays. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method synchronously partitions two arrays at the same time; both arrays are partially sorted according to the elements of the primary array. in other words, each time an element in the primary array is moved from index a to b, the correspoding element within the secondary array is also moved from index a to b.  use cases:  image having a large list of 2-dimensional points. if memory consumption and performance matter, it is a good idea to physically lay them out as two 1-dimensional arrays (using something like point2d objects would be prohibitively expensive, both in terms of time and space). now imagine wanting to histogram the points. we may want to partially sort the points by x-coordinate into intervals. this method efficiently does the job.  performance:  same as for single-partition methods. same as {@link #partition(int[],int,int,int)} except that this method synchronously partitions two arrays at the same time; both arrays are partially sorted according to the elements of the primary array. in other words, each time an element in the primary array is moved from index a to b, the correspoding element within the secondary array is also moved from index a to b.  performance:  same as for single-partition methods. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that it generically partitions arbitrary shaped data (for example matrices or multiple arrays) rather than int[] arrays.  this method operates on arbitrary shaped data and arbitrary shaped splitters. in fact, it has no idea what kind of data by what kind of splitters it is partitioning. comparisons and swapping are delegated to same as {@link #partition(int[],int,int,int)} except that it generically partitions arbitrary shaped data (for example matrices or multiple arrays) rather than int[] arrays. returns the index of the median of the three indexed elements. returns the index of the median of the three indexed elements. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that it partitions double[] rather than int[] arrays. same as {@link #partition(int[],int,int,int)} except that it partitions double[] rather than int[] arrays. partitions (partially sorts) the given list such that all elements falling into some intervals are placed next to each other. returns the indexes of elements delimiting intervals.  example:  list = (7, 4, 5, 50, 6, 4, 3, 6), splitters = (5, 10, 30) defines the three intervals [-infinity,5), [5,10), [10,30). lets define to sort the entire list (from=0, to=7) using all splitters (splitfrom==0, splitto=2).  the method modifies the list to be list = (4, 4, 3, 6, 7, 5, 6, 50) and returns the splitindexes = (2, 6, 6). in other words,  all values list[0..2] fall into [-infinity,5). all values list[3..6] fall into [5,10). all values list[7..6] fall into [10,30), i.e. no elements, since 7>6. all values list[7 .. 7=list.length-1] fall into [30,infinity]. in general, all values list[splitindexes[j-1]+1 .. splitindexes[j]] fall into interval j.  as can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other. note that within an interval, elements are entirelly unsorted. they are only sorted across interval boundaries. in particular, this partitioning algorithm is not stable: the relative order of elements is not preserved (producing a stable algorithm would require no more than minor modifications to method partition(int[],int,int,int)).  more formally, this method guarantees that upon return for all j = splitfrom .. splitto there holds: for all i = splitindexes[j-1]+1 .. splitindexes[j]: splitters[j-1] .  performance:  let n=to-from+1 be the number of elements to be partitioned. let k=splitto-splitfrom+1 be the number of splitter elements. then we have the following time complexities  worst case: o( n log(k) ). average case: o( n log(k) ). best case: o( n ). in general, the more uniform (skewed) the data is spread across intervals, the more performance approaches the worst (best) case. if no elements fall into the given intervals, running time is linear.  no temporary memory is allocated; the sort is in-place.  implementation:  the algorithm can be seen as a bentley/mcilroy quicksort where swapping and insertion sort are omitted. it is designed to detect and take advantage of skew while maintaining good performance in the uniform case. the list to be partially sorted. the index of the first element within list to be considered. the index of the last element within list to be considered. the method considers the elements list[from] .. list[to]. the values at which the list shall be split into intervals. must be sorted ascending and must not contain multiple identical values. these preconditions are not checked; be sure that they are met. the index of the first splitter element to be considered. the index of the last splitter element to be considered. the method considers the splitter elements splitters[splitfrom] .. splitters[splitto]. a list into which this method fills the indexes of elements delimiting intervals. upon return splitindexes[splitfrom..splitto] will be set accordingly. therefore, must satisfy splitindexes.length > splitto.  tip: normally you will have splitindexes.length == splitters.length as well as from==0, to==list.length-1 and splitfrom==0, splitto==splitters.length-1. @see cern.colt.arrays @see cern.colt.genericsorting @see java.util.arrays if (splitto-splitfrom+1  splitto || list[i] > key) i = -i-1; // not found medianindex = i; } int low = splitfrom; int high = splitto; int comparison; int mid=0; while (low  0) high = mid - 1; else break; //return mid; // key found } medianindex = mid; if (low > high) medianindex = -(medianindex + 1); // key not found. //} steps += to-from+1; int head = from; for (int i=from-1; ++i example:  list = (7, 4, 5, 50, 6, 4, 3, 6), splitter = 5 defines the two intervals [-infinity,5), [5,+infinity].  the method modifies the list to be list = (4, 4, 3, 50, 6, 7, 5, 6) and returns the split index 2. in other words,  all values list[0..2] fall into [-infinity,5). all values list[3=2+1 .. 7=list.length-1] fall into [5,+infinity].  as can be seen, the list is partially sorted such that values falling into a certain interval are placed next to each other. note that within an interval, elements are entirelly unsorted. they are only sorted across interval boundaries. in particular, this partitioning algorithm is not stable.  more formally, this method guarantees that upon return there holds:  for all i = from .. returnvalue: list[i]  and for all i = returnvalue+1 .. list.length-1: !(list[i] .   performance:  let n=to-from+1 be the number of elements to be partially sorted. then the time complexity is o( n ). no temporary memory is allocated; the sort is in-place.  the list to be partially sorted. the index of the first element within list to be considered. the index of the last element within list to be considered. the method considers the elements list[from] .. list[to]. the value at which the list shall be split. index of the largest element falling into the interval [-infinity,splitter), as seen after partitioning. system.out.println(); if (from= last) return first-1; int tmp = list[first]; list[first] = list[last]; list[last] = tmp; } system.out.println("splitter="+splitter); system.out.println("before="+new intarraylist(list)); int head = from; int trail = to; int element; while (head head && list[trail] >= splitter); if (head != trail) { element = list[head]; list[head] = list[trail]; list[trail] = element; } head++; trail--; system.out.println("after ="+new intarraylist(list)+", head="+head); } //system.out.println("splitter="+splitter); //system.out.println("before="+new intarraylist(list)); to++; //int head = from; int element; //int oldhead; while (--to >= from) { element = list[to]; if (element object[] rather than int[] arrays. same as {@link #partition(int[],int,int,int)} except that it synchronously partitions the objects of the given list by the order of the given comparator. equivalent to partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitindexes.elements()). equivalent to partition(list.elements(), from, to, splitters.elements(), 0, splitters.size()-1, splitindexes.elements()). same as {@link #triplepartition(int[],int[],int[],int,int,int[],int,int,int[])} except that it synchronously partitions double[] rather than int[] arrays. same as {@link #triplepartition(int[],int[],int[],int,int,int)} except that it synchronously partitions double[] rather than int[] arrays. same as {@link #partition(int[],int,int,int[],int,int,int[])} except that this method synchronously partitions three arrays at the same time; all three arrays are partially sorted according to the elements of the primary array. in other words, each time an element in the primary array is moved from index a to b, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index a to b.  use cases:  image having a large list of 3-dimensional points. if memory consumption and performance matter, it is a good idea to physically lay them out as three 1-dimensional arrays (using something like point3d objects would be prohibitively expensive, both in terms of time and space). now imagine wanting to histogram the points. we may want to partially sort the points by x-coordinate into intervals. this method efficiently does the job.  performance:  same as for single-partition methods. same as {@link #partition(int[],int,int,int)} except that this method synchronously partitions three arrays at the same time; all three arrays are partially sorted according to the elements of the primary array. in other words, each time an element in the primary array is moved from index a to b, the correspoding element within the secondary array as well as the corresponding element within the tertiary array are also moved from index a to b.  performance:  same as for single-partition methods. benchmark only key found key not found. int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. int key = list[m]; on short lists linear search is quicker not found else { return mid; // key found key not found. } not found not found, one past the end system.out.println("medianindex="+medianindex); partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half system.out.println("1.recursive: from="+from+", to="+splitindex+", splitfrom="+splitfrom+", splitto="+(medianindex-1)); recursively partition right half system.out.println("2.recursive: from="+(splitindex+1)+", to="+to+", splitfrom="+(medianindex+1)+", splitto="+splitto); system.out.println("back tracking\n\n"); returns index of last element  template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from] int, double --> template type dependent nothing to do all bins are empty choose a partition (pivot) index, m ideally, the pivot should be the median, because a median splits a list into two equal sized sublists. however, computing the median is expensive, so we use an approximation. we don't really have a choice we do have a choice small arrays, middle element big arrays, pseudomedian of 9 mid-size, pseudomedian of 3 find the splitter closest to the pivot, i.e. the splitter that best splits the list into two equal sized sublists. not found not found, one past the end partition the list according to the splitter, i.e. establish invariant: list[i] = splitter are empty recursively partition left half recursively partition right half int, double --> template type dependent swap x[i] with x[from]"
cern.colt.PersistentObject "this empty class is the common root for all persistent capable classes. if this class inherits from java.lang.object then all subclasses are serializable with the standard java serialization mechanism. if this class inherits from com.objy.db.app.ooobj then all subclasses are additionally serializable with the objectivity odbms persistance mechanism. thus, by modifying the inheritance of this class the entire tree of subclasses can be switched to objectivity compatibility (and back) with minimum effort. not yet commented. returns a copy of the receiver. this default implementation does not nothing except making the otherwise protected clone method public. copy of the receiver. should never happen since we are cloneable"
cern.colt.Sorting "quicksorts, mergesorts and binary searches; complements java.util.arrays. contains, for example, the quicksort on comparators and comparables, which are still missing in java.util.arrays of jdk 1.2. also provides mergesorts for types not supported in java.util.arrays, as well as a couple of other methods for primitive arrays. the quicksorts and mergesorts are the jdk 1.2 v1.26 algorithms, modified as necessary. @see cern.colt.genericsorting @see cern.colt.matrix.doublealgo.sorting @see java.util.arrays makes this class non instantiable, but still let's others inherit from it. searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays // even for very short lists (0,1,2,3 elems) this is only 10% faster while (frommust be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays searches the list for the specified value using the binary search algorithm. the list must be sorted into ascending order according to the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). if the list is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which instance will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. the comparator by which the list is sorted. @throws classcastexception if the list contains elements that are not mutually comparable using the specified comparator. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays @see java.util.comparator searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays generically searches the list for the specified value using the binary search algorithm. the list must must be sorted (as by the sort method) prior to making this call. if it is not sorted, the results are undefined: in particular, the call may enter an infinite loop. if the list contains multiple elements equal to the specified key, there is no guarantee which of the multiple elements will be found. the list to be searched. the value to be searched for. the leftmost search position, inclusive. the rightmost search position, inclusive. of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). the insertion point is defined as the the point at which the value would be inserted into the list: the index of the first element greater than the key, or list.length, if all elements in the list are less than the specified key. note that this guarantees that the return value will be &gt;= 0 if and only if the key is found. @see java.util.arrays returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. returns the index of the median of the three indexed chars. sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator the sort is done in three phases to avoid the expense of using nan and -0.0 aware comparisons during the main sort. preprocessing phase: move any nan's to end of array, count the number of -0.0's, and turn them into 0.0's. the sort is done in three phases to avoid the expense of using nan and -0.0 aware comparisons during the main sort. preprocessing phase: move any nan's to end of array, count the number of -0.0's, and turn them into 0.0's. sorts the specified range of the specified array of elements. this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. all elements in this range must implement the comparable interface. furthermore, all elements in this range must be mutually comparable (that is, e1.compareto(e2) must not throw a classcastexception for any elements e1 and e2 in the array). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. sorts the specified range of the receiver into ascending order, according to the natural ordering of its elements. all elements in this range must implement the comparable interface. furthermore, all elements in this range must be mutually comparable (that is, e1.compareto(e2) must not throw a classcastexception for any elements e1 and e2 in the array). the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length sorts the specified range of the specified array according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified array according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). the sorting algorithm is a tuned quicksort, adapted from jon l. bentley and m. douglas mcilroy's "engineering a sort function", software-practice and experience, vol. 23(11) p. 1249-1265 (november 1993). this algorithm offers nlog(n) performance on many data sets that cause other quicksorts to degrade to quadratic performance. the array to be sorted. the comparator to determine the order of the receiver. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified range of the specified array of elements according to the order induced by the specified comparator. all elements in the range must be mutually comparable by the specified comparator (that is, c.compare(e1, e2) must not throw a classcastexception for any elements e1 and e2 in the range). this sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort. the sorting algorithm is a modified mergesort (in which the merge is omitted if the highest element in the low sublist is less than the lowest element in the high sublist). this algorithm offers guaranteed nlog(n) performance, and can approach linear performance on nearly sorted lists. the array to be sorted. the index of the first element (inclusive) to be sorted. the index of the last element (exclusive) to be sorted. the comparator to determine the order of the array. @throws classcastexception if the array contains elements that are not mutually comparable using the specified comparator. @throws illegalargumentexception if fromindex &gt; toindex @throws arrayindexoutofboundsexception if fromindex &lt; 0 or toindex &gt; a.length @see comparator sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. sorts the specified sub-array of chars into ascending order. check that fromindex and toindex are in range, and throw an appropriate exception if they aren't. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a] with x[b]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. swaps x[a .. (a+n-1)] with x[b .. (b+n-1)]. key found key not found. key found key not found. key found key not found. key found key not found. key found key not found. even for very short lists (0,1,2,3 elems) this is only 10% faster key found key not found. key found key not found. key found key not found. key found key not found. rotate(array, firstcut, middle, secondcut); is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are "static private") speedup = 1.7 begin inline end inline insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest insertion sort on smallest arrays recursively sort halves of dest into src if list is already sorted, just copy from src to dest. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves (now in src) into dest main sort phase: mergesort everything but the nan's postprocessing phase: change 0.0's to -0.0's as required posn of any zero j is now one less than the index of the first zero main sort phase: mergesort everything but the nan's postprocessing phase: change 0.0's to -0.0's as required posn of any zero j is now one less than the index of the first zero insertion sort on smallest arrays recursively sort halves if list is already sorted, nothing left to do. this is an optimization that results in faster sorts for nearly ordered lists. merge sorted halves jal.int.sorting.inplace_merge(a, fromindex, mid, toindex); insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements insertion sort on smallest arrays choose a partition element, v small arrays, middle element big arrays, pseudomedian of 9 mid-size, med of 3 establish invariant: v (v) v swap partition elements back to middle recursively sort non-partition-elements"
cern.colt.Swapper "interface for an object that knows how to swap elements at two positions (a,b). @see cern.colt.genericsorting swaps the generic data g[a] with g[b]."
cern.colt.Timer "a handy stopwatch for benchmarking. like a real stop watch used on ancient running tracks you can start the watch, stop it, start it again, stop it again, display the elapsed time and reset the watch. constructs a new timer, initially not started. use start() to start the timer. prints the elapsed time on system.out this (for convenience only). same as seconds(). returns the elapsed time in milli seconds; does not stop the timer, if started. t = this - other; constructs and returns a new timer which is the difference of the receiver and the other timer. the new timer is not started. the timer to subtract. new timer. returns the elapsed time in minutes; does not stop the timer, if started. t = this + other; constructs and returns a new timer which is the sum of the receiver and the other timer. the new timer is not started. the timer to add. new timer. resets the timer. this (for convenience only). returns the elapsed time in seconds; does not stop the timer, if started. starts the timer. this (for convenience only). stops the timer. you can start it again later, if necessary. this (for convenience only). shows how to use a timer in convenient ways. returns a string representation of the receiver. we are started benchmark this piece do something we do not want to benchmark benchmark another piece and add to last benchmark benchmark yet another piece independently set timer to zero"
cern.colt.Version "information about the current release. use this class to distinguish releases and base runtime decisions upon. versions are of the form major.minor.micro.build, e.g. 1.0.0.52  you can most easily display version info by running java cern.colt.version. not yet commented. returns all version information as string. returns the time this release was build; for example "tue apr 11 11:50:39 cest 2000". returns the build version of this release. returns the major version of this release. returns the micro version of this release. returns the minor version of this release.  prints asstring on system.out. ignored. returns the major version of this release; for example version 1.2.3 returns 1. if (getpackage()==null) return numbers; string s = getpackage().getimplementationversion(); if (s==null) return numbers; int k = s.indexof('('); s = s.substring(0,k); s = s.trim(); //s = s.replace('.', ' '); //s = violinstrings.strings.stripblanks(s); //s = violinstrings.strings.translate(s, ".", " "); string[] words = s.split("."); // requires jdk 1.4.x for (int i=0; i<w; i++) { numbers[i] = integer.parseint(words[i]); //numbers[i] = integer.parseint(violinstrings.strings.word(s, i)); //system.out.println(numbers[i]); } return numbers; string s = "1.2.3.56 (tue apr 11 11:50:39 cest 2000)"; int[] numbers = new int[w]; s = s.replace('.', ' '); s = violinstrings.strings.stripblanks(s); s = violinstrings.strings.translate(s, ".", " "); requires jdk 1.4.x numbers[i] = integer.parseint(violinstrings.strings.word(s, i)); system.out.println(numbers[i]);"
cern.jet.math.Algebraic "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Arithmetic "arithmetic functions. makes this class non instantiable, but still let's others inherit from it. efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k". the binomial coefficient is defined as (n n-1 ... n-k+1 ) / ( 1 2 ... k ).  k: 0. k==0: 1. k==1: n. else: (n n-1 ... n-k+1 ) / ( 1 2 ... k ).  binomial coefficient. efficiently returns the binomial coefficient, often also referred to as "n over k" or "n choose k". the binomial coefficient is defined as  k: 0. k==0 || k==n: 1. k==1 || k==n-1: n. else: (n n-1 ... n-k+1 ) / ( 1 2 ... k ).  binomial coefficient. returns the smallest long &gt;= value. examples: 1.0 -> 1, 1.2 -> 2, 1.9 -> 2. this method is safer than using (long) math.ceil(value), because of possible rounding error. evaluates the series of chebyshev polynomials ti at argument x/2. the series is given by  n-1 - ' y = > coef[i] t (x/2) - i i=0  coefficients are stored in reverse order, i.e. the zero order term is last in the array. note n is the number of coefficients, not the order.  if coefficients are for the interval a to b, x must have been transformed to x -> 2(2x - b - a)/(b-a) before entering the routine. this maps x from (a, b) to (-1, 1), over which the chebyshev polynomials are defined.  if the coefficients are for the inverted interval, in which (a, b) is mapped to (1/b, 1/a), the transformation required is x -> 2(2ab/x - b - a)/(b-a). if b is infinity, this becomes x -> 4a/x - 1.  speed:  taking advantage of the recurrence properties of the chebyshev polynomials, the routine requires one more addition per loop than evaluating a nested polynomial of the same degree. argument to the polynomial. the coefficients of the polynomial. the number of coefficients. returns the factorial of the argument. returns the factorial of the argument. instantly returns the factorial k!. must hold k &gt;= 0. returns the largest long &lt;= value. examples:  1.0 -> 1, 1.2 -> 1, 1.9 -> 1  2.0 -> 2, 2.2 -> 2, 2.9 -> 2  this method is safer than using (long) math.floor(value), because of possible rounding error. returns logbasevalue. returns log10value. returns log2value. returns log(k!). tries to avoid overflows. for k simply looks up a table in o(1). for k>=30 uses stirlings approximation. must hold k &gt;= 0. instantly returns the factorial k!. must hold k &gt;= 0 && k &lt; 21. returns the stirlingcorrection.  correction term of the stirling approximation for log(k!) (series in 1/k, or table values for small k) with int parameter k.   log k! = (k + 1/2)log(k + 1) - (k + 1) + (1/2)log(2pi) + stirlingcorrection(k + 1)  log k! = (k + 1/2)log(k) - k + (1/2)log(2pi) + stirlingcorrection(k)  equivalent to math.round(binomial(n,k)). for method stirlingcorrection(...) for method logfactorial(...) log(k!) for k = 0, ..., 29 k! for k = 0, ..., 20 k! for k = 21, ..., 170 binomial(n,k) = (n n-1 ... n-k+1 ) / ( 1 2 ... k ) try quick version and see whether we get numeric overflows. factorial(..) is o(1); requires no loop; only a table lookup. if (n! < inf && k! < inf) no numeric overflow? now this is completely safe and accurate quicker binomial(n,k) = (n n-1 ... n-k+1 ) / ( 1 2 ... k ) 1.0 / math.log(10) == 0.43429448190325176 1.0 / math.log(2) == 1.4426950408889634 +1/12 -1/360 +1/1260 -1/1680"
cern.jet.math.Bessel "bessel and airy functions. coefficients for methods i0, i0e chebyshev coefficients for exp(-x) i0(x) in the interval [0,8]. lim(x->0){ exp(-x) i0(x) } = 1. chebyshev coefficients for exp(-x) sqrt(x) i0(x) in the inverted interval [8,infinity]. lim(x->inf){ exp(-x) sqrt(x) i0(x) } = 1/sqrt(2pi). coefficients for methods i1, i1e chebyshev coefficients for exp(-x) i1(x) / x in the interval [0,8]. lim(x->0){ exp(-x) i1(x) / x } = 1/2. chebyshev coefficients for exp(-x) sqrt(x) i1(x) in the inverted interval [8,infinity]. lim(x->inf){ exp(-x) sqrt(x) i1(x) } = 1/sqrt(2pi). coefficients for methods k0, k0e chebyshev coefficients for k0(x) + log(x/2) i0(x) in the interval [0,2]. the odd order coefficients are all zero; only the even order coefficients are listed. lim(x->0){ k0(x) + log(x/2) i0(x) } = -eul. chebyshev coefficients for exp(x) sqrt(x) k0(x) in the inverted interval [2,infinity]. lim(x->inf){ exp(x) sqrt(x) k0(x) } = sqrt(pi/2). coefficients for methods k1, k1e chebyshev coefficients for x(k1(x) - log(x/2) i1(x)) in the interval [0,2]. lim(x->0){ x(k1(x) - log(x/2) i1(x)) } = 1. chebyshev coefficients for exp(x) sqrt(x) k1(x) in the interval [2,infinity]. lim(x->inf){ exp(x) sqrt(x) k1(x) } = sqrt(pi/2). makes this class non instantiable, but still let's others inherit from it. returns the modified bessel function of order 0 of the argument.  the function is defined as i0(x) = j0( ix ).  the range is partitioned into the two intervals [0,8] and (8, infinity). chebyshev polynomial expansions are employed in each interval. the value to compute the bessel function of. returns the exponentially scaled modified bessel function of order 0 of the argument.  the function is defined as i0e(x) = exp(-|x|) j0( ix ). the value to compute the bessel function of. returns the modified bessel function of order 1 of the argument.  the function is defined as i1(x) = -i j1( ix ).  the range is partitioned into the two intervals [0,8] and (8, infinity). chebyshev polynomial expansions are employed in each interval. the value to compute the bessel function of. returns the exponentially scaled modified bessel function of order 1 of the argument.  the function is defined as i1(x) = -i exp(-|x|) j1( ix ). the value to compute the bessel function of. returns the bessel function of the first kind of order 0 of the argument. the value to compute the bessel function of. returns the bessel function of the first kind of order 1 of the argument. the value to compute the bessel function of. returns the bessel function of the first kind of order n of the argument. the order of the bessel function. the value to compute the bessel function of. returns the modified bessel function of the third kind of order 0 of the argument.  the range is partitioned into the two intervals [0,8] and (8, infinity). chebyshev polynomial expansions are employed in each interval. the value to compute the bessel function of. returns the exponentially scaled modified bessel function of the third kind of order 0 of the argument. the value to compute the bessel function of. returns the modified bessel function of the third kind of order 1 of the argument.  the range is partitioned into the two intervals [0,2] and (2, infinity). chebyshev polynomial expansions are employed in each interval. the value to compute the bessel function of. returns the exponentially scaled modified bessel function of the third kind of order 1 of the argument.  k1e(x) = exp(x) k1(x). the value to compute the bessel function of. returns the modified bessel function of the third kind of order nn of the argument.  the range is partitioned into the two intervals [0,9.55] and (9.55, infinity). an ascending power series is used in the low range, and an asymptotic expansion in the high range. the order of the bessel function. the value to compute the bessel function of. algorithm for kn. n-1 -n - (n-k-1)! 2 k k (x) = 0.5 (x/2) > -------- (-x /4) n - k! k=0 inf. 2 k n n - (x /4) + (-1) 0.5(x/2) > {p(k+1) + p(n+k+1) - 2log(x/2)} --------- - k! (n+k)! k=0 where p(m) is the psi function: p(1) = -eul and m-1 - p(m) = -eul + > 1/k - k=1 for large x, 2 2 2 u-1 (u-1 )(u-3 ) k (z) = sqrt(pi/2z) exp(-z) { 1 + ------- + ------------ + ...} v 1 2 1! (8z) 2! (8z) asymptotically, where 2 u = 4 v . compute factorial of n and psi(n) asymptotic expansion for kn(x) converges to 1.4e-17 for x > 18.4 returns the bessel function of the second kind of order 0 of the argument. the value to compute the bessel function of. returns the bessel function of the second kind of order 1 of the argument. the value to compute the bessel function of. returns the bessel function of the second kind of order n of the argument. the order of the bessel function. the value to compute the bessel function of."
cern.jet.math.Complex "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Constants "defines some useful constants. machine constants machep = 1.38777878078144567553e-17 2-56 maxlog = 8.8029691931113054295988e1 log(2127) minlog = -8.872283911167299960540e1 log(2-128) maxnum = 1.701411834604692317316873e38 2127 for ieee arithmetic (ibmpc): machep = 1.11022302462515654042e-16 2-53 maxlog = 7.09782712893383996843e2 log(21024) minlog = -7.08396418532264106224e2 log(2-1022) maxnum = 1.7976931348623158e308 21024 the global symbols for mathematical constants are pi = 3.14159265358979323846 pi pio2 = 1.57079632679489661923 pi/2 pio4 = 7.85398163397448309616e-1 pi/4 sqrt2 = 1.41421356237309504880 sqrt(2) sqrth = 7.07106781186547524401e-1 sqrt(2)/2 log2e = 1.4426950408889634073599 1/log(2) sq2opi = 7.9788456080286535587989e-1 sqrt( 2/pi ) loge2 = 6.93147180559945309417e-1 log(2) logsq2 = 3.46573590279972654709e-1 log(2)/2 thpio4 = 2.35619449019234492885 3pi/4 twoopi = 6.36619772367581343075535e-1 2/pi makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Elliptic "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Exponential "exponential functions. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.ExponentialIntegral "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Functions "function objects to be passed to generic methods. contains the functions of {@link java.lang.math} as function objects, as well as a few more basic functions. function objects conveniently allow to express arbitrary functions in a generic manner. essentially, a function object is an object that can perform a function on some arguments. it has a minimal interface: a method apply that takes the arguments, computes something and returns some result value. function objects are comparable to function pointers in c used for call-backs. unary functions are of type {@link cern.colt.function.doublefunction}, binary functions of type {@link cern.colt.function.doubledoublefunction}. all can be retrieved via public static final variables named after the function. unary predicates are of type {@link cern.colt.function.doubleprocedure}, binary predicates of type {@link cern.colt.function.doubledoubleprocedure}. all can be retrieved via public static final variables named isxxx.  binary functions and predicates also exist as unary functions with the second argument being fixed to a constant. these are generated and retrieved via factory methods (again with the same name as the function). example:  functions.pow gives the function ab. functions.pow.apply(2,3)==8. functions.pow(3) gives the function a3. functions.pow(3).apply(2)==8.  more general, any binary function can be made an unary functions by fixing either the first or the second argument. see methods {@link #bindarg1(doubledoublefunction,double)} and {@link #bindarg2(doubledoublefunction,double)}. the order of arguments can be swapped so that the first argument becomes the second and vice-versa. see method {@link #swapargs(doubledoublefunction)}. example:  functions.pow gives the function ab. functions.bindarg2(functions.pow,3) gives the function x3. functions.bindarg1(functions.pow,3) gives the function 3x. functions.swapargs(functions.pow) gives the function ba.   even more general, functions can be chained (composed, assembled). assume we have two unary functions g and h. the unary function g(h(a)) applying both in sequence can be generated via {@link #chain(doublefunction,doublefunction)}:  functions.chain(g,h);  assume further we have a binary function f. the binary function g(f(a,b)) can be generated via {@link #chain(doublefunction,doubledoublefunction)}:  functions.chain(g,f);  the binary function f(g(a),h(b)) can be generated via {@link #chain(doubledoublefunction,doublefunction,doublefunction)}:  functions.chain(f,g,h);  arbitrarily complex functions can be composed from these building blocks. for example sin(a) + cos2(b) can be specified as follows:  chain(plus,sin,chain(square,cos));  or, of course, as  new doubledoublefunction() { &nbsp;&nbsp;&nbsp;public final double apply(double a, double b) { return math.sin(a) + math.pow(math.cos(b),2); } }   for aliasing see {@link #functions}. try this    // should yield 1.4399560356056456 in all cases double a = 0.5; double b = 0.2; double v = math.sin(a) + math.pow(math.cos(b),2); system.out.println(v); functions f = functions.functions; doubledoublefunction f = f.chain(f.plus,f.sin,f.chain(f.square,f.cos)); system.out.println(f.apply(a,b)); doubledoublefunction g = new doubledoublefunction() { &nbsp;&nbsp;&nbsp;public double apply(double a, double b) { return math.sin(a) + math.pow(math.cos(b),2); } }; system.out.println(g.apply(a,b));     performance surprise. using modern non-adaptive jits such as sunjdk 1.2.2 (java -classic) there seems to be no or only moderate performance penalty in using function objects in a loop over traditional code in a loop. for complex nested function objects (e.g. f.chain(f.abs,f.chain(f.plus,f.sin,f.chain(f.square,f.cos)))) the penalty is zero, for trivial functions (e.g. f.plus) the penalty is often acceptable.     iteration performance [million function evaluations per second] pentium pro 200 mhz, sunjdk 1.2.2, nt, java -classic,    &nbsp;   30000000 iterations   3000000 iterations (10 times less) &nbsp;    f.plus a+b  f.chain(f.abs,f.chain(f.plus,f.sin,f.chain(f.square,f.cos)))  math.abs(math.sin(a) + math.pow(math.cos(b),2)) &nbsp; &nbsp;   &nbsp; 10.8 29.6 0.43 0.35 &nbsp; &nbsp;   little trick to allow for "aliasing", that is, renaming this class. writing code like  functions.chain(functions.plus,functions.sin,functions.chain(functions.square,functions.cos));  is a bit awkward, to say the least. using the aliasing you can instead write  functions f = functions.functions;  f.chain(f.plus,f.sin,f.chain(f.square,f.cos)); unary functions function that returns math.abs(a). function that returns math.acos(a). function that returns com.imsl.math.sfun.acosh(a). public static final doublefunction acosh = new doublefunction() { public final double apply(double a) { return sfun.acosh(a); } }; function that returns math.asin(a). function that returns com.imsl.math.sfun.asinh(a). public static final doublefunction asinh = new doublefunction() { public final double apply(double a) { return sfun.asinh(a); } }; function that returns math.atan(a). function that returns com.imsl.math.sfun.atanh(a). public static final doublefunction atanh = new doublefunction() { public final double apply(double a) { return sfun.atanh(a); } }; function that returns math.ceil(a). function that returns math.cos(a). function that returns com.imsl.math.sfun.cosh(a). public static final doublefunction cosh = new doublefunction() { public final double apply(double a) { return sfun.cosh(a); } }; function that returns com.imsl.math.sfun.cot(a). public static final doublefunction cot = new doublefunction() { public final double apply(double a) { return sfun.cot(a); } }; function that returns com.imsl.math.sfun.erf(a). public static final doublefunction erf = new doublefunction() { public final double apply(double a) { return sfun.erf(a); } }; function that returns com.imsl.math.sfun.erfc(a). public static final doublefunction erfc = new doublefunction() { public final double apply(double a) { return sfun.erfc(a); } }; function that returns math.exp(a). function that returns math.floor(a). function that returns com.imsl.math.sfun.gamma(a). public static final doublefunction gamma = new doublefunction() { public final double apply(double a) { return sfun.gamma(a); } }; function that returns its argument. function that returns 1.0 / a. function that returns math.log(a). function that returns com.imsl.math.sfun.log10(a). public static final doublefunction log10 = new doublefunction() { public final double apply(double a) { return sfun.log10(a); } }; function that returns math.log(a) / math.log(2). function that returns com.imsl.math.sfun.loggamma(a). public static final doublefunction loggamma = new doublefunction() { public final double apply(double a) { return sfun.loggamma(a); } }; function that returns -a. function that returns math.rint(a). function that returns a  0 ? 1 : 0. function that returns math.sin(a). function that returns com.imsl.math.sfun.sinh(a). public static final doublefunction sinh = new doublefunction() { public final double apply(double a) { return sfun.sinh(a); } }; function that returns math.sqrt(a). function that returns a a. function that returns math.tan(a). function that returns com.imsl.math.sfun.tanh(a). public static final doublefunction tanh = new doublefunction() { public final double apply(double a) { return sfun.tanh(a); } }; function that returns math.todegrees(a). public static final doublefunction todegrees = new doublefunction() { public final double apply(double a) { return math.todegrees(a); } }; function that returns math.toradians(a). public static final doublefunction toradians = new doublefunction() { public final double apply(double a) { return math.toradians(a); } }; binary functions function that returns math.atan2(a,b). function that returns com.imsl.math.sfun.logbeta(a,b). public static final doubledoublefunction logbeta = new doubledoublefunction() { public final double apply(double a, double b) { return sfun.logbeta(a,b); } }; function that returns a  b ? 1 : 0. function that returns a / b. function that returns a == b ? 1 : 0. function that returns a > b ? 1 : 0. function that returns math.ieeeremainder(a,b). function that returns a == b. function that returns a . function that returns a > b. function that returns a . function that returns math.log(a) / math.log(b). function that returns math.max(a,b). function that returns math.min(a,b). function that returns a - b. new doubledoublefunction() { public final double apply(double a, double b) { return a - b; } }; function that returns a % b. function that returns a b. function that returns a + b. new doubledoublefunction() { public final double apply(double a, double b) { return a + b; } }; function that returns math.abs(a) + math.abs(b). function that returns math.pow(a,b). makes this class non instantiable, but still let's others inherit from it. constructs a function that returns (from. a is a variable, from and to are fixed. constructs a unary function from a binary function with the first operand (argument) fixed to the given constant c. the second operand is variable (free). a binary function taking operands in the form function.apply(c,var). unary function function(c,var). constructs a unary function from a binary function with the second operand (argument) fixed to the given constant c. the first operand is variable (free). a binary function taking operands in the form function.apply(var,c). unary function function(var,c). constructs the function f( g(a), h(b) ). a binary function. a unary function. a unary function. binary function f( g(a), h(b) ). constructs the function g( h(a,b) ). a unary function. a binary function. unary function g( h(a,b) ). constructs the function g( h(a) ). a unary function. a unary function. unary function g( h(a) ). constructs a function that returns a  b ? 1 : 0. a is a variable, b is fixed. constructs a function that returns the constant c. demonstrates usage of this class. benchmarks and demonstrates usage of trivial and complex functions. constructs a function that returns a / b. a is a variable, b is fixed. constructs a function that returns a == b ? 1 : 0. a is a variable, b is fixed. constructs a function that returns a > b ? 1 : 0. a is a variable, b is fixed. constructs a function that returns math.ieeeremainder(a,b). a is a variable, b is fixed. constructs a function that returns from. a is a variable, from and to are fixed. constructs a function that returns a == b. a is a variable, b is fixed. constructs a function that returns a > b. a is a variable, b is fixed. constructs a function that returns a . a is a variable, b is fixed. constructs a function that returns a . a is a variable, b is fixed. constructs a function that returns math.log(a) / math.log(b). a is a variable, b is fixed. tests various methods of this class. constructs a function that returns math.max(a,b). a is a variable, b is fixed. constructs a function that returns math.min(a,b). a is a variable, b is fixed. constructs a function that returns a - b. a is a variable, b is fixed. constructs a function that returns a - bconstant. a and b are variables, constant is fixed. constructs a function that returns a % b. a is a variable, b is fixed. constructs a function that returns a b. a is a variable, b is fixed. return new doublefunction() { public final double apply(double a) { return a b; } }; constructs a function that returns a + b. a is a variable, b is fixed. constructs a function that returns a + bconstant. a and b are variables, constant is fixed. return new doubledoublefunction() { public final double apply(double a, double b) { return a + bconstant; } }; constructs a function that returns math.pow(a,b). a is a variable, b is fixed. constructs a function that returns a new uniform random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). currently the engine is {@link cern.jet.random.engine.mersennetwister} and is seeded with the current time.  note that any random engine derived from {@link cern.jet.random.engine.randomengine} and any random distribution derived from {@link cern.jet.random.abstractdistribution} are function objects, because they implement the proper interfaces. thus, if you are not happy with the default, just pass your favourite random generator to function evaluating methods. constructs a function that returns the number rounded to the given precision; math.rint(a/precision)precision. examples:  precision = 0.01 rounds 0.012 --> 0.01, 0.018 --> 0.02 precision = 10 rounds 123 --> 120 , 127 --> 130  constructs a function that returns function.apply(b,a), i.e. applies the function with the first operand as second operand and the second operand as first operand. a function taking operands in the form function.apply(a,b). binary function function(b,a). import com.imsl.math.sfun; should yield 1.4399560356056456 in all cases 1.0 / math.log(2) == 1.4426950408889634 doubledoublefunction f = f.chain(plus,sin,f.chain(square,cos)); double v = math.sin(a) + math.pow(math.cos(b),2); double v = a + b; doubledoublefunction f = f.chain(f.plus,f.identity,f.identity); doubledoublefunction f = f.chain(f.plus,f.sin,f.chain(f.square,f.cos)); doubledoublefunction f = f.plus; public final double apply(double x, double y) { return x+y; } emptyloop sum += a + b; cached for speed demo1();"
cern.jet.math.IntFunctions "integer function objects to be passed to generic methods. same as {@link functions} except operating on integers.  for aliasing see {@link #intfunctions}. little trick to allow for "aliasing", that is, renaming this class. writing code like  intfunctions.chain(intfunctions.plus,intfunctions.mult(3),intfunctions.chain(intfunctions.square,intfunctions.div(2)));  is a bit awkward, to say the least. using the aliasing you can instead write  intfunctions f = intfunctions.intfunctions;  f.chain(f.plus,f.mult(3),f.chain(f.square,f.div(2)));  unary functions function that returns math.abs(a) == (a . function that returns a--. function that returns (int) arithmetic.factorial(a). function that returns its argument. function that returns a++. function that returns -a. function that returns ~a. function that returns a  0 ? 1 : 0. function that returns a a. binary functions function that returns a & b. function that returns a  b ? 1 : 0. function that returns a / b. function that returns a == b ? 1 : 0. function that returns a == b. function that returns a . function that returns a > b. function that returns math.max(a,b). function that returns math.min(a,b). function that returns a - b. function that returns a % b. function that returns a b. function that returns a | b. function that returns a + b. function that returns (int) math.pow(a,b). function that returns a . function that returns a >> b. function that returns a >>> b. function that returns a ^ b. makes this class non instantiable, but still let's others inherit from it. constructs a function that returns a & b. a is a variable, b is fixed. constructs a function that returns (from. a is a variable, from and to are fixed. constructs a unary function from a binary function with the first operand (argument) fixed to the given constant c. the second operand is variable (free). a binary function taking operands in the form function.apply(c,var). unary function function(c,var). constructs a unary function from a binary function with the second operand (argument) fixed to the given constant c. the first operand is variable (free). a binary function taking operands in the form function.apply(var,c). unary function function(var,c). constructs the function g( h(a) ). a unary function. a unary function. unary function g( h(a) ). constructs the function g( h(a,b) ). a unary function. a binary function. unary function g( h(a,b) ). constructs the function f( g(a), h(b) ). a binary function. a unary function. a unary function. binary function f( g(a), h(b) ). constructs a function that returns a  b ? 1 : 0. a is a variable, b is fixed. constructs a function that returns the constant c. constructs a function that returns a / b. a is a variable, b is fixed. constructs a function that returns a == b ? 1 : 0. a is a variable, b is fixed. constructs a function that returns from. a is a variable, from and to are fixed. constructs a function that returns a == b. a is a variable, b is fixed. constructs a function that returns a > b. a is a variable, b is fixed. constructs a function that returns a . a is a variable, b is fixed. constructs a function that returns math.max(a,b). a is a variable, b is fixed. constructs a function that returns math.min(a,b). a is a variable, b is fixed. constructs a function that returns a - b. a is a variable, b is fixed. constructs a function that returns a % b. a is a variable, b is fixed. constructs a function that returns a b. a is a variable, b is fixed. constructs a function that returns a | b. a is a variable, b is fixed. constructs a function that returns a + b. a is a variable, b is fixed. constructs a function that returns (int) math.pow(a,b). a is a variable, b is fixed. constructs a function that returns a 32 bit uniformly distributed random number in the closed interval [integer.min_value,integer.max_value] (including integer.min_value and integer.max_value). currently the engine is {@link cern.jet.random.engine.mersennetwister} and is seeded with the current time.  note that any random engine derived from {@link cern.jet.random.engine.randomengine} and any random distribution derived from {@link cern.jet.random.abstractdistribution} are function objects, because they implement the proper interfaces. thus, if you are not happy with the default, just pass your favourite random generator to function evaluating methods. constructs a function that returns a . a is a variable, b is fixed. constructs a function that returns a >> b. a is a variable, b is fixed. constructs a function that returns a >>> b. a is a variable, b is fixed. constructs a function that returns function.apply(b,a), i.e. applies the function with the first operand as second operand and the second operand as first operand. a function taking operands in the form function.apply(a,b). binary function function(b,a). constructs a function that returns a | b. a is a variable, b is fixed."
cern.jet.math.Misc "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.Mult "only for performance tuning of compute intensive linear algebraic computations. constructs functions that return one of  a constant a / constant  a is variable, constant is fixed, but for performance reasons publicly accessible. intended to be passed to matrix.assign(function) methods. public read/write access to avoid frequent object construction. insert the method's description here. creation date: (8/10/99 19:12:09) returns the result of the function evaluation. a / constant. a constant."
cern.jet.math.NumericalIntegration "not yet commented. makes this class non instantiable, but still let's others inherit from it."
cern.jet.math.PlusMult "only for performance tuning of compute intensive linear algebraic computations. constructs functions that return one of  a + bconstant a - bconstant a + b/constant a - b/constant  a and b are variables, constant is fixed, but for performance reasons publicly accessible. intended to be passed to matrix.assign(othermatrix,function) methods. public read/write access to avoid frequent object construction. insert the method's description here. creation date: (8/10/99 19:12:09) returns the result of the function evaluation. a - b/constant. a - bconstant. a + b/constant. a + bconstant."
cern.jet.math.Polynomial "polynomial functions. makes this class non instantiable, but still let's others inherit from it. evaluates the given polynomial of degree n at x, assuming coefficient of n is 1.0. otherwise same as polevl().  2 n y = c + c x + c x +...+ c x 0 1 2 n where c = 1 and hence is omitted from the array. n coefficients are stored in reverse order: coef[0] = c , ..., coef[n-1] = c . n-1 0 calling arguments are otherwise the same as polevl().  in the interest of speed, there are no checks for out of bounds arithmetic. argument to the polynomial. the coefficients of the polynomial. the degree of the polynomial. evaluates the given polynomial of degree n at x.  2 n y = c + c x + c x +...+ c x 0 1 2 n coefficients are stored in reverse order: coef[0] = c , ..., coef[n] = c . n 0  in the interest of speed, there are no checks for out of bounds arithmetic. argument to the polynomial. the coefficients of the polynomial. the degree of the polynomial."
cern.jet.random.AbstractContinousDistribution "abstract base class for all continous distributions. makes this class non instantiable, but still let's others inherit from it."
cern.jet.random.AbstractDiscreteDistribution "abstract base class for all discrete distributions. makes this class non instantiable, but still let's others inherit from it. returns a random number from the distribution; returns (double) nextint(). returns a random number from the distribution."
cern.jet.random.AbstractDistribution "abstract base class for all random distributions. a subclass of this class need to override method nextdouble() and, in rare cases, also nextint().  currently all subclasses use a uniform pseudo-random number generation engine and transform its results to the target distribution. thus, they expect such a uniform engine upon instance construction.  {@link cern.jet.random.engine.mersennetwister} is recommended as uniform pseudo-random number generation engine, since it is very strong and at the same time quick. {@link #makedefaultgenerator()} will conveniently construct and return such a magic thing. you can also, for example, use {@link cern.jet.random.engine.drand}, a quicker (but much weaker) uniform random number generation engine. of course, you can also use other strong uniform random number generation engines.  ressources on the web: check the web version of the  cern data analysis briefbook . this will clarify the definitions of most distributions. also consult the  statsoft electronic textbook - the definite web book.  other useful ressources:  another site  and nextdouble(). this has the effect that distributions can now be used as function objects, returning a random number upon function evaluation. equivalent to nextint(). this has the effect that distributions can now be used as function objects, returning a random number upon function evaluation. returns a deep copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. returns the used uniform random number generator; constructs and returns a new uniform random number generation engine seeded with the current time. currently this is {@link cern.jet.random.engine.mersennetwister}. returns a random number from the distribution. returns a random number from the distribution; returns (int) math.round(nextdouble()). override this method if necessary. sets the uniform random generator internally used. www.cern.ch/rd11/rkb/an16pp/node1.html"> cern data analysis briefbook . this will clarify the definitions of most distributions. www.statsoftinc.com/textbook/stathome.html"> statsoft electronic textbook - the definite web book. www.stats.gla.ac.uk/steps/glossary/probability_distributions.html"> another site  and  list of definition of distributions. www.stat.ucla.edu/calculators/cdf"> plot all sort of distributions. www.animatedsoftware.com/statglos/statglos.htm"> internet glossary of statistical terms, www.ruf.rice.edu/~lane/hyperstat/index.html"> a text book, www.stat.umn.edu/~jkuhn/courses/stat3091f/stat3091f.html"> another text book. www.execpc.com/~helberg/statistics.html"> statistics on the web."
cern.jet.random.Benchmark "benchmarks random number generation from various distributions as well as pdf and cdf lookups. makes this class non instantiable, but still let's others inherit from it. prints the first size random numbers generated by the distribution. benchmarks all subclasses [0] the number of random numbers to be generated per subclass. [1] true prints each generated number, false does not print generated numbers (use this setting for benchmarking). benchmarks all subclasses the number of random numbers to be generated per subclass. true prints each generated number, false does not print generated numbers (use this setting for benchmarking). the mean for distributions that require a mean. randominstance(size,print,new zeta(10.0, 10.0,(randomengine)gen.clone())); randominstance(size,print,new zeta(1.0, 1.0, (randomengine)gen.clone())); randominstance(size,print,new zeta(mean, mean, (randomengine)gen.clone())); randominstance(size,print,new zeta(mean, 1/mean, (randomengine)gen.clone())); //randominstance(size,print,new zeta(1/mean, mean, (randomengine)gen.clone())); randominstance(size,print,new beta(10.0, 10.0,(randomengine)gen.clone())); randominstance(size,print,new beta(1.0, 1.0, (randomengine)gen.clone())); randominstance(size,print,new beta(mean, mean, (randomengine)gen.clone())); randominstance(size,print,new beta(mean, 1/mean, (randomengine)gen.clone())); randominstance(size,print,new beta(1/mean, mean, (randomengine)gen.clone())); randominstance(size,print,new uniform((randomengine)gen.clone())); randominstance(size,print,new poissonslow(mean,(randomengine)gen.clone())); randominstance(size,print,new poisson(3.0,(randomengine)gen.clone())); randominstance(size,print,new poissonslow(3.0,(randomengine)gen.clone())); randominstance(size,print,new binomial(1,0.5,(randomengine)gen.clone())); randominstance(size,print,new binomial(5,0.3,(randomengine)gen.clone())); randominstance(size,print,new binomial((int)mean,0.999999999,(randomengine)gen.clone())); randominstance(size,print,new binomial((int)mean,1.0/mean,(randomengine)gen.clone())); randominstance(size,print,new exponential(1.0,(randomengine)gen.clone())); randominstance(size,print,new exponential(3.0,(randomengine)gen.clone())); randominstance(size,print,new normal(0.0,1.0,(randomengine)gen.clone())); randominstance(size,print,new normal(3.0,1.0,(randomengine)gen.clone())); randominstance(size,print,new normal(mean,largevariance,(randomengine)gen.clone())); randominstance(size,print,new breitwigner(1.0, 0.2, double.negative_infinity, (randomengine)gen.clone())); randominstance(size,print,new breitwigner(1.0, 0.2, 1.0, (randomengine)gen.clone())); randominstance(size,print,new breitwignermeansquare(1.0, 0.2, double.negative_infinity, (randomengine)gen.clone())); randominstance(size,print,new breitwignermeansquare(1.0, 0.2, 1.0, (randomengine)gen.clone())); randominstance(size,print,new chisquare(1.0,(randomengine)gen.clone())); randominstance(size,print,new chisquare(5.0,(randomengine)gen.clone())); randominstance(size,print,new chisquare(mean,(randomengine)gen.clone())); randominstance(size,print,new gamma(0.2,1.0,(randomengine)gen.clone())); randominstance(size,print,new gamma(1.0,1.0,(randomengine)gen.clone())); randominstance(size,print,new gamma(3.0,0.5,(randomengine)gen.clone())); randominstance(size,print,new gamma(mean,0.5,(randomengine)gen.clone())); randominstance(size,print,new gamma(mean,1.0/mean,(randomengine)gen.clone())); randominstance(size,print,new gamma(mean,mean,(randomengine)gen.clone())); randominstance(size,print,new studentt(1.0,(randomengine)gen.clone())); randominstance(size,print,new studentt(2.5,(randomengine)gen.clone())); randominstance(size,print,new studentt(mean,(randomengine)gen.clone())); randominstance(size,print,new studentt(1.0/mean,(randomengine)gen.clone())); int probs = 10000; double[] pdf = new double[probs]; for (int i=0; i random numbers from  prints the first size random numbers generated by the distribution. prints the first size random numbers generated by the distribution. prints the first size random numbers generated by the distribution. timer.reset(); timer.start(); bina.xfrequencies2(distinct,freq); timer.stop().display(); //system.out.println(distinct); //system.out.println(freq); distinct.shuffle(); timer.reset().start(); distinct.sort(); timer.stop().display(); timer.reset().start(); bina.frequencies(distinct,freq); timer.stop().display(); //system.out.println(distinct); //system.out.println(freq); gamma distribution define distribution parameters for tests and debugging use a random engine with constant seed --> deterministic and reproducible results your favourite distribution goes here collect random numbers and print statistics int large = 100000000; = new mersennetwister(); randominstance(size,print,new zeta(1/mean, mean, (randomengine)gen.clone())); prepare f(x)=x^2 distrib. system.out.println(bina); system.out.println(binb); system.out.println(bina.comparewith(binb)); system.out.println(distinct); system.out.println(freq); system.out.println(distinct); system.out.println(freq); system.out.println(distinct); system.out.println(freq);"
cern.jet.random.Beta "beta distribution;  math definition and  animated definition.  p(x) = k x^(alpha-1) (1-x)^(beta-1) with k = g(alpha+beta)/(g(alpha)g(beta)) and g(a) being the gamma function.  valid parameter ranges: alpha &gt; 0 and beta &gt; 0.  instance methods operate on a constructs a beta distribution.    returns the cumulative distribution function. returns a random number from the distribution. returns a beta distributed random number; bypasses the internal state. beta distribution - stratified rejection/patchwork rejection for parameters a  1 , b > 1 (unimodal case) the patchwork rejection method b1prs of zechner/stadlober is utilized: the area below the density function f(x) in its body is rearranged by certain point reflections. within a large center interval variates are sampled efficiently by rejection from uniform hats. rectangular immediate acceptance regions speed up the generation. the remaining tails are covered by exponential functions. if (a-1)(b-1) = 0 sampling is done by inversion if either a or b are not equal to one. if a = b = 1 a uniform random variate is delivered. function : - bsprc samples a random variate from the beta distribution with parameters a > 0, b > 0. references : - h. sakasegawa (1983): stratified rejection and squeeze method for generating beta random numbers, ann. inst. statist. math. 35 b, 291-302. - h. zechner, e. stadlober (1993): generating beta variates via patchwork rejection, computing 50, 1-18. subprograms: - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed. - b00(seed,a,b) ... beta generator for a1, b>1 with unsigned long integer seed, double a, b. returns the cumulative distribution function. sets the parameters. returns a random number from the distribution. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node15.html#section000150000000000000000"> math definition www.statsoft.com/textbook/glosb.html#beta distribution"> animated definition. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.cis.tu-graz.ac.at/stat/stadl/random.html"> generating beta variates via patchwork rejection,, cache to speed up pdf() cached values shared by bxx cached values for b00 chached values for b01 chached values for b1prs the uniform random number generated shared by all static methods. b(1-b) / a(1-a) t = t_opt f(t) = fa fb 0  t squeeze accept: l(x) = 1 + (1 - a)(1 - x) squeeze reject: u(x) = 1 + (t^(a-1) - 1)/(1 - t) (1 - x) quotient accept: q(x) = x^(a-1) / fa one step newton start value t f(t) = fa fb ml = -m1 mu = -m2 t 0  t squeeze accept: l(x) = 1 + (1 - a)(1 - x) squeeze reject: u(x) = 1 + (t^(a-1) - 1)/(1 - t) (1 - x) quotient accept: q(x) = (x)^(a-1) / fa z1 = x1 - ll z5 = x5 + lr x1 = 2f2 - f(y) immediate accept: m = 2f4 - f(y) x  0!! squeeze accept: l(x) = f(x1) (x - z1) / (x1 - z1) z1 = x1 - ll, w <= 1 + (x - x1)/ll x5 < x x < 1!! squeeze accept: l(x) = f(x5) (z5 - x) / (z5 - x5) z5 = x5 + lr, w <= 1 + (x5 - x)/lr density accept: f(x) = (x/m)^a ((1 - x)/(1 - m))^b"
cern.jet.random.Binomial "binomial distribution; see the  math definition and  animated definition.  p(x) = k p^k (1-p)^(n-k) with k = n! / (k! (n-k)!).  instance methods operate on a constructs a binomial distribution. example: n=1, p=0.5. the number of trials (also known as sample size). the probability of success. a uniform random number generator. @throws illegalargumentexception if nmath.min(p,1-p) &lt;= 0.0 returns the cumulative distribution function. returns the cumulative distribution function. binomial-distribution - acceptance rejection/inversion acceptance rejection method combined with inversion for generating binomial random numbers with parameters n (number of trials) and p (probability of success). for min(np,n(1-p)) = 10 acceptance rejection is used: the algorithm is based on a hat-function which is uniform in the centre region and exponential in the tails. a triangular immediate acceptance region in the centre speeds up the generation of binomial variates. if candidate k is near the mode, f(k) is computed recursively starting at the mode m. the acceptance test by stirling's formula is modified according to w. hoermann (1992): the generation of binomial random variates, to appear in j. statist. comput. simul. if p  0. reference: - v. kachitvichyanukul, b.w. schmeiser (1988): binomial random variate generation, communications of the acm 31, 216-222. subprograms: - stirlingcorrection() ... correction term of the stirling approximation for log(k!) (series in 1/k or table values for small k) with long int k - randomgenerator ... (0,1)-uniform engine returns a random number from the distribution. returns a random number from the distribution with the given parameters n and p; bypasses the internal state. the number of trials the probability of success. @throws illegalargumentexception if nmath.min(p,1-p) &lt;= 0.0 returns the probability distribution function. sets the parameters number of trials and the probability of success. the number of trials the probability of success. @throws illegalargumentexception if nmath.min(p,1-p) &lt;= 0.0 returns a random number from the distribution with the given parameters n and p. the number of trials the probability of success. @throws illegalargumentexception if nmath.min(p,1-p) &lt;= 0.0 returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node19.html#section000190000000000000000"> math definition www.statsoft.com/textbook/glosb.html#binomial distribution"> animated definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randbinomial.html">randbinomial used in clhep 1.4.0 (c++). cache vars for method generatebinomial(...) cache vars for method pdf(...) the uniform random number generated shared by all static methods. set-up check for invalid input values mode, integer chop-down recurr. relat. variance i = p1 - 0.5 limit left limit right parallelogram height probabilities of regions 1-4 inversion chop-down triangular region immediate accept parallelogram left tail right tail acceptance test : two cases, depending on |k - m| computation of p(k) via recurrence relationship from the mode f(m) multiply f multiply v acceptance test lower and upper squeeze tests, based on lower bounds for log p(k) computation of log f(k) via stirling's formula final acceptance-rejection test"
cern.jet.random.BreitWigner "breitwigner (aka lorentz) distribution; see the  math definition. a more general form of the cauchy distribution.  instance methods operate on a constructs a breitwigner distribution. cut==double.negative_infinity indicates "don't cut". returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. cut==double.negative_infinity indicates "don't cut". sets the mean, gamma and cut parameters. cut==double.negative_infinity indicates "don't cut". returns a random number from the distribution. cut==double.negative_infinity indicates "don't cut". returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node23.html#section000230000000000000000"> math definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randbreitwigner.html">randbreitwigner used in clhep 1.4.0 (c++). the uniform random number generated shared by all static methods. don't cut"
cern.jet.random.BreitWignerMeanSquare "mean-square breitwigner distribution; see the  math definition.  instance methods operate on a constructs a mean-squared breitwigner distribution. cut==double.negative_infinity indicates "don't cut". returns a deep copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. returns a mean-squared random number from the distribution; bypasses the internal state. cut==double.negative_infinity indicates "don't cut". returns a random number from the distribution. cut==double.negative_infinity indicates "don't cut". sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node23.html#section000230000000000000000"> math definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randbreitwigner.html">randbreitwigner used in clhep 1.4.0 (c++). helper the uniform random number generated shared by all static methods. don't cut"
cern.jet.random.ChiSquare "chisquare distribution; see the  math definition and  animated definition. a special case of the gamma distribution.  p(x) = (1/g(f/2)) (x/2)^(f/2-1) exp(-x/2) with g(a) being the gamma function and f being the degrees of freedom.  valid parameter ranges: freedom &gt; 0.  instance methods operate on a constructs a chisquare distribution. example: freedom=1.0. degrees of freedom. @throws illegalargumentexception if freedom &lt; 1.0. returns the cumulative distribution function. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. degrees of freedom. it should hold freedom &lt; 1.0. chi distribution - ratio of uniforms with shift function : - chru samples a random number from the chi distribution with parameter a > 1. reference : - j.f. monahan (1987): an algorithm for generating chi random variables, acm trans. math. software 13, 168-172. subprogram : - anengine ... pointer to a (0,1)-uniform engine implemented by r. kremer, 1990 returns the probability distribution function. sets the distribution parameter. degrees of freedom. @throws illegalargumentexception if freedom &lt; 1.0. returns a random number from the distribution. degrees of freedom. @throws illegalargumentexception if freedom &lt; 1.0. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node31.html#section000310000000000000000"> math definition www.statsoft.com/textbook/glosc.html#chi-square distribution"> animated definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randchisquare.html">randchisquare used in clhep 1.4.0 (c++). www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached vars for method nextdouble(a) (for performance only) the uniform random number generated shared by all static methods. if( a < 1 ) return (-1.0); // check for invalid input value"
cern.jet.random.Distributions "contains methods for conveniently generating pseudo-random numbers from special distributions such as the burr, cauchy, erlang, geometric, lambda, laplace, logistic, weibull, etc.  about this class: all distributions are obtained by using a uniform pseudo-random number generator. followed by a transformation to the desired distribution.  example usage: cern.jet.random.engine.randomengine generator; generator = new cern.jet.random.engine.mersennetwister(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranecu(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranmar(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranlux(new java.util.date()); //generator = abstractdistribution.makedefaultgenerator(); for (int i=1000000; --i >=0; ) { int cauchy = distributions.nextcauchy(generator); ... }  @see cern.jet.random.engine.mersennetwister @see java.util.random @see java.lang.math makes this class non instantiable, but still let's others inherit from it. returns the probability distribution function of the discrete geometric distribution.  p(k) = p (1-p)^k for  k &gt;= 0.  the argument to the probability distribution function. the parameter of the probability distribution function. returns a random number from the burr ii, vii, viii, x distributions.  implementation: inversion method. this is a port of burr1.c from the c-rand / win-rand library. c-rand's implementation, in turn, is based upon  l. devroye (1986): non-uniform random variate generation, springer verlag, new york.  must be &gt; 0. the number of the burr distribution (e.g. 2,7,8,10). burr ii, vii, viii, x distributions - inversion function : - burr1 samples a random number from one of the burr ii, vii, viii, x distributions with parameter r > 0 , where the no. of the distribution is indicated by a pointer variable. reference : - l. devroye (1986): non-uniform random variate generation, springer verlag, new york. subprogram : - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed. y=u^(1/r) returns a random number from the burr iii, iv, v, vi, ix, xii distributions.  implementation: inversion method. this is a port of burr2.c from the c-rand / win-rand library. c-rand's implementation, in turn, is based upon  l. devroye (1986): non-uniform random variate generation, springer verlag, new york.  must be &gt; 0. must be &gt; 0. the number of the burr distribution (e.g. 3,4,5,6,9,12). burr iii, iv, v, vi, ix, xii distribution - inversion function : - burr2 samples a random number from one of the burr iii, iv, v, vi, ix, xii distributions with parameters r > 0 and k > 0, where the no. of the distribution is indicated by a pointer variable. reference : - l. devroye (1986): non-uniform random variate generation, springer verlag, new york. subprogram : - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed. returns a cauchy distributed random number from the standard cauchy distribution c(0,1).  math definition and  animated definition.  p(x) = 1/ (meanpi (1+(x/mean)^2)).  implementation: this is a port of cin.c from the c-rand / win-rand library.  @returns a number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). returns an erlang distributed random number with the given variance and mean. returns a discrete geometric distributed random number; definition.  p(k) = p (1-p)^k for  k &gt;= 0.  implementation: inversion method. this is a port of geo.c from the c-rand / win-rand library. must satisfy 0 &lt; p &lt; 1.  geometric distribution - inversion on generating random numbers of a discrete distribution by inversion normally sequential search is necessary, but in the case of the geometric distribution a direct transformation is possible because of the special parallel to the continuous exponential distribution exp(t): x - exp(t): g(x)=1-exp(-tx) geo(p): pk=g(k+1)-g(k)=exp(-tk)(1-exp(-t)) p=1-exp(-t) a random number of the geometric distribution geo(p) is obtained by k=(long int)x, where x is from exp(t) with parameter t=-log(1-p). function: - geo samples a random number from the geometric distribution with parameter 0 implementation: inversion method. this is a port of lamin.c from the c-rand / win-rand library. c-rand's implementation, in turn, is based upon  j.s. ramberg, b:w. schmeiser (1974): an approximate method for generating asymmetric variables, communications acm 17, 78-82.  returns a laplace (double exponential) distributed random number from the standard laplace distribution l(0,1).  implementation: inversion method. this is a port of lapin.c from the c-rand / win-rand library.  @returns a number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). returns a random number from the standard logistic distribution log(0,1).  implementation: inversion method. this is a port of login.c from the c-rand / win-rand library. returns a power-law distributed random number with the given exponent and lower cutoff. the exponent the lower cutoff returns a random number from the standard triangular distribution in (-1,1).  implementation: inversion method. this is a port of tra.c from the c-rand / win-rand library.  triangular distribution - inversion: x = +-(1-sqrt(u)) function : - tra samples a random number from the standard triangular distribution in (-1,1) subprogram : - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed. -1  algorithm from page 551 of: devroye, luc (1986) `non-uniform random variate generation', springer-verlag: berlin. isbn 3-540-96305-7 (also 0-387-96305-7) the skew of the distribution (must be &gt;1.0). @returns a zipfian distributed number in the closed interval [1,integer.max_value]. algorithm from page 551 of: devroye, luc (1986) `non-uniform random variate generation', springer-verlag: berlin. isbn 3-540-96305-7 (also 0-387-96305-7) generator = new edu.cornell.lassp.houle.rngpack.ranecu(new java.util.date()); generator = new edu.cornell.lassp.houle.rngpack.ranmar(new java.util.date()); generator = new edu.cornell.lassp.houle.rngpack.ranlux(new java.util.date()); generator = abstractdistribution.makedefaultgenerator(); www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. burr ii burr vii burr viii burr x www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. u(0/1) u^(-1/r) - 1 burr iii y^(-1/k) burr iv y^k + 1 burr v arctan[log(y/k)] burr vi burr ix y^(1/r) -1 burr xii y^(1/k) www.cern.ch/rd11/rkb/an16pp/node25.html#section000250000000000000000"> math definition www.statsoft.com/textbook/glosc.html#cauchy distribution"> animated definition. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.statsoft.com/textbook/glosf.html#geometric distribution">definition. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. sign(l) u(0/1) www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. polar method. see simulation, modelling & analysis by law & kelton, pp259"
cern.jet.random.Empirical "empirical distribution.  the probability distribution function (pdf) must be provided by the constructs an empirical distribution. the probability distribution function (pdf) is an array of positive real numbers. it need not be provided in the form of relative probabilities, absolute probabilities are also accepted. the pdf must satisfy both of the following conditions  0.0 &lt;= pdf[i] : 0&lt;=i&lt;=pdf.length-1 0.0 &lt; sum(pdf[i]) : 0&lt;=i&lt;=pdf.length-1  the probability distribution function. can be either empirical.no_interpolation or empirical.linear_interpolation. a uniform random number generator. @throws illegalargumentexception if at least one of the three conditions above is violated. returns the cumulative distribution function. returns a deep copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. returns a random number from the distribution. returns the probability distribution function. returns the probability distribution function. sets the distribution parameters. the pdf must satisfy both of the following conditions  0.0 &lt;= pdf[i] : 0 &lt; =i &lt;= pdf.length-1 0.0 &lt; sum(pdf[i]) : 0 &lt;=i &lt;= pdf.length-1  probability distribution function. can be either empirical.no_interpolation or empirical.linear_interpolation. @throws illegalargumentexception if at least one of the three conditions above is violated. returns a string representation of the receiver. not yet commented. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randgeneral.html">randgeneral used in clhep 1.4.0 (c++). cumulative distribution function non-existing pdf binary search in cumulative distribution function: largest k such that i[k] is known to be  rand div 2 after this binary search, nabove is always nbelow+1 and they straddle rand: binmeasure is always aprobfunc[nbelow], but we don't have aprobfunc any more so we subtract. rand lies right in a bin of measure 0. simply return the center of the range of that bin. (any value between k/n and (k+1)/n is equally good, in this rare case.) illegal interpolation type if (x  cdf.length-2) return 0.0; int k = (int) x; return cdf[k-1] - cdf[k]; throw new illegalargumentexception("non-existing pdf"); compute cumulative distribution function (cdf) from probability distribution function (pdf) cdf is now cached..."
cern.jet.random.EmpiricalWalker "discrete empirical distribution (pdf's can be specified).  the probability distribution function (pdf) must be provided by the james theiler, jt@lanl.gov, the constructs an empirical distribution. the probability distribution function (pdf) is an array of positive real numbers. it need not be provided in the form of relative probabilities, absolute probabilities are also accepted. the pdf must satisfy both of the following conditions  0.0 &lt;= pdf[i] : 0&lt;=i&lt;=pdf.length-1 0.0 &lt; sum(pdf[i]) : 0&lt;=i&lt;=pdf.length-1  the probability distribution function. can be either empirical.no_interpolation or empirical.linear_interpolation. a uniform random number generator. @throws illegalargumentexception if at least one of the three conditions above is violated. returns the cumulative distribution function. returns a deep copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. returns a random integer k with probability pdf(k). returns the probability distribution function. sets the distribution parameters. the pdf must satisfy all of the following conditions  pdf != null && pdf.length &gt; 0 0.0 &lt;= pdf[i] : 0 &lt; =i &lt;= pdf.length-1 0.0 &lt; sum(pdf[i]) : 0 &lt;=i &lt;= pdf.length-1  probability distribution function. @throws illegalargumentexception if at least one of the three conditions above is violated. sets the distribution parameters. the pdf must satisfy both of the following conditions  0.0 &lt;= pdf[i] : 0 &lt; =i &lt;= pdf.length-1 0.0 &lt; sum(pdf[i]) : 0 &lt;=i &lt;= pdf.length-1  probability distribution function. @throws illegalargumentexception if at least one of the three conditions above is violated. make sure elements of probarray[] are positive. won't enforce that sum is unity; instead will just normalize begin setting up the internal state now create the bigs and the smalls now work through the smalls then we are on our last value #if debug fprintf(stderr,"s=%2d, a=%2d, f=%.4f\n",s,(g->a)[s],(g->f)[s]); #endif now e[s] == mean no longer big, join ranks of the small still big, put it back where you found it e[b]==mean implies it is finished too stacks have been emptied, and a and f have been filled if 1, then artificially set all f[k]'s to unity. this will give wrong answers, but you'll get them faster. but, not that much faster (i get maybe 20%); that's an upper bound on what the optimal preprocessing would give. for (k=0; kdiscrete.c which was written by james theiler and is distributed with gsl 0.4.1. cumulative distribution function #if knuth_convention c = (int)(u(g->k)); #else #endif fprintf(stderr,"c,f,u: %d %.4f %f\n",c,f,u); compute cumulative distribution function (cdf) from probability distribution function (pdf) now normalize to 1 (relative probabilities). cdf is now cached... if (size = 0: "+pdf[k]); } normalize to relative probability #if 0 #endif #if knuth_convention"
cern.jet.random.engine.Benchmark "benchmarks the performance of the currently provided uniform pseudo-random number generation engines.  all distributions are obtained by using a uniform pseudo-random number generation engine. followed by a transformation to the desired distribution. therefore, the performance of the uniform engines is crucial.  comparison of uniform generation engines    name period  speed [# million uniform random numbers generated/sec] pentium pro 200 mhz, jdk 1.2, nt     mersennetwister 219937-1 (=106001) 2.5    ranlux (default luxury level 3)  10171 0.4    ranmar 1043 1.6    ranecu  1018 1.5    java.util.random.nextfloat()   ? 2.4     note: methods working on the default uniform random generator are synchronized and therefore in current vm's slow (as of june '99). methods taking as argument a uniform random generator are not synchronized and therefore much quicker. thus, if you need a lot of random numbers, you should use the unsynchronized approach:  example usage: edu.cornell.lassp.houle.rngpack.randomelement generator; generator = new cern.jet.random.engine.mersennetwister(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranecu(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranmar(new java.util.date()); //generator = new edu.cornell.lassp.houle.rngpack.ranlux(new java.util.date()); //generator = makedefaultgenerator(); for (int i=1000000; --i >=0; ) { double uniform = generator.raw(); ... }  @see cern.jet.random makes this class non instantiable, but still let's others inherit from it. benchmarks raw() for various uniform generation engines. gen = new edu.stanford.mt.mersennetwister(); system.out.println("\n edu.stanford.mt.mersennetwister:"); timer.reset().start(); for (int i=times; --i>=0; ) gen.raw(); timer.stop().display(); system.out.println(times/(timer.elapsedtime()-emptyloop)+ " numbers per second."); gen = new edu.cornell.lassp.houle.rngpack.ranecu(); system.out.println("\nranecu:"); timer.reset().start(); for (int i=times; --i>=0; ) gen.raw(); timer.stop().display(); system.out.println(times/(timer.elapsedtime()-emptyloop)+ " numbers per second."); gen = new edu.cornell.lassp.houle.rngpack.ranmar(); system.out.println("\nranmar:"); timer.reset().start(); for (int i=times; --i>=0; ) gen.raw(); timer.stop().display(); system.out.println(times/(timer.elapsedtime()-emptyloop)+ " numbers per second."); gen = new edu.cornell.lassp.houle.rngpack.ranlux(); system.out.println("\nranlux:"); timer.reset().start(); for (int i=times; --i>=0; ) gen.raw(); timer.stop().display(); system.out.println(times/(timer.elapsedtime()-emptyloop)+ " numbers per second."); tests various methods of this class. prints the first size random numbers generated by the given engine. system.out.println("raw():"); random = (randomengine) randomengine.clone(); //cern.colt.timer timer = new cern.colt.timer().start(); for (int j=0, i=size; --i>=0; j++) { system.out.print(" "+random.raw()); if (j%8==7) system.out.println(); } system.out.println("\n\nfloat():"); random = (randomengine) randomengine.clone(); for (int j=0, i=size; --i>=0; j++) { system.out.print(" "+random.nextfloat()); if (j%8==7) system.out.println(); } system.out.println("\n\ndouble():"); random = (randomengine) randomengine.clone(); for (int j=0, i=size; --i>=0; j++) { system.out.print(" "+random.nextdouble()); if (j%8==7) system.out.println(); } tests various methods of this class. generator = new edu.cornell.lassp.houle.rngpack.ranecu(new java.util.date()); generator = new edu.cornell.lassp.houle.rngpack.ranmar(new java.util.date()); generator = new edu.cornell.lassp.houle.rngpack.ranlux(new java.util.date()); generator = makedefaultgenerator(); no operation nextdouble() is slower testrandomfromto(from,to,times); benchmark(1000000); benchmark(1000000); benchmarksync(times); cern.colt.timer timer = new cern.colt.timer().start(); timer.stop().display(); cern.colt.set.openmultifloathashset multiset = new cern.colt.set.openmultifloathashset(); edu.cornell.lassp.houle.rngpack.randomelement random = new edu.cornell.lassp.houle.rngpack.ranecu(); edu.cornell.lassp.houle.rngpack.randomelement random = new edu.cornell.lassp.houle.rngpack.mt19937b(); edu.cornell.lassp.houle.rngpack.randomelement random = new edu.stanford.mt.mersennetwister(); randomjava.nextint(10000); integers.randomfromto(_from,_to); multiset.add(nextintfromto(_from,_to)); system.out.println(multiset); //check the distribution"
cern.jet.random.engine.DRand "quick medium quality uniform pseudo-random number generator. produces uniformly distributed int's and long's in the closed intervals [integer.min_value,integer.max_value] and [long.min_value,long.max_value], respectively, as well as float's and double's in the open unit intervals (0.0f,1.0f) and (0.0,1.0), respectively.  the seed can be any integer satisfying 0 &lt; 4seed+1 &lt; 232. in other words, there must hold seed &gt;= 0 && seed &lt; 1073741823.  quality: this generator follows the multiplicative congruential method of the form  z(i+1) = a z(i) (mod m) with a=663608941 (=0x278dde6dl), m=232.  z(i) assumes all different values 0 &lt; 4seed+1 &lt; m during a full period of 230.  performance: to_do  implementation: to_do  note that this implementation is not synchronized.  constructs and returns a random number generator with a default seed, which is a constant. constructs and returns a random number generator with the given seed. should not be 0, in such a case drand.default_seed is substituted. constructs and returns a random number generator seeded with the given date. typically new java.util.date() returns a 32 bit uniformly distributed random number in the closed interval [integer.min_value,integer.max_value] (including integer.min_value and integer.max_value). z(i+1)=az(i) (mod 232) sets the receiver's seed. this method resets the receiver's entire internal state. the following condition must hold: seed &gt;= 0 && seed &lt; (232-1) / 4. if the above condition does not hold, a modified seed that meets the condition is silently substituted. a == 0x278dde6d == 663608941 --> 536870911"
cern.jet.random.engine.MersenneTwister "mersennetwister (mt19937) is one of the strongest uniform pseudo-random number generators known so far; at the same time it is quick. produces uniformly distributed int's and long's in the closed intervals [integer.min_value,integer.max_value] and [long.min_value,long.max_value], respectively, as well as float's and double's in the open unit intervals (0.0f,1.0f) and (0.0,1.0), respectively. the seed can be any 32-bit integer except 0. shawn j. cokus commented that perhaps the seed should preferably be odd.  quality: mersennetwister is designed to pass the k-distribution test. it has an astronomically large period of 219937-1 (=106001) and 623-dimensional equidistribution up to 32-bit accuracy. it passes many stringent statistical tests, including the diehard test of g. marsaglia and the load test of p. hellekalek and s. wegenkittl.  performance: its speed is comparable to other modern generators (in particular, as fast as java.util.random.nextfloat()). 2.5 million calls to raw() per second (pentium pro 200 mhz, jdk 1.2, nt). be aware, however, that there is a non-negligible amount of overhead required to initialize the data structures used by a mersennetwister. code like  double sum = 0.0; for (int i=0; i will be wildly inefficient. consider using  double sum = 0.0; randomelement twister = new mersennetwister(new java.util.date()); for (int i=0; i instead. this allows the cost of constructing the mersennetwister object to be borne only once, rather than once for each iteration in the loop.  implementation: after m. matsumoto and t. nishimura, "mersenne twister: a 623-dimensionally equidistributed uniform pseudo-random number generator", acm transactions on modeling and computer simulation, vol. 8, no. 1, january 1998, pp 3--30. more info on  masumoto's homepage. more info on  pseudo-random number generators is on the web. yet  some more info.  the correctness of this implementation has been verified against the published output sequence mt19937-2.out of the c-implementation mt19937-2.c. (call test(1000) to print the sequence).  note that this implementation is not synchronized.  details: mersennetwister is designed with consideration of the flaws of various existing generators in mind. it is an improved version of tt800, a very successful generator. mersennetwister is based on linear recurrences modulo 2. such generators are very fast, have extremely long periods, and appear quite robust. mersennetwister produces 32-bit numbers, and every k-dimensional vector of such numbers appears the same number of times as k successive values over the period length, for each k &lt;= 623 (except for the zero vector, which appears one time less). if one looks at only the first n &lt;= 16 bits of each number, then the property holds for even larger k, as shown in the following table (taken from the publication cited above):     n   1   2   3   4   5   6   7   8   9   10   11   12 .. 16   17 .. 32     k   19937   9968   6240   4984   3738   3115   2493   2492   1869   1869   1248   1246   623      mersennetwister generates random numbers in batches of 624 numbers at a time, so the caching and pipelining of modern systems is exploited. the generator is implemented to generate the output by using the fastest arithmetic operations only: 32-bit additions and bit operations (no division, no multiplication, no mod). these operations generate sequences of 32 random bits (int's). long's are formed by concatenating two 32 bit int's. float's are formed by dividing the interval [0.0,1.0] into 232 sub intervals, then randomly choosing one subinterval. double's are formed by dividing the interval [0.0,1.0] into 264 sub intervals, then randomly choosing one subinterval.  set initial seeds: n = 624 words period parameters constant vector a most significant w-r bits least significant r bits for tempering mag01[x] = x matrix_a for x=0,1 constructs and returns a random number generator with a default seed, which is a constant. thus using this constructor will yield generators that always produce exactly the same sequence. this method is mainly intended to ease testing and debugging. constructs and returns a random number generator with the given seed. constructs and returns a random number generator seeded with the given date. typically new java.util.date() returns a copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. generates n words at one time. // optimized // only 5-10% faster ? int y; int kk; int[] cache = mt; // cached for speed int kkm; int limit = n-m; for (kk=0,kkm=kk+m; kk>> 1) ^ ((y & 0x1) == 0 ? mag0 : mag1); } limit = n-1; for (kkm=kk+(m-n); kk>> 1) ^ ((y & 0x1) == 0 ? mag0 : mag1); } y = (cache[n-1]&upper_mask)|(cache[0]&lower_mask); cache[n-1] = cache[m-1] ^ (y >>> 1) ^ ((y & 0x1) == 0 ? mag0 : mag1); this.mt = cache; this.mti = 0; returns a 32 bit uniformly distributed random number in the closed interval [integer.min_value,integer.max_value] (including integer.min_value and integer.max_value). each single bit including the sign bit will be random sets the receiver's seed. this method resets the receiver's entire internal state. see knuth taocp vol2. 3rd ed. p.106 for multiplier. in the previous versions, msbs of the seed affect only msbs of the array mt[]. 2002/01/09 modified by makoto matsumoto for >32 bit machines old version was: for (int i = 0; i >> 16; seed = 69069 seed + 1; } //system.out.println("init done"); mti = n; stat.fsu.edu/~geo/diehard.html">diehard test of g. marsaglia and the load test of p. hellekalek and s. wegenkittl. www.math.keio.ac.jp/~matumoto/eindex.html"> masumoto's homepage. www.ncsa.uiuc.edu/apps/cmp/rng/www-rng.html"> pseudo-random number generators is on the web. nhse.npac.syr.edu/random"> some more info. www.math.keio.ac.jp/~nisimura/random/real2/mt19937-2.out">mt19937-2.out of the c-implementation www.math.keio.ac.jp/~nisimura/random/real2/mt19937-2.c">mt19937-2.c. private static final int[] mag01=new int[] {0x0, matrix_a}; optimized only 5-10% faster ? cached for speed unoptimized generate n ints at one time y ^= tempering_shift_u(y ); y ^= tempering_shift_s(y) & tempering_mask_b; y ^= tempering_shift_t(y) & tempering_mask_c; y &= 0xffffffff; //you may delete this line if word size = 32 y ^= tempering_shift_l(y); system.out.println("init done"); system.out.println("init done");"
cern.jet.random.engine.MersenneTwister64 "same as mersennetwister except that method raw() returns 64 bit random numbers instead of 32 bit random numbers. constructs and returns a random number generator with a default seed, which is a constant. constructs and returns a random number generator with the given seed. should not be 0, in such a case mersennetwister64.default_seed is silently substituted. constructs and returns a random number generator seeded with the given date. typically new java.util.date() returns a 64 bit uniformly distributed random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0)."
cern.jet.random.engine.RandomEngine "abstract base class for uniform pseudo-random number generating engines.  most probability distributions are obtained by using a uniform pseudo-random number generation engine followed by a transformation to the desired distribution. thus, subclasses of this class are at the core of computational statistics, simulations, monte carlo methods, etc.  subclasses produce uniformly distributed int's and long's in the closed intervals [integer.min_value,integer.max_value] and [long.min_value,long.max_value], respectively, as well as float's and double's in the open unit intervals (0.0f,1.0f) and (0.0,1.0), respectively.  subclasses need to override one single method only: nextint(). all other methods generating different data types or ranges are usually layered upon nextint(). long's are formed by concatenating two 32 bit int's. float's are formed by dividing the interval [0.0f,1.0f] into 232 sub intervals, then randomly choosing one subinterval. double's are formed by dividing the interval [0.0,1.0] into 264 sub intervals, then randomly choosing one subinterval.  note that this implementation is not synchronized. makes this class non instantiable, but still let's others inherit from it. equivalent to raw(). this has the effect that random engines can now be used as function objects, returning a random number upon function evaluation. equivalent to nextint(). this has the effect that random engines can now be used as function objects, returning a random number upon function evaluation. constructs and returns a new uniform random number engine seeded with the current time. currently this is {@link cern.jet.random.engine.mersennetwister}. returns a 64 bit uniformly distributed random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). nextlong == long.max_value --> 1.0 nextlong == long.min_value --> 0.0 nextlong == long.max_value-1 --> 1.0 nextlong == long.max_value-100000l --> 0.9999999999999946 nextlong == long.min_value+1 --> 0.0 nextlong == long.min_value-100000l --> 0.9999999999999946 nextlong == 1l --> 0.5 nextlong == -1l --> 0.5 nextlong == 2l --> 0.5 nextlong == -2l --> 0.5 nextlong == 2l+100000l --> 0.5000000000000054 nextlong == -2l-100000l --> 0.49999999999999456 returns a 32 bit uniformly distributed random number in the open unit interval (0.0f,1.0f) (excluding 0.0f and 1.0f). returns a 32 bit uniformly distributed random number in the closed interval [integer.min_value,integer.max_value] (including integer.min_value and integer.max_value); returns a 64 bit uniformly distributed random number in the closed interval [long.min_value,long.max_value] (including long.min_value and long.max_value). returns a 32 bit uniformly distributed random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). nextint == integer.max_value --> 0.49999999976716936 nextint == integer.min_value --> 0.5 nextint == integer.max_value-1 --> 0.4999999995343387 nextint == integer.min_value+1 --> 0.5000000002328306 nextint == 1 --> 2.3283064365386963e-10 nextint == -1 --> 0.9999999997671694 nextint == 2 --> 4.6566128730773926e-10 nextint == -2 --> 0.9999999995343387 public abstract class randomengine extends edu.cornell.lassp.houle.rngpack.randomseedable implements cern.colt.function.doublefunction, cern.colt.function.intfunction { -9.223372036854776e18 == (double) long.min_value 5.421010862427522e-20 == 1 / math.pow(2,64) == 1 / ((double) long.max_value - (double) long.min_value); catch loss of precision of long --> double conversion --> in (0.0,1.0) catch loss of precision of double --> float conversion --> in (0.0f,1.0f) concatenate two 32-bit strings into one 64-bit string accept anything but zero in [integer.min_value,integer.max_value]-interval transform to (0.0,1.0)-interval 2.3283064365386963e-10 == 1.0 / math.pow(2,32)"
cern.jet.random.engine.RandomGenerator "interface for uniform pseudo-random number generators. returns a 32 bit uniformly distributed random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). returns a 64 bit uniformly distributed random number in the open unit interval (0.0,1.0) (excluding 0.0 and 1.0). returns a 32 bit uniformly distributed random number in the closed interval [integer.min_value,integer.max_value] (including integer.min_value and integer.max_value); returns a 64 bit uniformly distributed random number in the closed interval [long.min_value,long.max_value] (including long.min_value and long.max_value). returns a 32 bit uniformly distributed random number in the open unit interval (0.0f,1.0f) (excluding 0.0f and 1.0f)."
cern.jet.random.engine.RandomSeedGenerator "deterministic seed generator for pseudo-random number generators. the sole purpose of this class is to decorrelate seeds and uniform random number generators. (if a generator would be used to generate seeds for itself, the result could be correlations.)  this class has entirelly deterministic behaviour: constructing two instances with the same parameters at any two distinct points in time will produce identical seed sequences. however, it does not (at all) generate uniformly distributed numbers. do not use it as a uniformly distributed random number generator!  each generated sequence of seeds has a period of 109 numbers. internally uses {@link randomseedtable}. constructs and returns a new seed generator. constructs and returns a new seed generator; you normally won't need to use this method.  the position [row,column] indicates the iteration starting point within a (virtual) seed matrix. the seed matrix is a nm matrix with 1 + integer.max_value (virtual) rows and randomseedtable.columns columns. successive calls to method nextseed() will cycle over the given column, in ascending order: nextseed() returns the seed s[row,column], s[row+1,column], ... s[integer.max_value,column], s[0,column], s[1,column], ... should be in [0,integer.max_value]. should be in [0,randomseedtable.columns - 1]. prints the generated seeds for the given input parameters. returns the next seed. prints the next size generated seeds."
cern.jet.random.engine.RandomSeedTable "(seemingly gigantic) table of good seeds for pseudo-random number generators.  implementation: this is a port of seedtable.h used in clhep 1.4.0 (c++). clhep's implementation, in turn, is part of geant 4, a c++ simulation toolkit for high energy physics. geant4, in turn, took the table from the original fortran77 implementation of the hep cern library routine recusq. each sequence has a period of 109 numbers. the number of columns of the matrix (currently columns = 2). makes this class non instantiable, but still let's others inherit from it. returns a deterministic seed from a (seemingly gigantic) matrix of predefined seeds. should (but need not) be in [0,integer.max_value]. shoould (but need not) be in [0,seedtable.columns-1]. seed at the indicated matrix position. not yet commented. wwwinfo.cern.ch/asd/lhc++/clhep">clhep 1.4.0 (c++). wwwinfo.cern.ch/asd/geant/geant4.html">geant 4, a c++ simulation toolkit for high energy physics. a mn matrix, just stored as one-dim array 215 2 entries the table is limited; let's snap the unbounded input parameters to the table's actual size. "randomize" the seed (in some ways comparable to hash functions) cycle==0 --> mask = 0 cycle==0 --> seed stays unaffected now, each sequence has a period of 109 numbers."
cern.jet.random.Exponential "exponential distribution (aka negative exponential distribution); see the  math definition  animated definition.  p(x) = lambdaexp(-xlambda) for x &gt;= 0, lambda &gt; 0.  instance methods operate on a constructs a negative exponential distribution. returns the cumulative distribution function. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. returns the probability distribution function. sets the mean. returns a random number from the distribution with the given lambda. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node78.html#section000780000000000000000"> math definition www.statsoft.com/textbook/glose.html#exponential distribution"> animated definition. the uniform random number generated shared by all static methods."
cern.jet.random.ExponentialPower "exponential power distribution.  valid parameter ranges: tau &gt;= 1.  instance methods operate on a constructs an exponential power distribution. example: tau=1.0. @throws illegalargumentexception if tau &lt; 1.0. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. @throws illegalargumentexception if tau &lt; 1.0. sets the distribution parameter. @throws illegalargumentexception if tau &lt; 1.0. returns a random number from the distribution. @throws illegalargumentexception if tau &lt; 1.0. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached vars for method nextdouble(tau) (for performance only) the uniform random number generated shared by all static methods. set-up generator u(0/1) u(-1.0/1.0) u1=|u| u(0/1) uniform hat-function for x  (1-1/tau) u(0/1) acceptance/rejection random sign"
cern.jet.random.Fun "contains various mathematical helper methods. implementation: high performance implementation. this is a port of gen_fun.cpp from the c-rand / win-rand library. makes this class non instantiable, but still let's others inherit from it. modified bessel functions of first kind - order 0. modified bessel functions of first kind - order 1. returns n!. long i,prod; prod = 1; if (n != 0) { for (i = 2; i gamma(x). returns a quick approximation of log(gamma(x)). || x > 1.3e19 www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. while (!null) { otherwise numerical integration of the function defined above while (!null) { while (!null) { if (x > math.log(double.max_value)) return double.max_value;"
cern.jet.random.Gamma "gamma distribution;  math definition,  definition of gamma function and  animated definition.  p(x) = k x^(alpha-1) e^(-x/beta) with k = 1/(g(alpha) b^a)) and g(a) being the gamma function.  valid parameter ranges: alpha &gt; 0.  note: for a gamma distribution to have the mean mean and variance variance, set the parameters as follows:  alpha = meanmean / variance; lambda = 1 / (variance / mean);   instance methods operate on a constructs a gamma distribution. example: alpha=1.0, lambda=1.0. @throws illegalargumentexception if alpha &lt;= 0.0 || lambda &lt;= 0.0. returns the cumulative distribution function. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. gamma distribution - acceptance rejection combined with acceptance complement function: - gds samples a random number from the standard gamma distribution with parameter a > 0. acceptance rejection gs for a = 1 . references: - j.h. ahrens, u. dieter (1974): computer methods for sampling from gamma, beta, poisson and binomial distributions, computing 12, 223-246. - j.h. ahrens, u. dieter (1982): generating gamma variates by a modified rejection technique, communications of the acm 25, 47-54. subprograms: - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed - normal(seed) ... normal generator n(0,1). returns the probability distribution function. sets the mean and variance. @throws illegalargumentexception if alpha &lt;= 0.0 || lambda &lt;= 0.0. returns a random number from the distribution. @throws illegalargumentexception if alpha &lt;= 0.0 || lambda &lt;= 0.0. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. wwwinfo.cern.ch/asdoc/shortwrupsdir/g106/top.html"> math definition, www.cern.ch/rd11/rkb/an16pp/node96.html#section000960000000000000000"> definition of gamma function www.statsoft.com/textbook/glosf.html#gamma distribution"> animated definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randgamma.html">randgamma used in clhep 1.4.0 (c++). www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. the uniform random number generated shared by all static methods. check for invalid input values case a: acceptance rejection algorithm gs step 1 step 2. case gds  1 case b: acceptance complement algorithm gd (gaussian distribution, box muller transformation) step 1. preparations step 2. normal deviate immediate acceptance step 3. uniform random number squeeze acceptance step 4. set-up for hat case step 5. calculation of q step 6. step 7. quotient acceptance step 8. double exponential deviate t step 9. rejection of t step 10. new q(t) step 11. step 12. hat acceptance"
cern.jet.random.Hyperbolic "hyperbolic distribution.  valid parameter ranges: alpha &gt; 0 and beta &gt; 0.  instance methods operate on a constructs a beta distribution. returns a random number from the distribution. returns a hyperbolic distributed random number; bypasses the internal state. hyperbolic distribution - non-universal rejection function : - hyplc.c samples a random number from the hyperbolic distribution with shape parameter a and b valid for a>0 and |b|static methods. the new uniform random number generator to be shared. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached values shared for generatehyperbolic(...) the uniform random number generated shared by all static methods. set-up a^2 - b^2 -log(f(mode)) mode fr^-1(exp(-sqrt(a^2 - b^2) - 1.0)) fl^-1(exp(-sqrt(a^2 - b^2) - 1.0)) lower border upper border generator rejection with a uniform majorizing function over the body of the distribution rejection with an exponential envelope on the right side of the mode rejection with an exponential envelope on the left side of the mode"
cern.jet.random.HyperGeometric "hypergeometric distribution; see the  math definition the hypergeometric distribution with parameters n, n and s is the probability distribution of the random variable x, whose value is the number of successes in a sample of n items from a population of size n that has s 'success' items and n - s 'failure' items.  p(k) = c(s,k) c(n-s,n-k) / c(n,n) where c(a,b) = a! / (b! (a-b)!).  valid for n >= 2, s,n  instance methods operate on a constructs a hypergeometric distribution. returns a random number from the distribution. mode, real mode, integer mp = m + 1 mode probability, using the external function flogfak(k) = ln(k!) safety bound - guarantees at least 17 significant decimal digits b = min(n, (long int)(nu + kc')) down- and upward search from the mode downward search upward search upward search from k = 2m + 1 to k = b returns a random number from the distribution. (x, y)  (v, w) set-up returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. returns a random number from the distribution; bypasses the internal state. hypergeometric distribution - patchwork rejection/inversion the basic algorithms work for parameters 1 = 10 the patchwork rejection method hprs is employed: the area below the histogram function f(x) in its body is rearranged by certain point reflections. within a large center interval variates are sampled efficiently by rejection from uniform hats. rectangular immediate acceptance regions speed up the generation. the remaining tails are covered by exponential functions. function : - hprsc samples a random number from the hypergeometric distribution with parameters n (number of red and black balls), m (number of red balls) and n (number of trials) valid for n >= 2, m,n =10 with unsigned long integer seed, long integer n , m , n. returns the probability distribution function. sets the parameters. returns a random number from the distribution. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. library.advanced.org/10030/6atpdvah.htm"> math definition www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached vars shared by hmdu(...) and hprs(...) cached vars for hmdu(...) cached vars for hprs(...) the uniform random number generated shared by all static methods. set-up / main parameters approximate deviation of reflection points k2, k4 from nu - 1/2 mode m, reflection points k2 and k4, and points k1 and k5, which delimit the centre region of h(x) k2 = ceil (nu - 1/2 - u), k1 = 2k2 - (m - 1 + delta_ml) k4 = floor(nu - 1/2 + u), k5 = 2k4 - (m + 1 - delta_mr) delta_ml = 0 delta_mr = 1 range width of the critical left and right centre region recurrence constants r(k) = p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 reciprocal values of the scale parameters of expon. tail envelopes expon. tail left // expon. tail right // hypergeom. constant, necessary for computing function values f(k) function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5 area of the two centre and the two exponential tail regions area of the two immediate acceptance regions between k2, k4 immed. left centre left immed. right centre right expon. tail left expon. tail right generate uniform number u -- u(0, p6) case distinction corresponding to u centre left immediate acceptance region r2 = [k2, m) [0, f2), x = k2, ... m -1 immediate acceptance region r1 = [k1, k2)[0, f1), x = k1, ... k2-1 computation of candidate x  k2 either squeeze-acceptance of x or acceptance-rejection of v quick accept of x = k2 - dk quick reject of v quick accept of v = k2 + dk final accept of v centre right immediate acceptance region r3 = [m, k4+1)[0, f4), x = m, ... k4 immediate acceptance region r4 = [k4+1, k5+1)[0, f5) computation of candidate x > k4, and its counterpart v < k4 either squeeze-acceptance of x or acceptance-rejection of v quick accept of x = k4 + dk quick reject of v quick accept of v = k4 - dk final accept of v expon. tail left 0 <= x <= k1 - 1 y -- u(0, h(x)) quick accept of x expon. tail right k5 + 1 <= x <= n y -- u(0, h(x)) / quick accept of x acceptance-rejection test of candidate x from the original area test, whether y <= f(x), with y = uh(x) and u -- u(0, 1) log f(x) = log( m! (m - m)! (n - m)! (n - m - n + m)! ) - log( x! (m - x)! (n - x)! (n - m - n + x)! ) by using an external function for log k!"
cern.jet.random.Logarithmic "logarithmic distribution.  valid parameter ranges: 0 &lt; p &lt; 1.  instance methods operate on a constructs a logarithmic distribution. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. logarithmic distribution - inversion/transformation the algorithm combines inversion and transformation. it is based on the following fact: a random variable x from the logarithmic distribution has the property that x for fixed y=y is geometric distributed with p(x=x|y=y)=(1-y)y^(x-1) () where y has distribution function f(y)=ln(1-y)/ln(1-p). so first random numbers y are generated by simple inversion, then k=(long int) (1+ln(u)/ln(y)) is a geometric random number and because of () a logarithmic one. to speed up the algorithm squeezes are used as well as the fact, that many of the random numbers are 1 or 2 (depending on special circumstances). on an ibm/pc 486 optimal performance is achieved, if for pstatic methods. the new uniform random number generator to be shared. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached vars for method nextdouble(a) (for performance only) the uniform random number generated shared by all static methods. set-up inversion/chop-down system.out.println("u="+u+", p="+p); transformation"
cern.jet.random.NegativeBinomial "negative binomial distribution; see the  0, 0  0 unsigned long seed, double a - poisson(seed,a) ...poisson generator for a > 0 unsigned long seed, double a. returns the probability distribution function. sets the parameters number of trials and the probability of success. the number of trials the probability of success. returns a random number from the distribution with the given parameters n and p. the number of trials the probability of success. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.statlets.com/ www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. the uniform random number generated shared by all static methods."
cern.jet.random.Normal "normal (aka gaussian) distribution; see the  math definition and  animated definition.  1 2 pdf(x) = --------- exp( - (x-mean) / 2v ) sqrt(2piv) x - 1 | | 2 cdf(x) = --------- | exp( - (t-mean) / 2v ) dt sqrt(2piv)| | - -inf.  where v = variance = standarddeviation^2.  instance methods operate on a constructs a normal (gauss) distribution. example: mean=0.0, standarddeviation=1.0. returns the cumulative distribution function. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. returns the probability distribution function. sets the uniform random generator internally used. sets the mean and variance. returns a random number from the distribution with the given mean and standard deviation. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node188.html#section0001880000000000000000"> math definition www.statsoft.com/textbook/glosn.html#normal distribution"> animated definition. cache for box-mueller algorithm box-mueller performance cache the uniform random number generated shared by all static methods. uses polar box-muller transformation."
cern.jet.random.Poisson "poisson distribution (quick); see the  math definition and  animated definition.  p(k) = (mean^k / k!) exp(-mean) for k &gt;= 0.  valid parameter ranges: mean &gt; 0. note: if mean &lt;= 0.0 then always returns zero.  instance methods operate on a constructs a poisson distribution. example: mean=1.0. returns the cumulative distribution function. returns a deep copy of the receiver; the copy will produce identical sequences. after this call has returned, the copy and the receiver have equal but separate state. copy of the receiver. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. poisson distribution - patchwork rejection/inversion for parameter my = 10 patchwork rejection is employed: the area below the histogram function f(x) is rearranged in its body by certain point reflections. within a large center interval variates are sampled efficiently by rejection from uniform hats. rectangular immediate acceptance regions speed up the generation. the remaining tails are covered by exponential functions. returns the probability distribution function. sets the mean. returns a random number from the distribution with the given mean. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node208.html#section0002080000000000000000"> math definition www.statsoft.com/textbook/glosp.html#poisson distribution"> animated definition. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. www.cis.tu-graz.ac.at/stat/stadl/random.html">the patchwork rejection method for sampling from unimodal distributions, precomputed and cached values (for performance only) cache for = switch_mean cache for both; for all means larger than that, we don't try to compute a poisson deviation, but return the mean. switch from method a to method b the uniform random number generated shared by all static methods. static double p,q,p0,pp[36]; static long ll,m; case b: inversion- start new table and calculate p0 for (k=pp.length; --k >=0; ) pp[k] = 0; step u. uniform sample step t. table comparison step c. creation of new prob. end my  k2 either squeeze-acceptance of x or acceptance-rejection of y quick accept of x = k2 - dk quick reject of y quick accept of y = k2 + dk final accept of y centre right immediate acceptance region r3 = [m, k4+1)[0, f4), x = m, ... k4 immediate acceptance region r4 = [k4+1, k5+1)[0, f5) computation of candidate x > k4, and its counterpart y = k5 + 1 w -- u(0, h(x)) quick accept of x acceptance-rejection test of candidate x from the original area test, whether w <= f(k), with w = uh(x) and u -- u(0, 1) log f(x) = (x - m)log(my) - log x! + log m! mean is too large overflow sensitive: return (math.pow(mean,k) / cephes.arithmetic.factorial(k)) math.exp(-this.mean);"
cern.jet.random.PoissonSlow "poisson distribution; see the  math definition and  animated definition.  p(k) = (mean^k / k!) exp(-mean) for k &gt;= 0.  valid parameter ranges: mean &gt; 0. note: if mean &lt;= 0.0 then always returns zero.  instance methods operate on a constructs a poisson distribution. example: mean=1.0. returns the value ln(gamma(xx) for xx > 0. full accuracy is obtained for xx > 1. for 0 static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node208.html#section0002080000000000000000"> math definition www.statsoft.com/textbook/glosp.html#poisson distribution"> animated definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randpoisson.html">randpoisson used in clhep 1.4.0 (c++). precomputed and cached values (for performance only) for all means larger than that, we don't try to compute a poisson deviation, but return the mean. switch from method a to method b for method loggamma() the uniform random number generated shared by all static methods. not defined bug in clhep 1.4.0: was "} while ( product > g );" faster than em = math.floor(em); (em>=0.0) mean is too large detected endless loop due to rounding errors not defined"
cern.jet.random.sampling.RandomSampler "space and time efficiently computes a sorted simple random sample without replacement (srswor), that is, a sorted set of n random numbers from an interval of n numbers; example: computing n=3 random numbers from the interval [1,50] may yield the sorted random set (7,13,47). since we are talking about a set (sampling without replacement), no element will occur more than once. each number from the n numbers has the same probability to be included in the n chosen numbers. problem: this class solves problems including the following:  suppose we have a file containing 10^12 objects. we would like to take a truly random subset of 10^6 objects and do something with it, for example, compute the sum over some instance field, or whatever. how do we choose the subset? in particular, how do we avoid multiple equal elements? how do we do this quick and without consuming excessive memory? how do we avoid slowly jumping back and forth within the file?  sorted simple random sample without replacement (srswor): what are the exact semantics of this class? what is a srswor? in which sense exactly is a returned set "random"? it is random in the sense, that each number from the n numbers has the same probability to be included in the n chosen numbers. for those who think in implementations rather than abstract interfaces: suppose, we have an empty list. we pick a random number between 1 and 10^12 and add it to the list only if it was not already picked before, i.e. if it is not already contained in the list. we then do the same thing again and again until we have eventually collected 10^6 distinct numbers. now we sort the set ascending and return it. it is exactly in this sense that this class returns "random" sets. note, however, that the implementation of this class uses a technique orders of magnitudes better (both in time and space) than the one outlined above. performance: space requirements are zero. running time is o(n) on average, o(n) in the worst case. performance (200mhz pentium pro, jdk 1.2, nt)    n n speed [seconds]   103 1.2103 0.0014   103 107 0.006   105 107 0.7   9.0106 107 8.5   9.9106 107 2.0 (samples more than 95%)   104 1012 0.07   107 1012 60    scalability: this random sampler is designed to be scalable. in iterator style, it is able to compute and deliver sorted random sets stepwise in units called blocks. example: computing n=9 random numbers from the interval [1,50] in 3 blocks may yield the blocks (7,13,14), (27,37,42), (45,46,49). (the maximum of a block is guaranteed to be less than the minimum of its successor block. every block is sorted ascending. no element will ever occur twice, both within a block and among blocks.) a block can be computed and retrieved with method nextblock. successive calls to method nextblock will deliver as many random numbers as required. computing and retrieving samples in blocks is useful if you need very many random numbers that cannot be stored in main memory at the same time. for example, if you want to compute 10^10 such numbers you can do this by computing them in blocks of, say, 500 elements each. you then need only space to keep one block of 500 elements (i.e. 4 kb). when you are finished processing the first 500 elements you call nextblock to fill the next 500 elements into the block, process them, and so on. if you have the time and need, by using such blocks you can compute random sets up to n=10^19 random numbers. if you do not need the block feature, you can also directly call the static methods of this class without needing to construct a randomsampler instance first. random number generation: by default uses mersennetwister, a very strong random number generator, much better than java.util.random. you can also use other strong random number generators of paul houle's rngpack package. for example, ranecu, ranmar and ranlux are strong well analyzed research grade pseudo-random number generators with known periods. implementation: after j.s. vitter, an efficient algorithm for sequential random sampling, acm transactions on mathematical software, vol 13, 1987. paper available  here. @see randomsamplingassistant constructs a random sampler that computes and delivers sorted random sets in blocks. a set block can be retrieved with method nextblock. successive calls to method nextblock will deliver as many random numbers as required. the total number of elements to choose (must be n &gt;= 0 and n &lt;= n). the interval to choose random numbers from is [low,low+n-1]. the interval to choose random numbers from is [low,low+n-1]. hint: if low==0, then random numbers will be drawn from the interval [0,n-1]. a random number generator. set this parameter to null to use the default random number generator. returns a deep copy of the receiver. tests this class. computes the next count random numbers of the sorted random set specified on instance construction and fills them into values, starting at index fromindex. numbers are filled into the specified array starting at index fromindex to the right. the array is returned sorted ascending in the range filled with numbers. the number of elements to be filled into values by this call (must be &gt;= 0). the array into which the random numbers are to be filled; must have a length &gt;= count+fromindex. the first index within values to be filled with numbers (inclusive). efficiently computes a sorted random set of count elements from the interval [low,low+n-1]. since we are talking about a random set, no element will occur more than once. running time is o(count), on average. space requirements are zero. numbers are filled into the specified array starting at index fromindex to the right. the array is returned sorted ascending in the range filled with numbers. the total number of elements to choose (must be &gt;= 0). the interval to choose random numbers from is [low,low+n-1]. the number of elements to be filled into values by this call (must be &gt;= 0 and &lt;=n). normally, you will set count=n. the interval to choose random numbers from is [low,low+n-1]. hint: if low==0, then draws random numbers from the interval [0,n-1]. the array into which the random numbers are to be filled; must have a length &gt;= count+fromindex. the first index within values to be filled with numbers (inclusive). a random number generator. this algorithm is applicable if a large percentage (90%..100%) of n shall be sampled. in such cases it is more efficient than samplemethoda() and samplemethodd(). the idea is that it is more efficient to express sample(n,n,count) in terms of reject(n-n,n,count) and then invert the result. for example, sampling 99% turns into sampling 1% plus inversion. this algorithm is the same as method samplemethodd(...) with the exception that sampled elements are rejected, and not sampled elements included in the result set. efficiently computes a sorted random set of count elements from the interval [low,low+n-1]. since we are talking about a random set, no element will occur more than once. running time is o(count), on average. space requirements are zero. numbers are filled into the specified array starting at index fromindex to the right. the array is returned sorted ascending in the range filled with numbers. random number generation: by default uses mersennetwister, a very strong random number generator, much better than java.util.random. you can also use other strong random number generators of paul houle's rngpack package. for example, ranecu, ranmar and ranlux are strong well analyzed research grade pseudo-random number generators with known periods. the total number of elements to choose (must be n &gt;= 0 and n &lt;= n). the interval to choose random numbers from is [low,low+n-1]. the number of elements to be filled into values by this call (must be &gt;= 0 and &lt;=n). normally, you will set count=n. the interval to choose random numbers from is [low,low+n-1]. hint: if low==0, then draws random numbers from the interval [0,n-1]. the array into which the random numbers are to be filled; must have a length &gt;= count+fromindex. the first index within values to be filled with numbers (inclusive). a random number generator. set this parameter to null to use the default random number generator. computes a sorted random set of count elements from the interval [low,low+n-1]. since we are talking about a random set, no element will occur more than once. running time is o(n), on average. space requirements are zero. numbers are filled into the specified array starting at index fromindex to the right. the array is returned sorted ascending in the range filled with numbers. the total number of elements to choose (must be &gt;= 0). the interval to choose random numbers from is [low,low+n-1]. the number of elements to be filled into values by this call (must be &gt;= 0 and &lt;=n). normally, you will set count=n. the interval to choose random numbers from is [low,low+n-1]. hint: if low==0, then draws random numbers from the interval [0,n-1]. the array into which the random numbers are to be filled; must have a length &gt;= count+fromindex. the first index within values to be filled with numbers (inclusive). a random number generator. efficiently computes a sorted random set of count elements from the interval [low,low+n-1]. since we are talking about a random set, no element will occur more than once. running time is o(count), on average. space requirements are zero. numbers are filled into the specified array starting at index fromindex to the right. the array is returned sorted ascending in the range filled with numbers. the total number of elements to choose (must be &gt;= 0). the interval to choose random numbers from is [low,low+n-1]. the number of elements to be filled into values by this call (must be &gt;= 0 and &lt;=n). normally, you will set count=n. the interval to choose random numbers from is [low,low+n-1]. hint: if low==0, then draws random numbers from the interval [0,n-1]. the array into which the random numbers are to be filled; must have a length &gt;= count+fromindex. the first index within values to be filled with numbers (inclusive). a random number generator. // invert for (int iter=0; iter 0; iter++) { values[fromindex++] = ++chosen; count--; } chosen++; tests the methods of this class. to do benchmarking, comment the lines printing stuff to the console. log.print("chunk #"+i+" = ["); for (int j=0; j "); test(n/80,n,0,chunksize); system.out.print(" n="+n/40+" --> "); test(n/40,n,0,chunksize); system.out.print(" n="+n/20+" --> "); test(n/20,n,0,chunksize); system.out.print(" n="+n/10+" --> "); test(n/10,n,0,chunksize); system.out.print(" n="+n/5+" --> "); test(n/5,n,0,chunksize); system.out.print(" n="+n/2+" --> "); test(n/2,n,0,chunksize); system.out.print(" n="+(n-3)+" --> "); test(n-3,n,0,chunksize); } www.cs.duke.edu/~jsv"> here. public class randomsampler extends object implements java.io.serializable { static long negalphainv; // just to determine once and for all the best value for negalphainv testnegalphainv(args); nothing to do important !!! long threshold; tuning paramter, determines when to switch from method d to method a. dependent on programming language, platform, etc. threshold = -negalphainv n; && thresholdmaxtmpmemoryallowed) { more than 95% of all numbers shall be sampled. special case n==1 tuning paramter, determines when to switch from method d to method a. dependent on programming language, platform, etc. step d2: generate u and x step d3: accept? break inner loop step d4: accept? accept ! break inner loop end for step d5: select the (s+1)st record ! invert end while faster to use method a to finish the sampling special case n==1 sample remaining part, if necessary"
cern.jet.random.sampling.RandomSamplingAssistant "conveniently computes a stable simple random sample without replacement (srswor) subsequence of n elements from a given input sequence of n elements; example: computing a sublist of n=3 random elements from a list (1,...,50) may yield the sublist (7,13,47). the subsequence is guaranteed to be stable, i.e. elements never change position relative to each other. each element from the n elements has the same probability to be included in the n chosen elements. this class is a convenience adapter for randomsampler using blocks. @see randomsampler constructs a random sampler that samples n random elements from an input sequence of n elements. the total number of elements to choose (must be &gt;= 0). number of elements to choose from (must be &gt;= n). a random number generator. set this parameter to null to use the default random number generator. returns a deep copy of the receiver. not yet commented. returns the used random generator. tests random sampling. just shows how this class can be used; samples n elements from and int[] array. returns whether the next element of the input sequence shall be sampled (picked) or not. true if the next element shall be sampled (picked), false otherwise. tests the methods of this class. to do benchmarking, comment the lines printing stuff to the console. tests the methods of this class. to do benchmarking, comment the lines printing stuff to the console. system.out.print("\nelements = ["); for (int i=0; itrue where sampling shall occur and false where it shall not occur. public class randomsamplingassistant extends object implements java.io.serializable { start with the right offset test(n,n); reject reject accept manually inlined reject reject accept"
cern.jet.random.sampling.WeightedRandomSampler "conveniently computes a stable subsequence of elements from a given input sequence; picks (samples) exactly one random element from successive blocks of weight input elements each. for example, if weight==2 (a block is 2 elements), and the input is 52=10 elements long, then picks 5 random elements from the 10 elements such that one element is randomly picked from the first block, one element from the second block, ..., one element from the last block. weight == 1.0 --> all elements are picked (sampled). weight == 10.0 --> picks one random element from successive blocks of 10 elements each. etc. the subsequence is guaranteed to be stable, i.e. elements never change position relative to each other. calls blockedrandomsampler(1,null). chooses exactly one random element from successive blocks of weight input elements each. for example, if weight==2, and the input is 52=10 elements long, then chooses 5 random elements from the 10 elements such that one is chosen from the first block, one from the second, ..., one from the last block. weight == 1.0 --> all elements are consumed (sampled). 10.0 --> consumes one random element from successive blocks of 10 elements each. etc. the weight. a random number generator. set this parameter to null to use the default random number generator. returns a deep copy of the receiver. not yet commented. int chooses exactly one random element from successive blocks of weight input elements each. for example, if weight==2, and the input is 52=10 elements long, then chooses 5 random elements from the 10 elements such that one is chosen from the first block, one from the second, ..., one from the last block. true if the next element shall be sampled (picked), false otherwise. not yet commented. int not yet commented. chooses exactly one random element from successive blocks of weight input elements each. for example, if weight==2, and the input is 52=10 elements long, then chooses 5 random elements from the 10 elements such that one is chosen from the first block, one from the second, ..., one from the last block. a bitvector which will be filled with true where sampling shall occur and false where it shall not occur. public class blockedrandomsampler extends object implements java.io.serializable { reject tuned for speed reject accept manually inlined reject tuned for speed reject accept"
cern.jet.random.Stack "not yet commented. max number of elts on stack array of values on the stack index of top of stack constructs a new stack with the given capacity. static stack_t new_stack(int n) { stack_t s; s = (stack_t )malloc(sizeof(stack_t)); s->n = n; s->i = -1; // indicates stack is empty s->v = (int )malloc(sizeof(int)n); return s; } static void push_stack(stack_t s, int v) { s->i += 1; if ((s->i) >= (s->n)) { fprintf(stderr,"cannot push stack!\n"); exit(0); // fatal!! } (s->v)[s->i] = v; } static int pop_stack(stack_t s) { if ((s->i) i -= 1; return ((s->v)[s->i + 1]); } static inline int size_stack(const stack_t s) { return s->i + 1; } static void free_stack(stack_t s) { free((char )(s->v)); free((char )s); } returns the topmost element. places the given value on top of the stack. returns the number of elements contained. indicates stack is empty indicates stack is empty fatal!!"
cern.jet.random.StudentT "studentt distribution (aka t-distribution); see the  math definition and  animated definition.  p(x) = k (1+x^2/f) ^ -(f+1)/2 where k = g((f+1)/2) / (sqrt(pif) g(f/2)) and g(a) being the gamma function and f being the degrees of freedom.  valid parameter ranges: freedom &gt; 0.  instance methods operate on a constructs a studentt distribution. example: freedom=1.0. degrees of freedom. @throws illegalargumentexception if freedom &lt;= 0.0. returns the cumulative distribution function. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. degrees of freedom. @throws illegalargumentexception if a &lt;= 0.0. the polar method of box/muller for generating normal variates is adapted to the student-t distribution. the two generated variates are not independent and the expected no. of uniforms per variate is 2.5464. reference : - r.w. bailey (1994): polar generation of random variates with the t-distribution, mathematics of computation 62, 779-781. returns the probability distribution function. sets the distribution parameter. degrees of freedom. @throws illegalargumentexception if freedom &lt;= 0.0. returns a random number from the distribution. degrees of freedom. @throws illegalargumentexception if freedom &lt;= 0.0. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cern.ch/rd11/rkb/an16pp/node279.html#section0002790000000000000000"> math definition www.statsoft.com/textbook/gloss.html#student's t distribution"> animated definition. wwwinfo.cern.ch/asd/lhc++/clhep/manual/refguide/random/randstudentt.html">randstudentt used in clhep 1.4.0 (c++). www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. performance cache for pdf() the uniform random number generated shared by all static methods."
cern.jet.random.Uniform "uniform distribution;  math definition and  animated definition.  instance methods operate on a constructs a uniform distribution with the given minimum and maximum, using a {@link cern.jet.random.engine.mersennetwister} seeded with the given seed. constructs a uniform distribution with the given minimum and maximum. constructs a uniform distribution with min=0.0 and max=1.0. returns the cumulative distribution function (assuming a continous uniform distribution). returns a uniformly distributed random boolean. returns a uniformly distributed random number in the open interval (min,max) (excluding min and max). returns a uniformly distributed random number in the open interval (from,to) (excluding from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the open interval (from,to) (excluding from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the closed interval [min,max] (including min and max). returns a uniformly distributed random number in the closed interval [from,to] (including from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the closed interval [from,to] (including from and to). pre conditions: from &lt;= to. doing the thing turns out to be more tricky than expected. avoids overflows and underflows. treats cases like from=-1, to=1 and the like right. the following code would not solve the problem: return (long) (doubles.randomfromto(from,to)); rounding avoids the unsymmetric behaviour of casts from double to long: (long) -0.7 = 0, (long) 0.7 = 0. checking for overflows and underflows is also necessary. returns the probability distribution function (assuming a continous uniform distribution). sets the internal state. returns a uniformly distributed random boolean. returns a uniformly distributed random number in the open interval (0,1) (excluding 0 and 1). returns a uniformly distributed random number in the open interval (from,to) (excluding from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the open interval (from,to) (excluding from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the closed interval [from,to] (including from and to). pre conditions: from &lt;= to. returns a uniformly distributed random number in the closed interval [from,to] (including from and to). pre conditions: from &lt;= to. sets the uniform random number generation engine shared by all static methods. the new uniform random number generation engine to be shared. returns a string representation of the receiver. www.cern.ch/rd11/rkb/an16pp/node292.html#section0002920000000000000000"> math definition www.statsoft.com/textbook/glosu.html#uniform distribution"> animated definition. the uniform random number generated shared by all static methods. first the most likely and also the fastest case. would we get a numeric overflow? if not, we can still handle the case rather efficient. now the pathologic boundary cases. they are handled rather slow. return math.round(nextdoublefromto(from,to));"
cern.jet.random.VonMises "von mises distribution.  valid parameter ranges: k &gt; 0.  instance methods operate on a constructs a von mises distribution. example: k=1.0. @throws illegalargumentexception if k &lt;= 0.0. returns a random number from the distribution. returns a random number from the distribution; bypasses the internal state. @throws illegalargumentexception if k &lt;= 0.0. von mises distribution - acceptance rejection function : - mwc samples a random number from the von mises distribution ( -pi  0 via rejection from the wrapped cauchy distibution. reference: - d.j. best, n.i. fisher (1979): efficient simulation of the von mises distribution, appl. statist. 28, 152-157. subprogram: - drand(seed) ... (0,1)-uniform generator with unsigned long integer seed. implemented by f. niederl, august 1992 sets the distribution parameter. @throws illegalargumentexception if k &lt;= 0.0. returns a random number from the distribution. @throws illegalargumentexception if k &lt;= 0.0. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached vars for method nextdouble(a) (for performance only) the uniform random number generated shared by all static methods. set-up generator u(0/1) u(0/1) acceptance/rejection random sign // 0 <= x <= pi : -pi <= x <= 0 //"
cern.jet.random.Zeta "zeta distribution.  valid parameter ranges: ro &gt; 0 and pk &gt;= 0.  if either ro &gt; 100 or k &gt; 10000 numerical problems in computing the theoretical moments arise, therefore ro &lt;= 100 and k &lt;= 10000 are recommended.  instance methods operate on a constructs a zeta distribution. returns a zeta distributed random number. zeta distribution - acceptance rejection to sample from the zeta distribution with parameters ro and pk it suffices to sample variates x from the distribution with density function f(x)=b{[x+0.5]+pk}^(-(1+ro)) ( x > .5 ) and then deliver k=[x+0.5]. 1/b=sum[(j+pk)^-(ro+1)] (j=1,2,...) converges for ro >= .5 . it is not necessary to compute b, because variates x are generated by acceptance rejection using density function g(x)=ro(c+0.5)^ro(c+x)^-(ro+1). integer overflow is possible, when ro is small (ro  .14 + pk1.85e-8 + .02ln(pk) the percentage of overflow is less than 1%, so that the result is reliable. note: the comment above is likely to be nomore valid since the c-version operated on 32-bit integers, while this java version operates on 64-bit integers. however, the following is still valid: if either ro > 100 or k > 10000 numerical problems in computing the theoretical moments arise, therefore ro 0 and pk >= 0. reference: - j. dagpunar (1988): principles of random variate generation, clarendon press, oxford. returns a random number from the distribution. sets the parameters. returns a random number from the distribution. returns a string representation of the receiver. sets the uniform random number generated shared by all static methods. the new uniform random number generator to be shared. www.cis.tu-graz.ac.at/stat/stadl/random.html">c-rand / win-rand library. cached values (for performance) the uniform random number generated shared by all static methods. set-up"
cern.jet.stat.Descriptive "basic descriptive statistics. makes this class non instantiable, but still let's others inherit from it. returns the auto-correlation of a data sequence. checks if the given range is within the contained array's bounds. @throws indexoutofboundsexception if to!=from-1 || from&lt;0 || from&gt;to || to&gt;=size(). returns the correlation of two data sequences. that is covariance(data1,data2)/(standarddev1standarddev2). returns the covariance of two data sequences, which is cov(x,y) = (1/(size()-1)) sum((x[i]-mean(x)) (y[i]-mean(y))). see the  math definition. both covariance versions yield the same results but the one above is faster durbin-watson computation. computes the frequency (number of occurances, count) of each distinct value in the given sorted data. after this call returns both distinctvalues and frequencies have a new size (which is equal for both), which is the number of distinct values in the sorted data.  distinct values are filled into distinctvalues, starting at index 0. the frequency of each distinct value is filled into frequencies, starting at index 0. as a result, the smallest distinct value (and its frequency) can be found at index 0, the second smallest distinct value (and its frequency) at index 1, ..., the largest distinct value (and its frequency) at index distinctvalues.size()-1. example:  elements = (5,6,6,7,8,8) --> distinctvalues = (5,6,7,8), frequencies = (1,2,1,2) the data; must be sorted ascending. a list to be filled with the distinct values; can have any size. a list to be filled with the frequencies; can have any size; set this parameter to null to ignore it. returns the geometric mean of a data sequence. note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.  the geometric mean is given by pow( product( data[i] ), 1/size) which is equivalent to math.exp( sum( log(data[i]) ) / size). returns the geometric mean of a data sequence. note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero.  the geometric mean is given by pow( product( data[i] ), 1/data.size()). this method tries to avoid overflows at the expense of an equivalent but somewhat slow definition: geo = math.exp( sum( log(data[i]) ) / data.size()). returns the harmonic mean of a data sequence. the number of elements in the data sequence. sum( 1.0 / data[i]). incrementally maintains and updates minimum, maximum, sum and sum of squares of a data sequence. assume we have already recorded some data sequence elements and know their minimum, maximum, sum and sum of squares. assume further, we are to record some more elements and to derive updated values of minimum, maximum, sum and sum of squares.  this method computes those updated values without needing to know the already recorded elements. this is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory.  definition of sumofsquares: sumofsquares(n) = sum ( data[i] data[i] ). the additional elements to be incorporated into min, max, etc. the index of the first element within data to consider. the index of the last element within data to consider. the method incorporates elements data[from], ..., data[to]. the old values in the following format:  inout[0] is the old minimum. inout[1] is the old maximum. inout[2] is the old sum. inout[3] is the old sum of squares.  if no data sequence elements have so far been recorded set the values as follows  inout[0] = double.positive_infinity as the old minimum. inout[1] = double.negative_infinity as the old maximum. inout[2] = 0.0 as the old sum. inout[3] = 0.0 as the old sum of squares.  updated values filled into the inout array. double olddeviation = element - mean; mean += olddeviation / (n+1); sumsquareddeviations += (element-mean)olddeviation; // cool, huh? double oldmean = mean; mean += (element - mean)/(n+1); if (n > 0) { sumsquareddeviations += (element-mean)(element-oldmean); // cool, huh? } incrementally maintains and updates various sums of powers of the form sum(data[i]k). assume we have already recorded some data sequence elements data[i] and know the values of sum(data[i]from), sum(data[i]from+1), ..., sum(data[i]to). assume further, we are to record some more elements and to derive updated values of these sums.  this method computes those updated values without needing to know the already recorded elements. this is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory. for example, the incremental computation of moments is based upon such sums of powers:  the moment of k-th order with constant c of a data sequence, is given by sum( (data[i]-c)k ) / data.size(). it can incrementally be computed by using the equivalent formula  moment(k,c) = m(k,c) / data.size() where m(k,c) = sum( -1i b(k,i) ci sumofpowers(k-i)) for i = 0 .. k and b(k,i) = {@link cern.jet.math.arithmetic#binomial(long,long) binomial(k,i)} and sumofpowers(k) = sum( data[i]k ).  the additional elements to be incorporated into min, max, etc. the index of the first element within data to consider. the index of the last element within data to consider. the method incorporates elements data[from], ..., data[to]. the old values of the sums in the following format:  sumofpowers[0] is the old sum(data[i]fromsumindex). sumofpowers[1] is the old sum(data[i]fromsumindex+1). ... sumofpowers[tosumindex-fromsumindex] is the old sum(data[i]tosumindex).  if no data sequence elements have so far been recorded set all old values of the sums to 0.0. updated values filled into the sumofpowers array. incrementally maintains and updates sum and sum of squares of a weighted data sequence. assume we have already recorded some data sequence elements and know their sum and sum of squares. assume further, we are to record some more elements and to derive updated values of sum and sum of squares.  this method computes those updated values without needing to know the already recorded elements. this is interesting for interactive online monitoring and/or applications that cannot keep the entire huge data sequence in memory.  definition of sum: sum = sum ( data[i] weights[i] ). definition of sumofsquares: sumofsquares = sum ( data[i] data[i] weights[i]). the additional elements to be incorporated into min, max, etc. the weight of each element within data. the index of the first element within data (and weights) to consider. the index of the last element within data (and weights) to consider. the method incorporates elements data[from], ..., data[to]. the old values in the following format:  inout[0] is the old sum. inout[1] is the old sum of squares.  if no data sequence elements have so far been recorded set the values as follows  inout[0] = 0.0 as the old sum. inout[1] = 0.0 as the old sum of squares.  updated values filled into the inout array. returns the kurtosis (aka excess) of a data sequence. 4 the fourth central moment, which is moment(data,4,mean). the standarddeviation. returns the kurtosis (aka excess) of a data sequence, which is -3 + moment(data,4,mean) / standarddeviation4. returns the lag-1 autocorrelation of a dataset; note that this method has semantics different from autocorrelation(..., 1); returns the largest member of a data sequence. returns the arithmetic mean of a data sequence; that is sum( data[i] ) / data.size(). returns the mean deviation of a dataset. that is sum (math.abs(data[i]-mean)) / data.size()). returns the median of a sorted data sequence. the data sequence; must be sorted ascending. double[] sortedelements = sorteddata.elements(); int n = sorteddata.size(); int lhs = (n - 1) / 2 ; int rhs = n / 2 ; if (n == 0) return 0.0 ; double median; if (lhs == rhs) median = sortedelements[lhs] ; else median = (sortedelements[lhs] + sortedelements[rhs])/2.0 ; return median; returns the smallest member of a data sequence. returns the moment of k-th order with constant c of a data sequence, which is sum( (data[i]-c)k ) / data.size(). sumofpowers[m] == sum( data[i]m) ) for m = 0,1,..,k as returned by method {@link #incrementalupdatesumsofpowers(doublearraylist,int,int,int,int,double[])}. in particular there must hold sumofpowers.length == k+1. the number of elements of the data sequence. for (int i=0; ik-th order with constant c of a data sequence, which is sum( (data[i]-c)k ) / data.size(). returns the pooled mean of two data sequences. that is (size1 mean1 + size2 mean2) / (size1 + size2). 1 the number of elements in data sequence 1. 1 the mean of data sequence 1. 2 the number of elements in data sequence 2. 2 the mean of data sequence 2. returns the pooled variance of two data sequences. that is (size1 variance1 + size2 variance2) / (size1 + size2); 1 the number of elements in data sequence 1. 1 the variance of data sequence 1. 2 the number of elements in data sequence 2. 2 the variance of data sequence 2. returns the product, which is prod( data[i] ). in other words: data[0]data[1]...data[data.size()-1]. this method uses the equivalent definition: prod = pow( exp( sum( log(x[i]) ) / size(), size()). returns the product of a data sequence, which is prod( data[i] ). in other words: data[0]data[1]...data[data.size()-1]. note that you may easily get numeric overflows. returns the phi-quantile; that is, an element elem for which holds that phi percent of data elements are less than elem. the quantile need not necessarily be contained in the data sequence, it can be a linear interpolation. the data sequence; must be sorted ascending. the percentage; must satisfy 0 &lt;= phi &lt;= 1. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. the list to be searched (must be sorted ascending). the element to search for. percentage phi of elements &lt;= element (0.0 &lt;= phi &lt;= 1.0). returns the quantiles of the specified percentages. the quantiles need not necessarily be contained in the data sequence, it can be a linear interpolation. the data sequence; must be sorted ascending. the percentages for which quantiles are to be computed. each percentage must be in the interval [0.0,1.0]. quantiles. returns the linearly interpolated number of elements in a list less or equal to a given element. the rank is the number of elements {0, 1, 2,..., sortedlist.size()}. if no element is math.sqrt(sum( data[i]data[i] ) / data.size()). the rms of data sequence is the square-root of the mean of the squares of the elements in the data sequence. it is a measure of the average "size" of the elements of a data sequence. sumofsquares(data) == sum( data[i]data[i] ) of the data sequence. the number of elements in the data sequence. returns the sample kurtosis (aka excess) of a data sequence. ref: r.r. sokal, f.j. rohlf, biometry: the principles and practice of statistics in biological research (w.h. freeman and company, new york, 1998, 3rd edition) p. 114-115. the number of elements of the data sequence. 4 the fourth central moment, which is moment(data,4,mean). the sample variance. returns the sample kurtosis (aka excess) of a data sequence. return the standard error of the sample kurtosis. ref: r.r. sokal, f.j. rohlf, biometry: the principles and practice of statistics in biological research (w.h. freeman and company, new york, 1998, 3rd edition) p. 138. the number of elements of the data sequence. returns the sample skew of a data sequence. ref: r.r. sokal, f.j. rohlf, biometry: the principles and practice of statistics in biological research (w.h. freeman and company, new york, 1998, 3rd edition) p. 114-115. the number of elements of the data sequence. 3 the third central moment, which is moment(data,3,mean). the sample variance. returns the sample skew of a data sequence. return the standard error of the sample skew. ref: r.r. sokal, f.j. rohlf, biometry: the principles and practice of statistics in biological research (w.h. freeman and company, new york, 1998, 3rd edition) p. 138. the number of elements of the data sequence. returns the sample standard deviation. ref: r.r. sokal, f.j. rohlf, biometry: the principles and practice of statistics in biological research (w.h. freeman and company, new york, 1998, 3rd edition) p. 53. the number of elements of the data sequence. the sample variance. returns the sample variance of a data sequence. that is (sumofsquares - meansum) / (size - 1) with mean = sum/size. the number of elements of the data sequence. == sum( data[i] ). == sum( data[i]data[i] ). returns the sample variance of a data sequence. that is sum ( (data[i]-mean)^2 ) / (data.size()-1). returns the sample weighted variance of a data sequence. that is (sumofsquaredproducts - sumofproducts sumofproducts / sumofweights) / (sumofweights - 1). == sum( weights[i] ). == sum( data[i] weights[i] ). == sum( data[i] data[i] weights[i] ). returns the skew of a data sequence. 3 the third central moment, which is moment(data,3,mean). the standarddeviation. returns the skew of a data sequence, which is moment(data,3,mean) / standarddeviation3. splits (partitions) a list into sublists such that each sublist contains the elements with a given range. splitters=(a,b,c,...,y,z) defines the ranges [-inf,a), [a,b), [b,c), ..., [y,z), [z,inf]. examples:  data = (1,2,3,4,5,8,8,8,10,11). splitters=(2,8) yields 3 bins: (1), (2,3,4,5) (8,8,8,10,11). splitters=() yields 1 bin: (1,2,3,4,5,8,8,8,10,11). splitters=(-5) yields 2 bins: (), (1,2,3,4,5,8,8,8,10,11). splitters=(100) yields 2 bins: (1,2,3,4,5,8,8,8,10,11), ().  the list to be partitioned (must be sorted ascending). the points at which the list shall be partitioned (must be sorted ascending). sublists (an array with length == splitters.size() + 1. each sublist is returned sorted ascending. returns the standard deviation from a variance. returns the standard error of a data sequence. that is math.sqrt(variance/size). the number of elements in the data sequence. the variance of the data sequence. modifies a data sequence to be standardized. changes each element data[i] as follows: data[i] = (data[i]-mean)/standarddeviation. returns the sum of a data sequence. that is sum( data[i] ). returns the sum of inversions of a data sequence, which is sum( 1.0 / data[i]). the data sequence. the index of the first data element (inclusive). the index of the last data element (inclusive). returns the sum of logarithms of a data sequence, which is sum( log(data[i]). the data sequence. the index of the first data element (inclusive). the index of the last data element (inclusive). returns sum( (data[i]-c)k ); optimized for common parameters like c == 0.0 and/or k == -2 .. 4. returns sum( (data[i]-c)k ) for all i = from .. to; optimized for common parameters like c == 0.0 and/or k == -2 .. 5. returns the sum of powers of a data sequence, which is sum ( data[i]k ). returns the sum of squared mean deviation of of a data sequence. that is variance (size-1) == sum( (data[i] - mean)^2 ). the number of elements of the data sequence. the variance of the data sequence. returns the sum of squares of a data sequence. that is sum ( data[i]data[i] ). returns the trimmed mean of a sorted data sequence. the data sequence; must be sorted ascending. the mean of the (full) sorted data sequence. @left the number of leading elements to trim. @right the number of trailing elements to trim. returns the variance from a standard deviation. returns the variance of a data sequence. that is (sumofsquares - meansum) / size with mean = sum/size. the number of elements of the data sequence. == sum( data[i] ). == sum( data[i]data[i] ). returns the weighted mean of a data sequence. that is  sum (data[i] weights[i]) / sum ( weights[i] ). returns the weighted rms (root-mean-square) of a data sequence. that is sum( data[i] data[i] weights[i]) / sum( data[i] weights[i] ), or in other words sumofproducts / sumofsquaredproducts. == sum( data[i] weights[i] ). == sum( data[i] data[i] weights[i] ). returns the winsorized mean of a sorted data sequence. the data sequence; must be sorted ascending. the mean of the (full) sorted data sequence. @left the number of leading elements to trim. @right the number of trailing elements to trim. www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition. exercise for the reader: why does this give us the right answer? determine run length (number of equal elements) this version would easily results in overflows return math.pow(product, 1/size); read current values cool, huh? cool, huh? store new values at this point of return the following postcondition holds: data.size()-from elements have been consumed by this call. optimized for common parameters handle quicker if (element  max) max = element; if (element  max) max = element; handle quicker if (element  max) max = element; handle quicker now the most general case: optimized for maximum speed, but still not quite quick at this point of return the following postcondition holds: data.size()-fromindex elements have been consumed by this call. read current values store new values at this point of return the following postcondition holds: data.size()-from elements have been consumed by this call. sum += sign element found skip to the right over multiple occurances of element. element not found linear interpolation (y-ymean)^2/(n-1) (y-ymean)^4 sqrt( (y-ymean)^2/(n-1) ) (y-ymean)^3 the standard deviation calculated as the sqrt of the variance underestimates the unbiased standard deviation. it needs to be multiplied by this correction factor. cn = 1+1/(4(n-1)); find the sum of the squares assertion: data is sorted ascending. assertion: splitvalues is sorted ascending. splitvalue not found splitvalue found for multiple identical elements ("runs"), binarysearch does not define which of all valid indexes is returned. thus, skip over to the first element of a run. now fill the remainder optimized for speed"
cern.jet.stat.Gamma "gamma and beta functions.  implementation:  some code taken and adapted from the java 2d graph package 2.4, which in turn is a port from the cephes 2.2 math library (c). most cephes code (missing from the 2d graph package) directly ported. makes this class non instantiable, but still let's others inherit from it. returns the beta function of the arguments.  - - | (a) | (b) beta( a, b ) = -----------. - | (a+b)  returns the gamma function of the argument. returns the incomplete beta function evaluated from zero to xx; formerly named ibeta. the alpha parameter of the beta distribution. the beta parameter of the beta distribution. the integration end point. reverse a and b if x is greater than the mean. choose expansion for better convergence. multiply w by the factor a b _ _ _ x (1-x) | (a+b) / ( a | (a) | (b) ) . resort to logarithms. continued fraction expansion #1 for incomplete beta integral; formerly named incbcf. continued fraction expansion #2 for incomplete beta integral; formerly named incbd. returns the incomplete gamma function; formerly named igamma. the parameter of the gamma distribution. the integration end point. compute xa exp(-x) / gamma(a) power series returns the complemented incomplete gamma function; formerly named igamc. the parameter of the gamma distribution. the integration start point. continued fraction returns the natural logarithm of the gamma function; formerly named lgamma. 1.00000000000000000000e0, power series for incomplete beta integral; formerly named pseries. use when bx is small and x not too close to 1. returns the gamma function computed by stirling's formula; formerly named stirf. the polynomial stir is valid for 33 java 2d graph package 2.4, people.ne.mediaone.net/moshier/index.html#cephes">cephes 2.2 math library (c). double maxgam = 171.624376956302725; double logpi = 1.14472988584940017414; if( x > 1.0e8 ) return( q );"
cern.jet.stat.Probability "custom tailored numerical integration of certain probability distributions.  implementation:  some code taken and adapted from the java 2d graph package 2.4, which in turn is a port from the cephes 2.2 math library (c). most cephes code (missing from the 2d graph package) directly ported. coefficients for method normalinverse() approximation for 0 x under the beta density function.  x - - | (a+b) | | a-1 b-1 p(x) = ---------- | t (1-t) dt - - | | | (a) | (b) - 0  this function is identical to the incomplete beta integral function gamma.incompletebeta(a, b, x). the complemented function is 1 - p(1-x) = gamma.incompletebeta( b, a, x ); returns the area under the right hand tail (from x to infinity) of the beta density function. this function is identical to the incomplete beta integral function gamma.incompletebeta(b, a, x). returns the sum of the terms 0 through k of the binomial probability density.  k -- ( n ) j n-j > ( ) p (1-p) -- ( j ) j=0  the terms are not summed directly; instead the incomplete beta integral is employed, according to the formula  y = binomial( k, n, p ) = gamma.incompletebeta( n-k, k+1, 1-p ).  all arguments must be positive, end term. the number of trials. the probability of success (must be in (0.0,1.0)). returns the sum of the terms k+1 through n of the binomial probability density.  n -- ( n ) j n-j > ( ) p (1-p) -- ( j ) j=k+1  the terms are not summed directly; instead the incomplete beta integral is employed, according to the formula  y = binomialcomplemented( k, n, p ) = gamma.incompletebeta( k+1, n-k, p ).  all arguments must be positive, end term. the number of trials. the probability of success (must be in (0.0,1.0)). returns the area under the left hand tail (from 0 to x) of the chi square probability density function with v degrees of freedom.  inf. - 1 | | v/2-1 -t/2 p( x | v ) = ----------- | t e dt v/2 - | | 2 | (v/2) - x  where x is the chi-square variable.  the incomplete gamma integral is used, according to the formula  y = chisquare( v, x ) = incompletegamma( v/2.0, x/2.0 ).  the arguments must both be positive. degrees of freedom. integration end point. returns the area under the right hand tail (from x to infinity) of the chi square probability density function with v degrees of freedom.  inf. - 1 | | v/2-1 -t/2 p( x | v ) = ----------- | t e dt v/2 - | | 2 | (v/2) - x  where x is the chi-square variable. the incomplete gamma integral is used, according to the formula y = chisquarecomplemented( v, x ) = incompletegammacomplement( v/2.0, x/2.0 ). the arguments must both be positive. degrees of freedom. returns the error function of the normal distribution; formerly named erf. the integral is  x - 2 | | 2 erf(x) = -------- | exp( - t ) dt. sqrt(pi) | | - 0  implementation: for 0 ; otherwise erf(x) = 1 - erfc(x).  code adapted from the java 2d graph package 2.4, which in turn is a port from the cephes 2.2 math library (c). the argument to the function. returns the complementary error function of the normal distribution; formerly named erfc.  1 - erf(x) = inf. - 2 | | 2 erfc(x) = -------- | exp( - t ) dt sqrt(pi) | | - x  implementation: for small x, erfc(x) = 1 - erf(x); otherwise rational approximations are computed.  code adapted from the java 2d graph package 2.4, which in turn is a port from the cephes 2.2 math library (c). the argument to the function. returns the integral from zero to x of the gamma probability density function.  x b - a | | b-1 -at y = ----- | t e dt - | | | (b) - 0  the incomplete gamma integral is used, according to the relation y = gamma.incompletegamma( b, ax ). the paramater a (alpha) of the gamma distribution. the paramater b (beta, lambda) of the gamma distribution. integration end point. returns the integral from x to infinity of the gamma probability density function:  inf. b - a | | b-1 -at y = ----- | t e dt - | | | (b) - x  the incomplete gamma integral is used, according to the relation  y = gamma.incompletegammacomplement( b, ax ). the paramater a (alpha) of the gamma distribution. the paramater b (beta, lambda) of the gamma distribution. integration end point. returns the sum of the terms 0 through k of the negative binomial distribution.  k -- ( n+j-1 ) n j > ( ) p (1-p) -- ( j ) j=0  in a sequence of bernoulli trials, this is the probability that k or fewer failures precede the n-th success.  the terms are not computed individually; instead the incomplete beta integral is employed, according to the formula  y = negativebinomial( k, n, p ) = gamma.incompletebeta( n, k+1, p ). all arguments must be positive, end term. the number of trials. the probability of success (must be in (0.0,1.0)). returns the sum of the terms k+1 to infinity of the negative binomial distribution.  inf -- ( n+j-1 ) n j > ( ) p (1-p) -- ( j ) j=k+1  the terms are not computed individually; instead the incomplete beta integral is employed, according to the formula  y = negativebinomialcomplemented( k, n, p ) = gamma.incompletebeta( k+1, n, 1-p ). all arguments must be positive, end term. the number of trials. the probability of success (must be in (0.0,1.0)). returns the area under the normal (gaussian) probability density function, integrated from minus infinity to x (assumes mean is zero, variance is one).  x - 1 | | 2 normal(x) = --------- | exp( - t /2 ) dt sqrt(2pi) | | - -inf. = ( 1 + erf(z) ) / 2 = erfc(z) / 2  where z = x/sqrt(2). computation is via the functions errorfunction and errorfunctioncomplement. returns the area under the normal (gaussian) probability density function, integrated from minus infinity to x.  x - 1 | | 2 normal(x) = --------- | exp( - (t-mean) / 2v ) dt sqrt(2piv)| | - -inf.  where v = variance. computation is via the functions errorfunction. the mean of the normal distribution. the variance of the normal distribution. the integration limit. returns the value, x, for which the area under the normal (gaussian) probability density function (integrated from minus infinity to x) is equal to the argument y (assumes mean is zero, variance is one); formerly named ndtri.  for small arguments 0 , the program computes z = sqrt( -2.0 log(y) ); then the approximation is x = z - log(z)/z - (1/z) p(1/z) / q(1/z). there are two rational functions p/q, one for 0  and the other for y up to exp(-2). for larger arguments, w = y - 0.5, and x/sqrt(2pi) = w + w3 r(w2)/s(w2)). 0.135... = exp(-2) y > exp(-32) = 1.2664165549e-14 returns the sum of the first k terms of the poisson distribution.  k j -- -m m > e -- -- j! j=0  the terms are not summed directly; instead the incomplete gamma integral is employed, according to the relation  y = poisson( k, m ) = gamma.incompletegammacomplement( k+1, m ). the arguments must both be positive. number of terms. the mean of the poisson distribution. returns the sum of the terms k+1 to infinity of the poisson distribution.  inf. j -- -m m > e -- -- j! j=k+1  the terms are not summed directly; instead the incomplete gamma integral is employed, according to the formula  y = poissoncomplemented( k, m ) = gamma.incompletegamma( k+1, m ). the arguments must both be positive. start term. the mean of the poisson distribution. returns the integral from minus infinity to t of the student-t distribution with k &gt; 0 degrees of freedom.  t - | | - | 2 -(k+1)/2 | ( (k+1)/2 ) | ( x ) ---------------------- | ( 1 + --- ) dx - | ( k ) sqrt( k pi ) | ( k/2 ) | | | - -inf.  relation to incomplete beta integral:  1 - studentt(k,t) = 0.5 gamma.incompletebeta( k/2, 1/2, z ) where z = k/(k + t2).  since the function is symmetric about t=0, the area under the right tail of the density is found by calling the function with -t instead of t. degrees of freedom. integration end point. returns the value, t, for which the area under the student-t probability density function (integrated from minus infinity to t) is equal to 1-alpha/2. the value returned corresponds to usual student t-distribution lookup table for talpha[size].  the function uses the studentt function to determine the return value iteratively. probability size of data set www.sci.usq.edu.au/staff/leighb/graph/top.html">java 2d graph package 2.4, people.ne.mediaone.net/moshier/index.html#cephes">cephes 2.2 math library (c). www.sci.usq.edu.au/staff/leighb/graph/top.html">java 2d graph package 2.4, people.ne.mediaone.net/moshier/index.html#cephes">cephes 2.2 math library (c). 1.00000000000000000000e0, www.sci.usq.edu.au/staff/leighb/graph/top.html">java 2d graph package 2.4, people.ne.mediaone.net/moshier/index.html#cephes">cephes 2.2 math library (c). 1.0 1.00000000000000000000e0, fixes bug reported by stefan.bentink@molgen.mpg.de cumulative probability cumulative probability return inverse of normal for large size find a pair of x1,x2 that braket zero find better approximation pegasus-method calculate slope of secant and t value for which it is 0. calculate function value at x3 this criteria needs to be very tight! we found a perfect value -> return"
cern.jet.stat.quantile.Buffer "a buffer holding elements; internally used for computing approximate quantiles. this method was clears the receiver. returns whether the receiver is already allocated. returns whether the receiver is empty. returns whether the receiver is empty. returns whether the receiver is partial. returns whether the receiver's level. sets the receiver's level. returns the number of elements contained in the receiver. sorts the receiver. returns whether the receiver's weight. sets the receiver's weight."
cern.jet.stat.quantile.BufferSet "an abstract set of buffers; internally used for computing approximate quantiles."
cern.jet.stat.quantile.DoubleBuffer "a buffer holding double elements; internally used for computing approximate quantiles. this method was adds a value to the receiver. adds a value to the receiver. allocates the receiver. clears the receiver. returns a deep copy of the receiver. deep copy of the receiver. returns whether the specified element is contained in the receiver. returns whether the receiver is empty. returns whether the receiver is empty. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying algorithm. returns the rank of a given element within the sorted sequence of the receiver. a rank is the number of elements <= element. ranks are of the form {1,2,...size()}. if no element is <= element, then the rank is zero. if the element lies in between two contained elements, then uses linear interpolation. rank of the element. cern.colt.list.doublearraylist the element to search for returns the number of elements contained in the receiver. sorts the receiver. returns a string representation of the receiver. lazy buffer allocation can safe memory. lazy buffer allocation can safe memory. important: to do : replace mergesort with quicksort! currently it is mergesort only for debugging purposes (jdk 1.2 can't be imported into visualage). values.mergesort(); ", v=" + values.tostring();"
cern.jet.stat.quantile.DoubleBufferSet "a set of buffers holding double elements; internally used for computing approximate quantiles. constructs a buffer set with b buffers, each having k elements the number of buffers the number of elements per buffer returns an empty buffer if at least one exists. preferably returns a buffer which has already been used, i.e. a buffer which has already been allocated. returns all full or partial buffers. determines all full buffers having the specified level. full buffers having the specified level minimum level of all buffers which are full. returns the number of empty buffers. returns all empty buffers. number of buffers removes all elements from the receiver. the receiver will be empty after this call returns, and its memory requirements will be close to zero. removes all elements from the receiver. the receiver will be empty after this call returns, and its memory requirements will be close to zero. returns a deep copy of the receiver. deep copy of the receiver. collapses the specified full buffers (must not include partial buffer). full buffer containing the collapsed values. the buffer has accumulated weight. the buffers to be collapsed (all of them must be full or partially full) returns whether the specified element is contained in the receiver. applies a procedure to each element of the receiver, if any. iterates over the receiver in no particular order. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. determines all values of the specified buffers positioned at the specified triggerpositions within the sorted sequence and fills them into outputvalues. the buffers to be searched (all must be full or partial) the positions of elements within the sorted sequence to be retrieved a list filled with the values at triggerpositions number of elements within a buffer. returns the number of elements currently needed to store all contained elements. computes the next triggerposition for collapse next triggerposition for collapse specifies that the j-th trigger position is to be computed the accumulated weights returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. element to search for. percentage p of elements &lt;= element (0.0 &lt;= p &lt;=1.0). string representation of the receiver returns the number of elements in all buffers. tmp var only count buffers collect buffers count buffers collect buffers determine w sum of all weights determine outputtriggerpositions do the main work: determine values at given positions in sorted sequence mark all full buffers as empty, except the first, which will contain the output if (buffers.length==0) { throw new illegalargumentexception("oops! buffer.length==0."); } system.out.println("triggers="+cern.it.util.arrays.tostring(positions)); new doublearraylist(outputvalues).fillfromtowith(0, outputvalues.length-1, 0.0f); delte the above line, it is only for testing cern.it.util.log.println("\nentering getvaluesatpositions..."); cern.it.util.log.println("hitpositions="+cern.it.util.arrays.tostring(positions)); sort buffers. collect some infos into fast cache; for tuning purposes only. cern.it.util.log.println("buffer["+i+"]="+buffers[i].values); prepare merge of equi-distant elements within buffers into output values first collect some infos into fast cache; for tuning purposes only. now prepare the important things. current position in collapsed values current position in each buffer; init with zeroes current position in sorted sequence next position in sorted sequence to trigger output population nothing to output, because no elements have been filled (we are empty). return meaningless values fill all output values with equi-distant elements. system.out.println("\nj="+j); system.out.println("counter="+counter); system.out.println("nexthit="+nexthit); determine buffer with smallest value at cursor position. doublebuffer buffer = buffers[b]; if (cursors[b] < buffer.length) { /double value = buffer.values[cursors[b]]; trigger copies into output sequence, if necessary. system.out.println("adding to output="+minvalue); that element has now been treated, move further. system.out.println("cursors="+cern.it.util.arrays.tostring(cursors)); end while (j<k) cern.it.util.log.println("returning output="+cern.it.util.arrays.tostring(outputvalues)); is w odd? w is even alternate between both possible next hit positions upon successive invocations"
cern.jet.stat.quantile.DoubleQuantileEstimator "the abstract base class for approximate quantile finders computing quantiles over a sequence of double elements. makes this class non instantiable, but still let's others inherit from it. adds a value to the receiver. the value to add. adds all values of the specified list to the receiver. the list of which all values shall be added. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). // the obvious version, but we can do quicker... double[] thevalues = values.elements(); int thesize=values.size(); for (int i=0; ifalse, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. not yet commented. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. element to search for. percentage p of elements &lt;= element (0.0 &lt;= p &lt;=1.0). not yet commented. default implementation does nothing. computes the specified quantile elements over the values previously added. the quantiles for which elements are to be computed. each phi must be in the interval [0.0,1.0]. phis must be sorted ascending. approximate quantile elements. //check parameter doublearraylist sortedphilist = phis.copy(); sortedphilist.sort(); if (! phis.equals(sortedphilist)) { throw new illegalargumentexception("phis must be sorted ascending."); } not yet commented. initializes the receiver returns the number of elements currently contained in the receiver (identical to the number of values added so far). returns a string representation of the receiver. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. abstract class approximatedoublequantilefinder extends object implements doublequantilefinder { system.out.println("adding "+value); the obvious version, but we can do quicker... full full check parameter system.out.println("starting to augment missing values, if necessary..."); system.out.println("triggerpositions="+cern.colt.arrays.tostring(triggerpositions)); system.out.println("starting to determine quantiles..."); system.out.println(bufferset); do the main work: determine values at given positions in sorted sequence"
cern.jet.stat.quantile.DoubleQuantileFinder "the interface shared by all quantile finders, no matter if they are exact or approximate. it is usually completely sufficient to operate on this interface only. also see {@link hep.aida.bin.quantilebin1d}, demonstrating how this package can be used. adds a value to the receiver. the value to add. adds all values of the specified list to the receiver. the list of which all values shall be added. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). removes all elements from the receiver. the receiver will be empty after this call returns, and its memory requirements will be close to zero. returns a deep copy of the receiver. deep copy of the receiver. applies a procedure to each element of the receiver, if any. iterates over the receiver in no particular order. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. writing a wrapper is a good idea if you can think of better ways of doing interpolation. same if you want to keep min,max and other such measures. element to search for. percentage p of elements &lt;= element (0.0 &lt;= p &lt;=1.0). computes the specified quantile elements over the values previously added. the quantiles for which elements are to be computed. each phi must be in the interval [0.0,1.0]. phis must be sorted ascending. quantile elements. returns the number of elements currently contained in the receiver (identical to the number of values added so far). returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. public interface doublequantilefinder extends com.objy.db.iapp.persistentevents, java.io.serializable {"
cern.jet.stat.quantile.EquiDepthHistogram "read-only equi-depth histogram for selectivity estimation. assume you have collected statistics over a data set, among them a one-dimensional equi-depth histogram (quantiles). then an applications or dbms might want to estimate the selectivity of some range query [from,to], i.e. the percentage of data set elements contained in the query range. this class does not collect equi-depth histograms but only space efficiently stores already produced histograms and provides operations for selectivity estimation. uses linear interpolation.  this class stores a list l of float values for which holds: let v be a list of values (sorted ascending) an equi-depth histogram has been computed over. let s=l.length. let p=(0, 1/s-1), 2/s-1,..., s-1/s-1=1.0) be a list of the s percentages. then for each i=0..s-1: l[i] = e : v.contains(e) && v[0],..., v[p[i]v.length] &lt;= e. (in particular: l[0]=min(v)=v[0] and l[s-1]=max(v)=v[s-1].) constructs an equi-depth histogram with the given quantile elements. quantile elements must be sorted ascending and have the form specified in the class documentation. returns the bin index of the given element. in other words, returns a handle to the range the element falls into. the element to search for. @throws java.lang.illegalargumentexception if the element is not contained in any bin. returns the number of bins. in other words, returns the number of subdomains partitioning the entire value domain. returns the end of the range associated with the given bin. @throws arrayindexoutofboundsexception if binindex &lt; 0 || binindex &gt;= bins(). returns the percentage of elements in the range (from,to]. does linear interpolation. the start point (exclusive). the end point (inclusive). @returns a number in the closed interval [0.0,1.0]. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation. element to search for. @returns a number in the closed interval [0.0,1.0]. @deprecated deprecated. returns the number of bin boundaries. returns the start of the range associated with the given bin. @throws arrayindexoutofboundsexception if binindex &lt; 0 || binindex &gt;= bins(). not yet commented. element found. last bin is a closed interval. element not found. index = -index-1; now index is the insertion point. int index = new floatarraylist(binboundaries).binarysearch(element); found do linear interpolation"
cern.jet.stat.quantile.ExactDoubleQuantileFinder "exact quantile finding algorithm for known and unknown n requiring large main memory; computes quantiles over a sequence of double elements. the folkore algorithm: keeps all elements in main memory, sorts the list, then picks the quantiles. constructs an empty exact quantile finder. adds a value to the receiver. the value to add. adds all values of the specified list to the receiver. the list of which all values shall be added. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). removes all elements from the receiver. the receiver will be empty after this call returns, and its memory requirements will be close to zero. returns a deep copy of the receiver. deep copy of the receiver. returns whether the specified element is contained in the receiver. applies a procedure to each element of the receiver, if any. iterates over the receiver in no particular order. the procedure to be applied. stops iteration if the procedure returns false, otherwise continues. false if the procedure stopped before all elements where iterated over, true otherwise. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. element to search for. percentage p of elements &lt;= element (0.0 &lt;= p &lt;=1.0). computes the specified quantile elements over the values previously added. the quantiles for which elements are to be computed. each phi must be in the interval [0.0,1.0]. phis must be sorted ascending. exact quantile elements. int buffersize = (int) this.size(); double[] quantileelements = new double[phis.size()]; for (int i=phis.size(); --i >=0;) { int rank=(int)utils.epsilonceiling(phis.get(i)buffersize) -1; quantileelements[i]=buffer.get(rank); } return new doublearraylist(quantileelements); returns the number of elements currently contained in the receiver (identical to the number of values added so far). sorts the receiver. returns a string representation of the receiver. returns the number of elements currently needed to store all contained elements. this number usually differs from the results of method size(), according to the underlying datastructure. class exactdoublequantilefinder extends object implements doublequantilefinder { important: to do : replace mergesort with quicksort! currently it is mergesort because jdk 1.2 can't be imported into visualage. this.buffer.mergesort();"
cern.jet.stat.quantile.KnownDoubleQuantileEstimator "approximate quantile finding algorithm for known n requiring only one pass and little main memory; computes quantiles over a sequence of double elements. needs as input the following parameters: 1. n - the number of values of the data sequence over which quantiles are to be determined. 2. quantiles - the number of quantiles to be computed. 3. epsilon - the allowed approximation error on quantiles. the approximation guarantee of this algorithm is explicit. it is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. with sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a ( constructs an approximate quantile finder with b buffers, each having k elements. the number of buffers the number of elements per buffer the total number of elements over which quantiles are to be computed. 1.0 --> all elements are consumed. 10.0 --> consumes one random element from successive blocks of 10 elements each. etc. a uniform random number generator. the number of infinities to fill. the buffer into which the infinities shall be filled. not yet commented. removes all elements from the receiver. the receiver will be empty after this call returns, and its memory requirements will be close to zero. returns a deep copy of the receiver. deep copy of the receiver. not yet commented. for (int i=0; iphis must be sorted ascending. approximate quantile elements. the known quantile finder reads off quantiles from full buffers only. since there might be a partially full buffer, this method first satisfies this constraint by temporarily filling a few +infinity, -infinity elements to make up a full block. this is in full conformance with the explicit approximation guarantees. for those of you working on online apps: the approximation guarantees are given for computing quantiles after n elements have been filled, not for intermediate displays. if you have one thread filling and another thread displaying concurrently, you will note that in the very beginning the infinities will dominate the display. this could confuse reading off quantiles requires to fill some +infinity, -infinity values to make a partial buffer become full. this method removes the infinities which were previously temporarily added to a partial buffer. removing them is necessary if we want to continue filling more elements. precondition: the buffer is sorted ascending. the number of infinities previously filled. the buffer into which the infinities were filled. not yet commented. this is a known n quantile finder! one should not try to fill more than n elements, because otherwise we can't give explicit approximation guarantees anymore. use an unknown quantile finder instead if your app may fill more than n elements. however, to make this class meaningful even under wired use cases, we actually do allow to fill more than n elements (without explicit approx. guarantees, of course). normally, elements beyond n will not get sampled because the sampler is exhausted. therefore the histogram will no more change no matter how much you fill. this might not be what the www-cad.eecs.berkeley.edu/~manku"> here. correction factor for phis see method samplenextelement() see method samplenextelement() switch off sampler double[] infinities = new double[missinginfinities]; if (even) {infinities[i]=double.max_value;} else {infinities[i]=-double.max_value;} if (even) {this.add(double.max_value);} else {this.add(-double.max_value);} buffer.values.addalloffromto(new doublearraylist(infinities),0,missinginfinities-1); this.totalelementsfilled -= infinities; switch on sampler again this.setsamplingrate(samplingrate,n); doublebuffer[] emptybuffers = this.bufferset._getemptybuffers(); currentbuffertofill.state = doublebuffer.partial; any auxiliary infinities needed? system.out.println("adding "+missingvalues+" infinity elements..."); determine beta (n + infinity values = beta n) restore state we were in before. remove the temporarily added infinities. now you can continue filling the remaining values, if any. count them (this is not very clever but it's safe) this.totalelementsfilled -= infinities; if ((totalelementsfilled-1) % n == 0) setsamplingrate(samplingrate, n); // delete if appropriate"
cern.jet.stat.quantile.Quantile1Test "a class to test the quantilebin1d code. the command line is "java quantile1test numexamples n" where numexamples is the number of random (gaussian) numbers to be presented to the quantilebin1d.add method, and n is the absolute maximum number of examples the quantilebin1d is setup to receive in the constructor. n can be set to "l", which will use long.max_value, or to "i", which will use integer.max_value, or to any positive long value. get the number of examples from the first argument get n from the second argument set up the quantilebin1d object use a new random number generator to generate numexamples random gaussians, and add them to the quantilebin1d print out the percentiles int step = 1;"
cern.jet.stat.quantile.QuantileCalc "computes b and k vor various parameters. efficiently computes the binomial coefficient, often also referred to as "n over k" or "n choose k". the binomial coefficient is defined as n!/((n-k)!k!). tries to avoid numeric overflows. binomial coefficient. returns the smallest long &gt;= value. examples: 1.0 -> 1, 1.2 -> 2, 1.9 -> 2. this method is safer than using (long) math.ceil(value), because of possible rounding error. computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. assumes that quantiles are to be computed over n values. the required sampling rate is computed and stored in the first element of the provided returnsamplingrate array, which, therefore must be at least of length 1. the number of values over which quantiles shall be computed (e.g 10^6). the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to avoid probabilistic answers, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. a double[1] where the sampling rate is to be filled in. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer, returnsamplingrate[0]=the required sampling rate. computes the number of buffers and number of values per buffer such that quantiles can be determined with a guaranteed approximation error no more than epsilon. assumes that quantiles are to be computed over n values. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer. the anticipated number of values over which quantiles shall be determined. the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. assumes that quantiles are to be computed over n values. the required sampling rate is computed and stored in the first element of the provided returnsamplingrate array, which, therefore must be at least of length 1. the anticipated number of values over which quantiles shall be computed (e.g 10^6). the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to avoid probabilistic answers, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. a double[1] where the sampling rate is to be filled in. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer, returnsamplingrate[0]=the required sampling rate. computes b and k for different parameters. computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact results, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to get exact results, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. long[3] - long[0]=the number of buffers, long[1]=the number of elements per buffer, long[2]=the tree height where sampling shall start. double d = (ld(h+max_h-1.0) + ls((h+1)pow - 2.0(h+max_h))) / (ld + ls(pow-2.0)); d = (d + 2.0) / (2.0epsilon); since binomial(n,k)==binomial(n,n-k), we can enforce the faster variant, which is also the variant minimizing number overflows. no way around exact quantile search for each b, determine maximum height, i.e. the height for which x0 go back to last height was x>0 or did we loop without finding anything? safe some space end for for each b, determine the smallest k satisfying the constraints, i.e. for each b, determine kmin, with kmin = n/binomial(b+hmax-2,hmax-1) from all b's, determine b that minimizes bkmin epsilon large enough? epsilon is very small or zero. the only possible solution without violating the approximation guarantees is exact quantile search. delta can be set to zero, i.e., all quantiles should be approximate with probability 1 no way around exact quantile search one possibility is to use one buffer of size n  otherwise, there are at least two buffers (b >= 2) and the height of the tree is at least three (h >= 3)  we restrict the search for b and h to max_binom, a large enough value for practical values of epsilon >= 0.001 and delta >= 0.00001  from our sigmod 98 paper, we have two equantions to satisfy: t = w/(1-alpha)^2  denoting 1/(1-alpha) by x, we see that the first inequality is equivalent to t/u = 0.5 + 0.5 sqrt (1 + 4t/u) plugging in this value into second equation yields k >= wx^2/v delta can be set to zero, i.e., all quantiles should be approximate with probability 1 no way around exact quantile search double logdelta = math.log(2.0/(quantilesdelta)) / (2.0epsilonepsilon); until we find a solution identify that combination of b and h that minimizes bk. exhaustive search. now we have k>=c(1-alpha)^-2. let's compute c. double c = math.log(2.0/(delta/quantiles)) / (2.0epsilonepsilonmath.min(ld, 8.0ls/3.0)); now we have k>=d/alpha. let's compute d. now we have c(1-alpha)^-2 == d/alpha. we solve this equation for alpha yielding two solutions alpha_1,2 = (c + 2d +- sqrt(cc + 4cd))/(2d) non real solution to equation any alpha must satisfy 0<alpha<1 to yield valid solutions take the alpha that minimizes d/alpha now we have k=ceiling(max(d/alpha, (h+1)/(2epsilon))) valid solution? found a solution requiring less memory end for h end for b no solution found so far. very unlikely. anyway, try again. end while no solution found. no way around exact quantile search."
cern.jet.stat.quantile.QuantileFinderFactory "factory constructing exact and approximate quantile finders for both known and unknown n. also see {@link hep.aida.bin.quantilebin1d}, demonstrating how this package can be used. the approx. algorithms compute approximate quantiles of large data sequences in a single pass. the approximation guarantees are explicit, and apply for arbitrary value distributions and arrival distributions of the data sequence. the main memory requirements are smaller than for any other known technique by an order of magnitude. the approx. algorithms are primarily intended to help applications scale. when faced with a large data sequences, traditional methods either need very large memories or time consuming disk based sorting. in constrast, the approx. algorithms can deal with > 10^10 values without disk based sorting. all classes can be seen from various angles, for example as 1. algorithm to compute quantiles. 2. 1-dim-equi-depth histogram. 3. 1-dim-histogram arbitrarily rebinnable in real-time. 4. a space efficient multiset data structure using lossy compression. 5. a space efficient value preserving bin of a 2-dim or d-dim histogram. (all subject to an accuracy specified by the make this class non instantiable. let still allow others to inherit. computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. assumes that quantiles are to be computed over n values. the required sampling rate is computed and stored in the first element of the provided returnsamplingrate array, which, therefore must be at least of length 1. the number of values over which quantiles shall be computed (e.g 10^6). the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to avoid probabilistic answers, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. output parameter, a double[1] where the sampling rate is to be filled in. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer, returnsamplingrate[0]=the required sampling rate. computes the number of buffers and number of values per buffer such that quantiles can be determined with a guaranteed approximation error no more than epsilon. assumes that quantiles are to be computed over n values. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer. the anticipated number of values over which quantiles shall be determined. the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. assumes that quantiles are to be computed over n values. the required sampling rate is computed and stored in the first element of the provided returnsamplingrate array, which, therefore must be at least of length 1. the anticipated number of values over which quantiles shall be computed (e.g 10^6). the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact result, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to avoid probabilistic answers, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. a double[1] where the sampling rate is to be filled in. long[2] - long[0]=the number of buffers, long[1]=the number of elements per buffer, returnsamplingrate[0]=the required sampling rate. returns a quantile finder that minimizes the amount of memory needed under the convenience method that computes phi's for equi-depth histograms. this is simply a list of numbers with i / (double)quantiles for i={1,2,...,quantiles-1}. equi-depth phi's computes the number of buffers and number of values per buffer such that quantiles can be determined with an approximation error no more than epsilon with a certain probability. the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact results, set epsilon=0.0; the probability that the approximation error is more than than epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to get exact results, set delta=0.0. the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000. long[4] - long[0]=the number of buffers, long[1]=the number of elements per buffer, long[2]=the tree height where sampling shall start, long[3]==1 if precomputing is better, otherwise 0; long[] result_1 = unknown_n_compute_b_and_k_raw(epsilon,delta,quantiles); long b1 = result_1[0]; long k1 = result_1[1]; int quantilestoprecompute = (int) doubles.ceiling(1.0 / epsilon); if (quantiles>quantilestoprecompute) { // try if precomputing quantiles requires less memory. long[] result_2 = unknown_n_compute_b_and_k_raw(epsilon/2.0,delta,quantilestoprecompute); long b2 = result_2[0]; long k2 = result_2[1]; if (b2k2 you never need to call this method. it is only for curious double d = (ld(h+max_h-1.0) + ls((h+1)pow - 2.0(h+max_h))) / (ld + ls(pow-2.0)); d = (d + 2.0) / (2.0epsilon); import cern.it.util.doubles; www-cad.eecs.berkeley.edu/~manku/papers/quantiles.ps.gz"> here. www-cad.eecs.berkeley.edu/~manku/papers/unknown.ps.gz"> here. no way around exact quantile search can make any error we wish for each b, determine maximum height, i.e. the height for which x0 go back to last height was x>0 or did we loop without finding anything? safe some space end for for each b, determine the smallest k satisfying the constraints, i.e. for each b, determine kmin, with kmin = n/binomial(b+hmax-2,hmax-1) from all b's, determine b that minimizes bkmin epsilon large enough? epsilon is very small or zero. the only possible solution without violating the approximation guarantees is exact quantile search. one possibility is to use one buffer of size n  otherwise, there are at least two buffers (b >= 2) and the height of the tree is at least three (h >= 3)  we restrict the search for b and h to max_binom, a large enough value for practical values of epsilon >= 0.001 and delta >= 0.00001  from our sigmod 98 paper, we have two equantions to satisfy: t = w/(1-alpha)^2  denoting 1/(1-alpha) by x, we see that the first inequality is equivalent to t/u = 0.5 + 0.5 sqrt (1 + 4t/u) plugging in this value into second equation yields k >= wx^2/v boolean known_n = true; if (n==long.max_value) known_n = false; check parameters. if they are illegal, keep quite and return an exact finder. if (n==long.max_value) { // no maximum n provided by if (true) fixes bug reported by larryperanich@fairisaac.com no maximum n provided by determine whether unknownfinder or knownfinder with maximum n requires less memory. important: for known finder, switch sampling off (delta == 0) !!! with knownn-sampling we can only guarantee the errors if the input sequence has exactly n elements. with knownn-no sampling we can also guarantee the errors for sequences smaller than n elements. the knownfinder is smaller the unknownfinder is smaller move stuff from _raw(..) here and delete _raw(...) try if precomputing quantiles requires less memory. precomputation is better delta can be set to zero, i.e., all quantiles should be approximate with probability 1 can make any error we wish no way around exact quantile search double logdelta = math.log(2.0/(quantilesdelta)) / (2.0epsilonepsilon); until we find a solution identify that combination of b and h that minimizes bk. exhaustive search. now we have k>=c(1-alpha)^-2. let's compute c. double c = math.log(2.0/(delta/quantiles)) / (2.0epsilonepsilonmath.min(ld, 8.0ls/3.0)); now we have k>=d/alpha. let's compute d. now we have c(1-alpha)^-2 == d/alpha. we solve this equation for alpha yielding two solutions alpha_1,2 = (c + 2d +- sqrt(cc + 4cd))/(2d) non real solution to equation any alpha must satisfy 0<alpha<1 to yield valid solutions take the alpha that minimizes d/alpha now we have k=ceiling(max(d/alpha, (h+1)/(2epsilon))) valid solution? found a solution requiring less memory end for h end for b no solution found so far. very unlikely. anyway, try again. end while no solution found. no way around exact quantile search."
cern.jet.stat.quantile.QuantileFinderTest "a class holding test cases for exact and approximate quantile finders. finds the first and last indexes of a specific element within a sorted list. [] cern.colt.list.doublearraylist the element to search for observed epsilon observed epsilon observed epsilon this method was this method was not yet commented. this method was double[] returnsamplingrate = new double[1]; long[] result; if (known_n) { result = quantilefinderfactory.known_n_compute_b_and_k(n, epsilon, delta, p, returnsamplingrate); } else { result = quantilefinderfactory.unknown_n_compute_b_and_k(epsilon, delta, p); long b1 = result[0]; long k1 = result[1]; if (n>=0) { long[] resultknown = quantilefinderfactory.known_n_compute_b_and_k(n, epsilon, delta, p, returnsamplingrate); long b2 = resultknown[0]; long k2 = resultknown[1]; if (b2 k2 =0) mem = n; system.out.print(" (e,d,n,p)=("+epsilon+","+delta+","+n+","+p+") --> "); system.out.print("(mem,b,k,memf"); if (known_n) system.out.print(",sampling"); system.out.print(")=("+(math.round(bk/1000.0))+","+b+","+k+", "+math.round(bk8/1024.0/1024.0)); system.out.print(")=("+bk/1000.0+","+b+","+k+", "+bk8/1024.0/1024.0+", "+math.round(bk8/1024.0/1024.0)); if (known_n) system.out.print(","+returnsamplingrate[0]); cern.it.util.log.enablelogging(args[3].equals("log")); int quantiles = phis.length; new unknownapproximatedoublequantilefinder(b,k); approxfinder = new approximatedoublequantilefinder(b,k); system.out.println("unshuffled="+list); system.out.println("shuffled="+list); list.sort(); system.out.println("sorted="+list); system.out.println("free="+runtime.getruntime().freememory()); system.out.println("total="+runtime.getruntime().totalmemory()); approxfinder.close(); system.out.println("maxlevel of full buffers="+maxleveloffullbuffers(approxfinder.bufferset)); system.out.println("total buffers filled="+ approxfinder.totalbuffersfilled); system.out.println("free="+runtime.getruntime().freememory()); system.out.println("total="+runtime.getruntime().totalmemory()); exactfinder.close(); double[] errors1 = errors1(exactquantiles.elements(), approxquantiles.elements()); system.out.println("error1="+new doublearraylist(errors1)); system.out.println(rankofwithin(5.0f, list));"
cern.jet.stat.quantile.UnknownDoubleQuantileEstimator "approximate quantile finding algorithm for unknown n requiring only one pass and little main memory; computes quantiles over a sequence of double elements. this algorithm requires at most two times the memory of a corresponding approx. quantile finder knowing n. needs as input the following parameters: 1. quantiles - the number of quantiles to be computed. 2. epsilon - the allowed approximation error on quantiles. the approximation guarantee of this algorithm is explicit. it is also possible to couple the approximation algorithm with random sampling to further reduce memory requirements. with sampling, the approximation guarantees are explicit but probabilistic, i.e. they apply with respect to a ( constructs an approximate quantile finder with b buffers, each having k elements. the number of buffers the number of elements per buffer the tree height at which sampling shall start. the epsilon for which quantiles shall be precomputed; set this value phis must be sorted ascending. approximate quantile elements. if (phis.size() > quantilestoprecompute) { // illegal use case! // we compute results, but loose explicit approximation guarantees. return super.quantileelements(phis); } not yet commented. to do. this could faster be done without sorting (min and second min). returns a string representation of the receiver. www-cad.eecs.berkeley.edu/~manku"> here. if there is only one buffer at the lowest level, then increase its level so that there are at least two at the lowest level. delta for unknown finder illegal use case! we compute results, but loose explicit approximation guarantees. select that quantile from the precomputed set that corresponds to a position closest to phi. finds closest"
cern.jet.stat.quantile.Utils "holds some utility methods shared by different quantile finding implementations. makes this class non instantiable, but still let's others inherit from it. similar to math.ceil(value), but adjusts small numerical rounding errors +- epsilon."
corejava.Format "format - printf style formatting for java copyright (c) 1995...2002 cay s. horstmann (http://horstmann.com) this library is free software; you can redistribute it and/or modify it under the terms of the gnu lesser general public license as published by the free software foundation; either version 2.1 of the license, or (at your option) any later version. this library is distributed in the hope that it will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose. see the gnu lesser general public license for more details. you should have received a copy of the gnu lesser general public license along with this library; if not, write to the free software foundation, inc., 59 temple place, suite 330, boston, ma 02111-1307 usa a class for formatting numbers that follows printf conventions. also implements c-like atoi and atof functions @version 1.22 2002-11-16 formats the number following printf conventions. main limitation: can only handle one format parameter at a time use multiple format objects to format more than one number the format string following printf conventions the string has a prefix, a format code and a suffix. the prefix and suffix become part of the formatted output. the format code directs the formatting of the (single) parameter to be formatted. the code has the following structure   a % (required)  a modifier (optional)   +  forces display of + for positive numbers  0  show leading zeroes  -  align left in the field  space  prepend a space in front of positive numbers  #  use "alternate" format. add 0 or 0x for octal or hexadecimal numbers. don't suppress trailing zeroes in general floating point format.   an integer denoting field width (optional)  a period followed by an integer denoting precision (optional)  a format descriptor (required)  f  floating point number in fixed format e, e  floating point number in exponential notation (scientific format). the e format results in an uppercase e for the exponent (1.14130e+003), the e format in a lowercase e. g, g  floating point number in general format (fixed format for small numbers, exponential format for large numbers). trailing zeroes are suppressed. the g format results in an uppercase e for the exponent (if any), the g format in a lowercase e. d, i  integer in decimal x  integer in hexadecimal o  integer in octal s  string c  character   @exception illegalargumentexception if bad format prints a formatted number following printf conventions the format string the double to print prints a formatted number following printf conventions the format string the int to print prints a formatted number following printf conventions the format string the long to print prints a formatted number following printf conventions the format string the character to print prints a formatted number following printf conventions the format string a string to print converts a string of digits (decimal, octal or hex) to an integer a string numeric value of the prefix of s representing a base 10 integer converts a string of digits (decimal, octal or hex) to a long integer a string numeric value of the prefix of s representing a base 10 integer converts a string of digits to a double a string formats a double into a string (like sprintf in c) the number to format formatted string @exception illegalargumentexception if bad argument formats an integer into a string (like sprintf in c) the number to format formatted string formats a long integer into a string (like sprintf in c) the number to format formatted string formats a character into a string (like sprintf in c) the value to format formatted string formats a string into a larger string (like sprintf in c) the value to format formatted string a test stub for the format class horstmann.com) 0 = prefix, 1 = flags, 2 = width, 3 = precision, 4 = format, 5 = end integer part fractional part exponent of fractional part 0 = int part, 1 = frac part regression test to confirm fix of reported bugs 2000-06-09 remove trailing zeroes and decimal point fractional part csh 10-25-97 2000-06-09 one of cdeefggiosxxos"
hep.aida.bin.AbstractBin "abstract base class for all arbitrary-dimensional bins consumes double elements. first see the package summary and javadoc tree view to get the broad picture.  this class is fully thread safe (all public methods are synchronized). thus, you can have one or more threads adding to the bin as well as one or more threads reading and viewing the statistics of the bin while it is filled. for high performance, add data in large chunks (buffers) via method addallof rather than piecewise via method add. makes this class non instantiable, but still let's others inherit from it. returns center(0). returns a custom definable "center" measure; override this method if necessary. returns the absolute or relative center of this bin. for example, the center of gravity. the real absolute center can be obtained as follow: partition(i).min(j) bin(j).offset() + bin(j).center(i), where i is the dimension. and j is the index of this bin. this default implementation always returns 0.5. the dimension to be considered (zero based). removes all elements from the receiver. the receiver will be empty after this call returns. returns whether two objects are equal; this default implementation returns true if the other object is a bin and has the same size, value, error and center. returns error(0). returns a custom definable error measure; override this method if necessary. this default implementation always returns 0. the dimension to be considered. returns whether a client can obtain all elements added to the receiver. in other words, tells whether the receiver internally preserves all added elements. if the receiver is rebinnable, the elements can be obtained via elements() methods. returns offset(0). returns the relative or absolute position for the center of the bin; override this method if necessary. returns 1.0 if a relative center is stored in the bin. returns 0.0 if an absolute center is stored in the bin. this default implementation always returns 1.0 (relative). the index of the considered dimension (zero based); returns the number of elements contained. @returns the number of elements contained. returns a string representation of the receiver. buf.append("\nvalue: "+value()); buf.append("\nerror: "+error()); buf.append("\nrms: "+rms()+"\n"); trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. this default implementation does nothing. returns value(0). returns a custom definable "value" measure; override this method if necessary. this default implementation always returns 0.0. the dimension to be considered."
hep.aida.bin.AbstractBin1D "abstract base class for all 1-dimensional bins consumes double elements. first see the package summary and javadoc tree view to get the broad picture.  this class is fully thread safe (all public methods are synchronized). thus, you can have one or more threads adding to the bin as well as one or more threads reading and viewing the statistics of the bin while it is filled. for high performance, add data in large chunks (buffers) via method addallof rather than piecewise via method add. makes this class non instantiable, but still let's others inherit from it. adds the specified element to the receiver. element to be appended. adds all values of the specified list to the receiver. the list of which all values shall be added. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. you may want to override this method for performance reasons. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). @throws indexoutofboundsexception if list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size()). constructs and returns a streaming buffer connected to the receiver. whenever the buffer is full it's contents are automatically flushed to this. (addding elements via a buffer to a bin is significantly faster than adding them directly.) the number of elements the buffer shall be capable of holding before overflowing and flushing to the receiver. streaming buffer having the receiver as target. computes the deviations from the receiver's measures to another bin's measures. the other bin to compare with summary of the deviations. returns whether two bins are equal; they are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum and sumofsquares. returns the maximum. returns the arithmetic mean, which is sum( x[i] ) / size(). returns the minimum. computes the relative error (in percent) from one measure to another. returns the rms (root mean square), which is math.sqrt( sum( x[i]x[i] ) / size() ). returns the sample standard deviation, which is math.sqrt(variance()). returns the sample standard error, which is math.sqrt(variance() / size()) returns the sum of all elements, which is sum( x[i] ). returns the sum of squares, which is sum( x[i] x[i] ). returns a string representation of the receiver. buf.append("\nvalue: "+value()); buf.append("\nerror(0): "+error(0)); trims the capacity of the receiver to be the receiver's current size. releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. this default implementation does nothing. returns the sample variance, which is sum( (x[i]-mean())2 ) / (size()-1)."
hep.aida.bin.BinBinFunction1D "interface that represents a function object: a function that takes two bins as arguments and returns a single value. applies a function to two bin arguments. the first argument passed to the function. the second argument passed to the function. result of the function."
hep.aida.bin.BinFunction1D "interface that represents a function object: a function that takes two bins as arguments and returns a single value. applies a function to one bin argument. the argument passed to the function. result of the function. returns the name of this function. name of this function."
hep.aida.bin.BinFunctions1D "function objects computing dynamic bin aggregations; to be passed to generic methods. @see cern.colt.matrix.doublealgo.formatter @see cern.colt.matrix.doublealgo.statistic little trick to allow for "aliasing", that is, renaming this class. using the aliasing you can instead write  binfunctions f = binfunctions.functions;  somealgo(f.max); function that returns bin.max(). function that returns bin.mean(). function that returns bin.median(). function that returns bin.min(). function that returns bin.rms(). function that returns bin.size(). function that returns bin.standarddeviation(). function that returns bin.sum(). function that returns bin.sumoflogarithms(). function that returns bin.geometricmean(). makes this class non instantiable, but still let's others inherit from it. function that returns bin.quantile(percentage). percentage of the quantile (0 )."
hep.aida.bin.DynamicBin1D "1-dimensional rebinnable bin holding double elements; efficiently computes advanced statistics of data sequences. technically speaking, a multiset (or bag) with efficient statistics operations defined upon. first see the package summary and javadoc tree view to get the broad picture.  the data filled into a dynamicbin1d is internally preserved in the bin. as a consequence this bin can compute more than only basic statistics. on the other hand side, if you add huge amounts of elements, you may run out of memory (each element takes 8 bytes). if this drawbacks matter, consider to use {@link staticbin1d}, which overcomes them at the expense of limited functionality.  this class is fully thread safe (all public methods are synchronized). thus, you can have one or more threads adding to the bin as well as one or more threads reading and viewing the statistics of the bin while it is filled. for high performance, add data in large chunks (buffers) via method addallof rather than piecewise via method add.  if your favourite statistics measure is not directly provided by this class, check out {@link cern.jet.stat.descriptive} in combination with methods {@link #elements()} and {@link #sortedelements()}.  implementation: lazy evaluation, caching, incremental maintainance. @see cern.jet.stat.descriptive the elements contained in this bin. the elements contained in this bin, sorted ascending. preserve element order under all circumstances? constructs and returns an empty bin; implicitly calls {@link #setfixedorder(boolean) setfixedorder(false)}. adds the specified element to the receiver. element to be appended. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). @throws indexoutofboundsexception if list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size()). applies a function to each element and aggregates the results. returns a value v such that v==a(size()) where a(i) == aggr( a(i-1), f(x(i)) ) and terminators are a(1) == f(x(0)), a(0)==double.nan.  example:  cern.jet.math.functions f = cern.jet.math.functions.functions; bin = 0 1 2 3 // sum( x[i]x[i] ) bin.aggregate(f.plus,f.square); --> 14  for further examples, see the package doc. an aggregation function taking as first argument the current aggregation and as second argument the transformed current element. a function transforming the current element. aggregated measure. @see cern.jet.math.functions removes all elements from the receiver. the receiver will be empty after this call returns. resets the values of all measures. returns a deep copy of the receiver. deep copy of the receiver. returns the correlation of two bins, which is corr(x,y) = covariance(x,y) / (stddev(x)stddev(y)) (pearson's correlation coefficient). a correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). see the  math definition and cov(x,y) = (1/size()) sum((x[i]-mean(x)) (y[i]-mean(y))). see the  math definition. the bin to compare with. covariance. @throws illegalargumentexception if size() != other.size(). returns a copy of the currently stored elements. concerning the order in which elements are returned, see {@link #setfixedorder(boolean)}. copy of the currently stored elements. returns the currently stored elements; warning: not a copy of them. thus, improper usage of the returned list may not only corrupt the receiver's internal state, but also break thread safety! only provided for performance and memory sensitive applications. do not modify the returned list unless you know exactly what you're doing. this method can be used in a thread safe, clean and performant way by explicitly synchronizing on the bin, as follows:  ... double sinsum = 0; synchronized (dynamicbin) { // lock out anybody else doublearraylist elements = dynamicbin.elements_unsafe(); // read each element and do something with it, for example double[] values = elements.elements(); // zero-copy for (int i=dynamicbin.size(); --i >=0; ) { sinsum += math.sin(values[i]); } } system.out.println(sinsum); ...  concerning the order in which elements are returned, see {@link #setfixedorder(boolean)}. currently stored elements. returns whether two bins are equal. they are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum and sumofsquares and have the same elements, order being irrelevant (multiset equality).  definition of equality for multisets: a,b are equal  a is a superset of b and b is a superset of a. (elements must occur the same number of times, order is irrelevant.) computes the frequency (number of occurances, count) of each distinct element. after this call returns both distinctelements and frequencies have a new size (which is equal for both), which is the number of distinct elements currently contained.  distinct elements are filled into distinctelements, starting at index 0. the frequency of each distinct element is filled into frequencies, starting at index 0. further, both distinctelements and frequencies are sorted ascending by "element" (in sync, of course). as a result, the smallest distinct element (and its frequency) can be found at index 0, the second smallest distinct element (and its frequency) at index 1, ..., the largest distinct element (and its frequency) at index distinctelements.size()-1.  example:  elements = (8,7,6,6,7) --> distinctelements = (6,7,8), frequencies = (2,2,1) a list to be filled with the distinct elements; can have any size. a list to be filled with the frequencies; can have any size; set this parameter to null to ignore it. returns a map holding the frequency distribution, that is, (distintelement,frequency) pairs. the frequency (count) of an element is its number of occurances.  example:  elements = (8,7,6,6,7) --> map.keys = (8,6,7), map.values = (1,2,2) map holding the frequency distribution. returns integer.max_value, the maximum order k for which sums of powers are retrievable. @see #hassumofpowers(int) @see #sumofpowers(int) returns integer.min_value, the minimum order k for which sums of powers are retrievable. @see #hassumofpowers(int) @see #sumofpowers(int) element to be appended. returns true. returns whether a client can obtain all elements added to the receiver. in other words, tells whether the receiver internally preserves all added elements. if the receiver is rebinnable, the elements can be obtained via elements() methods. returns the maximum. returns the minimum. returns the moment of k-th order with value c, which is sum( (x[i]-c)k ) / size(). the order; any number - can be less than zero, zero or greater than zero. any number. returns the exact phi-quantile; that is, the smallest contained element elem for which holds that phi percent of elements are less than elem. must satisfy 0 &lt; phi &lt; 1. returns exactly how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. the element to search for. exact percentage phi of elements &lt;= element (0.0 &lt;= phi &lt;= 1.0). returns the exact quantiles of the specified percentages. the percentages for which quantiles are to be computed. each percentage must be in the interval (0.0,1.0]. percentages must be sorted ascending. exact quantiles. removes from the receiver all elements that are contained in the specified list. the elements to be removed. true if the receiver changed as a result of the call. uniformly samples (chooses) n random elements with or without replacement from the contained elements and adds them to the given buffer. if the buffer is connected to a bin, the effect is that the chosen elements are added to the bin connected to the buffer. also see {@link #buffered(int) buffered}. the number of elements to choose. true samples with replacement, otherwise samples without replacement. a random number generator. set this parameter to null to use a default random number generator seeded with the current time. the buffer to which chosen elements will be added. @throws illegalargumentexception if !withreplacement && n > size(). @see cern.jet.random.sampling generic bootstrap resampling. quite optimized - don't be afraid to try it. executes resamples resampling steps. in each resampling step does the following:  uniformly samples (chooses) size() random elements with replacement from this and fills them into an auxiliary bin b1. uniformly samples (chooses) other.size() random elements with replacement from other and fills them into another auxiliary bin b2. executes the comparison function function on both auxiliary bins (function.apply(b1,b2)) and adds the result of the function to an auxiliary bootstrap bin b3.  finally returns the auxiliary bootstrap bin b3 from which the measure of interest can be read off.  background: also see a more  in-depth discussion on bootstrapping and related randomization methods. the classical statistical test for comparing the means of two samples is the t-test. unfortunately, this test assumes that the two samples each come from a normal distribution and that these distributions have the same standard deviation. quite often, however, data has a distribution that is non-normal in many ways. in particular, distributions are often unsymmetric. for such data, the t-test may produce misleading results and should thus not be used. sometimes asymmetric data can be transformed into normally distributed data by taking e.g. the logarithm and the t-test will then produce valid results, but this still requires postulation of a certain distribution underlying the data, which is often not warranted, because too little is known about the data composition. bootstrap resampling of means differences (and other differences) is a robust replacement for the t-test and does not require assumptions about the actual distribution of the data. the idea of bootstrapping is quite simple: simulation. the only assumption required is that the two samples a and b are representative for the underlying distribution with respect to the statistic that is being tested - this assumption is of course implicit in all statistical tests. we can now generate lots of further samples that correspond to the two given ones, by sampling with replacement. this process is called resampling. a resample can (and usually will) have a different mean than the original one and by drawing hundreds or thousands of such resamples ar from a and br from b we can compute the so-called bootstrap distribution of all the differences &quot;mean of ar minus mean of br&quot;. that is, a bootstrap bin filled with the differences. now we can compute, what fraction of these differences is, say, greater than zero. let's assume we have computed 1000 resamples of both a and b and found that only 8 of the differences were greater than zero. then 8/1000 or 0.008 is the p-value (probability) for the hypothesis that the mean of the distribution underlying a is actually larger than the mean of the distribution underlying b. from this bootstrap test, we can clearly reject the hypothesis. instead of using means differences, we can also use other differences, for example, the median differences. instead of p-values we can also read arbitrary confidence intervals from the bootstrap bin. for example, 90% of all bootstrap differences are left of the value -3.5, hence a left 90% confidence interval for the difference would be (3.5,infinity); in other words: the difference is 3.5 or larger with probability 0.9. sometimes we would like to compare not only means and medians, but also the variability (spread) of two samples. the conventional method of doing this is the f-test, which compares the standard deviations. it is related to the t-test and, like the latter, assumes the two samples to come from a normal distribution. the f-test is very sensitive to data with deviations from normality. instead we can again resort to more robust bootstrap resampling and compare a measure of spread, for example the inter-quartile range. this way we compute a bootstrap resampling of inter-quartile range differences in order to arrive at a test for inequality or variability.   example:    // v1,v2 - the two samples to compare against each other double[] v1 = { 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 21, 22,23,24,25,26,27,28,29,30,31}; double[] v2 = {10,11,12,13,14,15,16,17,18,19, 20, 30,31,32,33,34,35,36,37,38,39}; hep.aida.bin.dynamicbin1d x = new hep.aida.bin.dynamicbin1d(); hep.aida.bin.dynamicbin1d y = new hep.aida.bin.dynamicbin1d(); x.addallof(new cern.colt.list.doublearraylist(v1)); y.addallof(new cern.colt.list.doublearraylist(v2)); cern.jet.random.engine.randomengine random = new cern.jet.random.engine.mersennetwister(); // bootstrap resampling of differences of means: binbinfunction1d diff = new binbinfunction1d() { &nbsp;&nbsp;&nbsp;public double apply(dynamicbin1d x, dynamicbin1d y) {return x.mean() - y.mean();} }; // bootstrap resampling of differences of medians: binbinfunction1d diff = new binbinfunction1d() { &nbsp;&nbsp;&nbsp;public double apply(dynamicbin1d x, dynamicbin1d y) {return x.median() - y.median();} }; // bootstrap resampling of differences of inter-quartile ranges: binbinfunction1d diff = new binbinfunction1d() { &nbsp;&nbsp;&nbsp;public double apply(dynamicbin1d x, dynamicbin1d y) {return (x.quantile(0.75)-x.quantile(0.25)) - (y.quantile(0.75)-y.quantile(0.25)); } }; dynamicbin1d boot = x.samplebootstrap(y,1000,random,diff); cern.jet.math.functions f = cern.jet.math.functions.functions; system.out.println("p-value="+ (boot.aggregate(f.plus, f.greater(0)) / boot.size())); system.out.println("left 90% confidence interval = ("+boot.quantile(0.9) + ",infinity)"); --> // bootstrap resampling of differences of means: p-value=0.0080 left 90% confidence interval = (-3.571428571428573,infinity) // bootstrap resampling of differences of medians: p-value=0.36 left 90% confidence interval = (5.0,infinity) // bootstrap resampling of differences of inter-quartile ranges: p-value=0.5699 left 90% confidence interval = (5.0,infinity)    the other bin to compare the receiver against. the number of times resampling shall be done. a random number generator. set this parameter to null to use a default random number generator seeded with the current time. a difference function comparing two samples; takes as first argument a sample of this and as second argument a sample of other. bootstrap bin holding the results of function of each resampling step. @see cern.colt.genericpermuting#permutation(long,int) determines whether the receivers internally preserved elements may be reordered or not.  fixedorder==false allows the order in which elements are returned by method elements() to be different from the order in which elements are added. fixedorder==true guarantees that under all circumstances the order in which elements are returned by method elements() is identical to the order in which elements are added. however, the latter consumes twice as much memory if operations involving sorting are requested. this option is usually only required if a 2-dimensional bin, formed by two 1-dimensional bins, needs to be rebinnable.   naturally, if fixedorder is set to true you should not already have added elements to the receiver; it should be empty. returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. sorts elements if not already sorted. call updateincrementalstats() because after sorting we no more know what elements are still to be done by updateincrementalstats() and would therefore later need to rebuild incremental stats from scratch. returns a copy of the currently stored elements, sorted ascending. concerning the memory required for operations involving sorting, see {@link #setfixedorder(boolean)}. copy of the currently stored elements, sorted ascending. returns the currently stored elements, sorted ascending; warning: not a copy of them; thus, improper usage of the returned list may not only corrupt the receiver's internal state, but also break thread safety! only provided for performance and memory sensitive applications. do not modify the returned elements unless you know exactly what you're doing. this method can be used in a thread safe, clean and performant way by explicitly synchronizing on the bin, as follows:  ... synchronized (dynamicbin) { // lock out anybody else doublearraylist elements = dynamicbin.sortedelements_unsafe(); // read each element and do something with it, e.g. double[] values = elements.elements(); // zero-copy for (int i=dynamicbin.size(); --i >=0; ) { foo(values[i]); } } ...  concerning the memory required for operations involving sorting, see {@link #setfixedorder(boolean)}. currently stored elements, sorted ascending. modifies the receiver to be standardized. changes each element x[i] as follows: x[i] = (x[i]-mean)/standarddeviation. returns the sum of all elements, which is sum( x[i] ). returns the sum of inversions, which is sum( 1 / x[i] ). returns the sum of logarithms, which is sum( log(x[i]) ). returns the k-th order sum of powers, which is sum( x[i]k ). the order of the powers. sum of powers. returns the sum of squares, which is sum( x[i] x[i] ). returns a string representation of the receiver. removes the s smallest and l largest elements from the receiver. the receivers size will be reduced by s + l elements. the number of smallest elements to trim away (s >= 0). the number of largest elements to trim away (l >= 0). returns the trimmed mean. that is the mean of the data if the s smallest and l largest elements would be removed from the receiver (they are not removed). the number of smallest elements to trim away (s >= 0). the number of largest elements to trim away (l >= 0). trimmed mean. trims the capacity of the receiver to be the receiver's current size. (this has nothing to do with trimming away smallest and largest elements. the method name is used to be consistent with jdk practice.)  releases any superfluos internal memory. an application can use this operation to minimize the storage of the receiver. does not affect functionality. assertion: isbasicparametersvalid == false assertion: isbasicparametersvalid == false  element to be appended. never ever use "this.size" as it would be intuitive! this class abuses "this.size". "this.size" does not reflect the number of elements contained in the receiver! instead, "this.size" reflects the number of elements incremental stats computation has already processed. cached parameters protected double skew = 0.0; protected double kurtosis = 0.0; cache states protected boolean isskewvalid = true; protected boolean iskurtosisvalid = true; protected boolean issumofpowersvalid = true; sum( x[i]x[i] ) this.skew = 0.0; this.kurtosis = 0.0; www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition www.stat.berkeley.edu/ www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition. safe since we are already synchronized. lock out anybody else read each element and do something with it, for example zero-copy cern.colt.map.opendoubleinthashmap.hashcollisions = 0; fill a map that collects frequencies cern.colt.timer timer = new cern.colt.timer().start(); double element = i; // benchmark only todo double element = i%1000; // benchmark only todo timer.stop(); system.out.println("filling map took = "+timer); system.out.println("collisions="+cern.colt.map.opendoubleinthashmap.hashcollisions); this.isskewvalid = false; this.iskurtosisvalid = false; currently no caching for this parameter without with garnet.acns.fsu.edu/~pkelly/bootstrap.html"> in-depth discussion on bootstrapping and related randomization methods. v1,v2 - the two samples to compare against each other bootstrap resampling of differences of means: bootstrap resampling of differences of medians: bootstrap resampling of differences of inter-quartile ranges: bootstrap resampling of differences of means: bootstrap resampling of differences of medians: bootstrap resampling of differences of inter-quartile ranges: since "resamples" can be quite large, we care about performance and memory prepare auxiliary bins and buffers resampling steps if (size() > 0) throw new runtimeexception("must be called before starting to add elements."); never ever use "this.size" as it would be intuitive! this class abuses "this.size". "this.size" does not reflect the number of elements contained in the receiver! instead, "this.size" reflects the number of elements incremental stats computation has already processed. safe since we are already synchronized. lock out anybody else read each element and do something with it, e.g. zero-copy no chaching for this measure don't cause unintended floods no caching for this parameter. prepare arguments store the new parameters back next time we don't need to redo the stuff we have just done... this.isskewvalid = true; this.iskurtosisvalid = true;"
hep.aida.bin.MightyStaticBin1D "static and the same as its superclass, except that it can do more: additionally computes moments of arbitrary integer order, harmonic mean, geometric mean, etc. constructors need to be told what functionality is required for the given use case. only maintains aggregate measures (incrementally) - the added elements themselves are not kept. constructs and returns an empty bin with limited functionality but good performance; equivalent to mightystaticbin1d(false,false,4). constructs and returns an empty bin with the given capabilities. tells whether {@link #sumoflogarithms()} can return meaningful results. set this parameter to false if measures of sum of logarithms, geometric mean and product are not required.  tells whether {@link #sumofinversions()} can return meaningful results. set this parameter to false if measures of sum of inversions, harmonic mean and sumofpowers(-1) are not required.  the maximum order k for which {@link #sumofpowers(int)} can return meaningful results. set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required. in general, if moments are required set this parameter at least as large as the largest required moment. this method always substitutes math.max(2,maxorderforsumofpowers) for the parameter passed in. thus, sumofpowers(0..2) always returns meaningful results. @see #hassumofpowers(int) @see #moment(int,double) adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). @throws indexoutofboundsexception if list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size()). resets the values of all measures. returns a deep copy of the receiver. deep copy of the receiver. computes the deviations from the receiver's measures to another bin's measures. the other bin to compare with summary of the deviations. returns the geometric mean, which is product( x[i] )1.0/size(). this method tries to avoid overflows at the expense of an equivalent but somewhat inefficient definition: geomean = exp( sum( log(x[i]) ) / size()). note that for a geometric mean to be meaningful, the minimum of the data sequence must not be less or equal to zero. geometric mean; double.nan if !hassumoflogarithms(). returns the maximum order k for which sums of powers are retrievable, as specified upon instance construction. @see #hassumofpowers(int) @see #sumofpowers(int) order 0..2 is always recorded. order 0 is size() order 1 is sum() order 2 is sum_xx() returns the minimum order k for which sums of powers are retrievable, as specified upon instance construction. @see #hassumofpowers(int) @see #sumofpowers(int) returns the harmonic mean, which is size() / sum( 1/x[i] ). remember: if the receiver contains at least one element of 0.0, the harmonic mean is 0.0. harmonic mean; double.nan if !hassumofinversions(). @see #hassumofinversions() returns whether sumofinversions() can return meaningful results. false if the bin was constructed with insufficient parametrization, true otherwise. see the constructors for proper parametrization. tells whether sumoflogarithms() can return meaningful results. false if the bin was constructed with insufficient parametrization, true otherwise. see the constructors for proper parametrization. tells whether sumofpowers(k) can return meaningful results. defined as hassumofpowers(k)  getminorderforsumofpowers() . a return value of true implies that hassumofpowers(k-1) .. hassumofpowers(0) will also return true. see the constructors for proper parametrization.  details: hassumofpowers(0..2) will always yield true. hassumofpowers(-1)  hassumofinversions(). false if the bin was constructed with insufficient parametrization, true otherwise. @see #getminorderforsumofpowers() @see #getmaxorderforsumofpowers() returns the kurtosis (aka excess), which is -3 + moment(4,mean()) / standarddeviation()4. kurtosis; double.nan if !hassumofpowers(4). @see #hassumofpowers(int) returns the moment of k-th order with value c, which is sum( (x[i]-c)k ) / size(). the order; must be greater than or equal to zero. any number. @throws illegalargumentexception if k . double.nan if !hassumofpower(k). returns the product, which is prod( x[i] ). in other words: x[0]x[1]...x[size()-1]. product; double.nan if !hassumoflogarithms(). @see #hassumoflogarithms() sets the range of orders in which sums of powers are to be computed. in other words, sumofpower(k) will return sum( x[i]^k ) if min_k  and throw an exception otherwise. @see #islegalorder(int) @see #sumofpowers(int) @see #getrangeforsumofpowers() returns the skew, which is moment(3,mean()) / standarddeviation()3. skew; double.nan if !hassumofpowers(3). @see #hassumofpowers(int) returns the sum of inversions, which is sum( 1 / x[i] ). sum of inversions; double.nan if !hassumofinversions(). @see #hassumofinversions() returns the sum of logarithms, which is sum( log(x[i]) ). sum of logarithms; double.nan if !hassumoflogarithms(). @see #hassumoflogarithms() returns the k-th order sum of powers, which is sum( x[i]k ). the order of the powers. sum of powers; double.nan if !hassumofpowers(k). @see #hassumofpowers(int) returns a string representation of the receiver. @throws illegaloperationexception if ! islegalorder(k). returns whether two bins are equal; they are equal if the other object is of the same class or a subclass of this class and both have the same size, minimum, maximum, sum, sumofsquares, sumofinversions and sumoflogarithms. tells whether sumofpowers(fromk) .. sumofpowers(tok) can return meaningful results. false if the bin was constructed with insufficient parametrization, true otherwise. see the constructors for proper parametrization. @throws illegalargumentexception if fromk > tok. returns getminorderforsumofpowers() . sum( log(x[i]) ) sum( 1/x[i] ) sum( x[i]^3 ) .. sum( x[i]^max_k ) int max_k = this.min_k + this.sumofpowers.length-1; checkorder(k); if (max_k < ) throw new illegalargumentexception(); if (! this.hassumofinversions) throw new illegaloperationexception("you must specify upon instance construction that the sum of inversions shall be computed."); if (! this.hassumoflogarithms) throw new illegaloperationexception("you must specify upon instance construction that the sum of logarithms shall be computed."); checkorder(k); don't print tons of measures if (! islegalorder(k)) return double.nan; if (! xislegalorder(k)) throw new illegaloperationexception("illegal order of sum of powers: k="+k+". upon instance construction legal range was fixed to be "+getminorderforsumofpowers()+" <= k <= "+getmaxorderforsumofpowers());"
hep.aida.bin.QuantileBin1D "1-dimensional non-rebinnable bin holding double elements with scalable quantile operations defined upon; using little main memory, quickly computes approximate quantiles over very large data sequences with and even without a-priori knowledge of the number of elements to be filled; conceptually a strongly lossily compressed multiset (or bag); guarantees to respect the worst case approximation error specified upon instance construction. first see the package summary and javadoc tree view to get the broad picture.  motivation and problem: intended to help scale applications requiring quantile computation. quantile computation on very large data sequences is problematic, for the following reasons: computing quantiles requires sorting the data sequence. to sort a data sequence the entire data sequence needs to be available. thus, data cannot be thrown away during filling (as done by static bins like {@link staticbin1d} and {@link mightystaticbin1d}). it needs to be kept, either in main memory or on disk. there is often not enough main memory available. thus, during filling data needs to be streamed onto disk. sorting disk resident data is prohibitively time consuming. as a consequence, traditional methods either need very large memories (like {@link dynamicbin1d}) or time consuming disk based sorting.  this class proposes to efficiently solve the problem, at the expense of producing approximate rather than exact results. it can deal with infinitely many elements without resorting to disk. the main memory requirements are smaller than for any other known approximate technique by an order of magnitude. they get even smaller if an upper limit on the maximum number of elements ever to be added is known a-priori.  approximation error: the approximation guarantees are parametrizable and explicit but probabilistic, and apply for arbitrary value distributions and arrival distributions of the data sequence. in other words, this class guarantees to respect the worst case approximation error specified upon instance construction to a certain probability. of course, if it is specified that the approximation error should not exceed some number very close to zero, this class will potentially consume just as much memory as any of the traditional exact techniques would do. however, for errors larger than 10-5, its memory requirements are modest, as shown by the table below.  main memory requirements: given in megabytes, assuming a single element (double) takes 8 byte. the number of elements required is then mb10241024/8.  parameters:  epsilon - the maximum allowed approximation error on quantiles; in [0.0,1.0]. to get exact rather than approximate quantiles, set epsilon=0.0; delta - the probability allowed that the approximation error fails to be smaller than epsilon; in [0.0,1.0]. to avoid probabilistic answers, set delta=0.0. for example, delta = 0.0001 is equivalent to a confidence of 99.99%. quantiles - the number of quantiles to be computed; in [0,integer.max_value]. is n known? - specifies whether the exact size of the dataset over which quantiles are to be computed is known. nmax - the exact dataset size, if known. otherwise, an upper limit on the dataset size. if no upper limit is known set to infinity (long.max_value).  nmax=inf - we are sure that exactly (known) or less than (unknown) infinity elements will be added. nmax=106 - we are sure that exactly (known) or less than (unknown) 106 elements will be added. nmax=107 - we are sure that exactly (known) or less than (unknown) 107 elements will be added. nmax=108 - we are sure that exactly (known) or less than (unknown) 108 elements will be added.     required main memory [mb]    #quantiles    epsilon  delta &nbsp; n unknown  n known   nmax=inf nmax=106 nmax=107 nmax=108 nmax=inf nmax=106 nmax=107 nmax=108      &nbsp; &nbsp;   any  0  any infinity 7.6 76 762 infinity 7.6 76 762   any  10 -1  0 infinity 0.003 0.005 0.006 0.03 0.003 0.005 0.006    10 -2  0.02 0.03 0.05 0.31 0.02 0.03 0.05    10 -3  0.12 0.2 0.3 2.7 0.12 0.2 0.3    10 -4  0.6 1.2 2.1 26.9 0.6 1.2 2.1    10 -5  2.5 6.4 11.6 205 2.5 6.4 11.6    10 -6  7.6 25.4 63.6 1758 7.6 25.4 63.6    &nbsp; &nbsp;   100  10 -2  10 -1 0.033 0.021 0.03 0.03 0.020 0.020 0.020 0.020   10 -5 0.038 0.021 0.03 0.04 0.024 0.020 0.020 0.020    10 -3  10 -1 0.48 0.12 0.2 0.3 0.32 0.12 0.2 0.3   10 -5 0.54 0.12 0.2 0.3 0.37 0.12 0.2 0.3    10 -4  10 -1 6.6 0.6 1.2 2.1 4.6 0.6 1.2 2.1   10 -5 7.2 0.6 1.2 2.1 5.2 0.6 1.2 2.1    10 -5  10 -1 86 2.5 6.4 11.6 63 2.5 6.4 11.6   10 -5 94 2.5 6.4 11.6 70 2.5 6.4 11.6    &nbsp; &nbsp;   10000  10 -2  10 -1 0.04 0.02 0.03 0.04 0.02 0.02 0.02 0.02   10 -5 0.04 0.02 0.03 0.04 0.03 0.02 0.03 0.03    10 -3  10 -1 0.52 0.12 0.21 0.3 0.35 0.12 0.21 0.3   10 -5 0.56 0.12 0.21 0.3 0.38 0.12 0.21 0.3    10 -4  10 -1 7.0 0.64 1.2 2.1 5.0 0.64 1.2 2.1   10 -5 7.5 0.64 1.2 2.1 5.4 0.64 1.2 2.1    10 -5  10 -1 90 2.5 6.4 11.6 67 2.5 6.4 11.6   10 -5 96 2.5 6.4 11.6 71 2.5 6.4 11.6   &nbsp; &nbsp; &nbsp;   #quantiles epsilon delta nmax=inf nmax=106 nmax=107 nmax=108 nmax=inf nmax=106 nmax=107 nmax=108   n unknown n known   required main memory [mb]    implementation:  after: gurmeet singh manku, sridhar rajagopalan and bruce g. lindsay, random sampling techniques for space efficient online computation of order statistics of large datasets. proc. of the 1999 acm sigmod int. conf. on management of data, paper available  here.  and  gurmeet singh manku, sridhar rajagopalan and bruce g. lindsay, approximate medians and other quantiles in one pass and with limited memory, proc. of the 1998 acm sigmod int. conf. on management of data, paper available  here.  the broad picture is as follows. two concepts are used: shrinking and sampling. shrinking takes a data sequence, sorts it and produces a shrinked data sequence by picking every k-th element and throwing away all the rest. the shrinked data sequence is an approximation to the original data sequence.  imagine a large data sequence (residing on disk or being generated in memory on the fly) and a main memory block of n=bk elements (b is the number of buffers, k is the number of elements per buffer). fill elements from the data sequence into the block until it is full or the data sequence is exhausted. when the block (or a subset of buffers) is full and the data sequence is not exhausted, apply shrinking to lossily compress a number of buffers into one single buffer. repeat these steps until all elements of the data sequence have been consumed. now the block is a shrinked approximation of the original data sequence. treating it as if it would be the original data sequence, we can determine quantiles in main memory.  now, the whole thing boils down to the question of: can we choose b and k (the number of buffers and the buffer size) such that bk is minimized, yet quantiles determined upon the block are guaranteed to be away from the true quantiles no more than some epsilon? it turns out, we can. it also turns out that the required main memory block size n=bk is usually moderate (see the table above).  the theme can be combined with random sampling to further reduce main memory requirements, at the expense of probabilistic guarantees. sampling filters the data sequence and feeds only selected elements to the algorithm outlined above. sampling is turned on or off, depending on the parametrization.  this quick overview does not go into important details, such as assigning proper weights to buffers, how to choose subsets of buffers to shrink, etc. for more information consult the papers cited above.  time performance:  pentium pro 200 mhz, sunjdk 1.2.2, nt, java -classic, filling 10 4 elements at a time, reading 100 percentiles at a time, hassumoflogarithms()=false, hassumofinversions()=false, getmaxorderforsumofpowers()=2      performance    quantiles  epsilon  delta &nbsp;   filling  [#elements/sec]  &nbsp;   quantile computation [#quantiles/sec]     n unknown, nmax=inf  n known, nmax=107   n unknown, nmax=inf  n known, nmax=107    &nbsp;  &nbsp;  &nbsp;     104  10  -1  10  -1   1600000  1300000 250000  130000     10  -2 360000 1200000 50000  20000     10  -3 150000 200000 3600  3000     10  -4 120000 170000 80  1000     @see cern.jet.stat.quantile not public; for use by subclasses only! constructs and returns an empty bin. equivalent to new quantilebin1d(false, long.max_value, epsilon, 0.001, 10000, new cern.jet.random.engine.drand(new java.util.date()). equivalent to new quantilebin1d(known_n, n, epsilon, delta, quantiles, randomgenerator, false, false, 2). constructs and returns an empty bin that, under the given constraints, minimizes the amount of memory needed. some applications exactly know in advance over how many elements quantiles are to be computed. provided with such information the main memory requirements of this class are small. other applications don't know in advance over how many elements quantiles are to be computed. however, some of them can give an upper limit, which will reduce main memory requirements. for example, if elements are selected from a database and filled into histograms, it is usually not known in advance how many elements are being filled, but one may know that at most s elements, the number of elements in the database, are filled. a third type of application knowns nothing at all about the number of elements to be filled; from zero to infinitely many elements may actually be filled. this method efficiently supports all three types of applications. _n specifies whether the number of elements over which quantiles are to be computed is known or not.  if known_n==true, the number of elements over which quantiles are to be computed. if known_n==false, the upper limit on the number of elements over which quantiles are to be computed. in other words, the maximum number of elements ever to be added. if such an upper limit is a-priori unknown, then set n = long.max_value.  the approximation error which is guaranteed not to be exceeded (e.g. 0.001) (0 &lt;= epsilon &lt;= 1). to get exact rather than approximate quantiles, set epsilon=0.0;  the allowed probability that the actual approximation error exceeds epsilon (e.g. 0.0001) (0 &lt;= delta &lt;= 1). to avoid probabilistic answers, set delta=0.0. for example, delta = 0.0001 is equivalent to a confidence of 99.99%.  the number of quantiles to be computed (e.g. 100) (quantiles &gt;= 1). if unknown in advance, set this number large, e.g. quantiles &gt;= 10000.  a uniform random number generator. set this parameter to null to use a default generator seeded with the current time.  the next three parameters specify additional capabilities unrelated to quantile computation. they are identical to the one's defined in the constructor of the parent class {@link mightystaticbin1d}.  tells whether {@link #sumoflogarithms()} can return meaningful results. set this parameter to false if measures of sum of logarithms, geometric mean and product are not required.  tells whether {@link #sumofinversions()} can return meaningful results. set this parameter to false if measures of sum of inversions, harmonic mean and sumofpowers(-1) are not required.  the maximum order k for which {@link #sumofpowers(int)} can return meaningful results. set this parameter to at least 3 if the skew is required, to at least 4 if the kurtosis is required. in general, if moments are required set this parameter at least as large as the largest required moment. this method always substitutes math.max(2,maxorderforsumofpowers) for the parameter passed in. thus, sumofpowers(0..2) always returns meaningful results. adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). @throws indexoutofboundsexception if list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size()). removes all elements from the receiver. the receiver will be empty after this call returns. returns a deep copy of the receiver. deep copy of the receiver. computes the deviations from the receiver's measures to another bin's measures. the other bin to compare with summary of the deviations. returns the median. computes and returns the phi-quantile. the percentage for which the quantile is to be computed. phi must be in the interval (0.0,1.0]. phi quantile element. returns how many percent of the elements contained in the receiver are &lt;= element. does linear interpolation if the element is not contained but lies in between two contained elements. element to search for. percentage phi of elements &lt;= element (0.0 &lt;= phi &lt;=1.0). returns the quantiles of the specified percentages. for implementation reasons considerably more efficient than calling {@link #quantile(double)} various times. the percentages for which quantiles are to be computed. each percentage must be in the interval (0.0,1.0]. percentages must be sorted ascending. quantiles. returns how many elements are contained in the range [minelement,maxelement]. does linear interpolation if one or both of the parameter elements are not contained. returns exact or approximate results, depending on the parametrization of this class or subclasses. the minimum element to search for. the maximum element to search for. number of elements in the range. divides (rebins) a copy of the receiver at the given percentage boundaries into bins and returns these bins, such that each bin approximately reflects the data elements of its range. the receiver is not physically rebinned (divided); it stays unaffected by this operation. the returned bins are such that if one would have filled elements into multiple bins instead of one single all encompassing bin only, those multiple bins would have approximately the same statistics measures as the one's returned by this method.  the split(...) methods are particularly well suited for real-time interactive rebinning (the famous "scrolling slider" effect).  passing equi-distant percentages like (0.0, 0.2, 0.4, 0.6, 0.8, 1.0) into this method will yield bins of an equi-depth histogram, i.e. a histogram with bin boundaries adjusted such that each bin contains the same number of elements, in this case 20% each. equi-depth histograms can be useful if, for example, not enough properties of the data to be captured are known a-priori to be able to define reasonable bin boundaries (partitions). for example, when guesses about minimas and maximas are strongly unreliable. or when chances are that by focussing too much on one particular area other important areas and characters of a data set may be missed.  implementation:  the receiver is divided into s = percentages.size()-1 intervals (bins). for each interval i, its minimum and maximum elements are determined based upon quantile computation. further, each interval i is split into k equi-percent-distant subintervals (sub-bins). in other words, an interval is split into subintervals such that each subinterval contains the same number of elements.  for each subinterval s, its minimum and maximum are determined, again, based upon quantile computation. they yield an approximate arithmetic mean am = (min+max)/2 of the subinterval. a subinterval is treated as if it would contain only elements equal to the mean am. thus, if the subinterval contains, say, n elements, it is assumed to consist of n mean elements (am,am,...,am). a subinterval's sum of elements, sum of squared elements, sum of inversions, etc. are then approximated using such a sequence of mean elements.  finally, the statistics measures of an interval i are computed by summing up (integrating) the measures of its subintervals.  accuracy:  depending on the accuracy of quantile computation and the number of subintervals per interval (the resolution). objects of this class compute exact or approximate quantiles, depending on the parameters used upon instance construction. objects of subclasses may always compute exact quantiles, as is the case for {@link dynamicbin1d}. most importantly for this class quantilebin1d, a reasonably small epsilon (e.g. 0.01, perhaps 0.001) should be used upon instance construction. the confidence parameter delta is less important, you may find delta=0.00001 appropriate.  the larger the resolution, the smaller the approximation error, up to some limit. integrating over only a few subintervals per interval will yield very crude approximations. if the resolution is set to a reasonably large number, say 10..100, more small subintervals are integrated, resulting in more accurate results.  note that for good accuracy, the number of quantiles computable with the given approximation guarantees should upon instance construction be specified, so as to satisfy  quantiles > resolution (percentages.size()-1)   example:  resolution=2, percentlist = (0.0, 0.1, 0.2, 0.5, 0.9, 1.0) means the receiver is to be split into 5 bins:   bin 0 ranges from [0%..10%) and holds the smallest 10% of the sorted elements. bin 1 ranges from [10%..20%) and holds the next smallest 10% of the sorted elements. bin 2 ranges from [20%..50%) and holds the next smallest 30% of the sorted elements. bin 3 ranges from [50%..90%) and holds the next smallest 40% of the sorted elements. bin 4 ranges from [90%..100%) and holds the largest 10% of the sorted elements.   the statistics measures for each bin are to be computed at a resolution of 2 subbins per bin. thus, the statistics measures of a bin are the integrated measures over 2 subbins, each containing the same amount of elements:  bin 0 has a subbin ranging from [ 0%.. 5%) and a subbin ranging from [ 5%..10%). bin 1 has a subbin ranging from [10%..15%) and a subbin ranging from [15%..20%). bin 2 has a subbin ranging from [20%..35%) and a subbin ranging from [35%..50%). bin 3 has a subbin ranging from [50%..70%) and a subbin ranging from [70%..90%). bin 4 has a subbin ranging from [90%..95%) and a subbin ranging from [95%..100%).   lets concentrate on the subbins of bin 0.  assume the subbin a=[0%..5%) has a minimum of 300 and a maximum of 350 (0% of all elements are less than 300, 5% of all elements are less than 350). assume the subbin b=[5%..10%) has a minimum of 350 and a maximum of 550 (5% of all elements are less than 350, 10% of all elements are less than 550).   assume the entire data set consists of n=100 elements.  then subbin a has an approximate mean of 300+350 / 2 = 325, a size of n(5%-0%) = 1005% = 5 elements, an approximate sum of 325 1005% = 1625, an approximate sum of squares of 3252 1005% = 528125, an approximate sum of inversions of (1.0/325) 1005% = 0.015, etc. analogously, subbin b has an approximate mean of 350+550 / 2 = 450, a size of n(10%-5%) = 1005% = 5 elements, an approximate sum of 450 1005% = 2250, an approximate sum of squares of 4502 1005% = 1012500, an approximate sum of inversions of (1.0/450) 1005% = 0.01, etc.   finally, the statistics measures of bin 0 are computed by summing up (integrating) the measures of its subintervals: bin 0 has a size of n(10%-0%)=10 elements (we knew that already), sum of 1625+2250=3875, sum of squares of 528125+1012500=1540625, sum of inversions of 0.015+0.01=0.025, etc. from these follow other measures such as mean=3875/10=387.5, rms = sqrt(1540625 / 10)=392.5, etc. the other bins are computes analogously. the percentage boundaries at which the receiver shall be split. a measure of accuracy; the desired number of subintervals per interval. percentages = [p0, p1, p2, ..., p(size-2), p(size-1)] defines bins [p0,p1), [p1,p2), ..., [p(size-2),p(size-1)) each bin is divided into k equi-percent-distant sub bins (subintervals). e.g. k = 2 means "compute" with a resolution (accuracy) of 2 subbins (subintervals) per bin, percentages = [0.1, 0.2, 0.3, ..., 0.9, 1.0] means bin 0 holds the first 0.1-0.0=10% of the sorted elements, bin 1 holds the next 0.2-0.1=10% of the sorted elements, ... bins = [0.1, 0.2), [0.2, 0.3), ..., [0.9, 1.0) subbins = [0.1, 0.15, 0.2, 0.25, 0.3, ....] [0.1, 0.15) [0.15, 0.2) [0.3, 0.35) [0.35, 0.4) [0.2, 0.25) [0.25, 0.3) double binmean = binsum / binsize; system.out.println("size="+binsize); system.out.println("min="+binmin); system.out.println("max="+binmax); system.out.println("mean="+binmean); system.out.println("sum_x="+binsum); system.out.println("sum_xx="+binsumofsquares); system.out.println("rms="+math.sqrt(binsumofsquares / binsize)); system.out.println(); divides (rebins) a copy of the receiver at the given interval boundaries into bins and returns these bins, such that each bin approximately reflects the data elements of its range. for each interval boundary of the axis (including -infinity and +infinity), computes the percentage (quantile inverse) of elements less than the boundary. then lets {@link #splitapproximately(doublearraylist,int)} do the real work. an axis defining interval boundaries. a measure of accuracy; the desired number of subintervals per interval. returns a string representation of the receiver. www-cad.eecs.berkeley.edu/~manku/papers/unknown.ps.gz"> here. www-cad.eecs.berkeley.edu/~manku/papers/quantiles.ps.gz"> here. construct subintervals compute quantile elements; collect summary statistics for each bin. one bin's statistics are the integrated statistics of its subintervals. don't compute tons of measures for each bin integrate all subintervals example: bin(0) contains (0.2-0.1) == 10% of all elements fill statistics buf.append("10%, 25%, 50%, 75%, 90% quantiles: "+quantile(0.1) + ", "+ quantile(0.25) + ", "+ quantile(0.5) + ", " + quantile(0.75) + ", " + quantile(0.9));"
hep.aida.bin.StaticBin1D "1-dimensional non-rebinnable bin consuming double elements; efficiently computes basic statistics of data sequences. first see the package summary and javadoc tree view to get the broad picture.  the data streamed into a simplebin1d is not preserved! as a consequence infinitely many elements can be added to this bin. as a further consequence this bin cannot compute more than basic statistics. it is also not rebinnable. if these drawbacks matter, consider to use a {@link dynamicbin1d}, which overcomes them at the expense of increased memory requirements.  this class is fully thread safe (all public methods are synchronized). thus, you can have one or more threads adding to the bin as well as one or more threads reading and viewing the statistics of the bin while it is filled. for high performance, add data in large chunks (buffers) via method addallof rather than piecewise via method add.  implementation: incremental maintainance. performance linear in the number of elements added. the number of elements consumed by incremental parameter maintainance. function arguments used by method addallof(...) for memory tuning only. avoids allocating a new array of arguments each time addallof(...) is called. each bin does not need its own set of argument vars since they are declared as "static". addallof(...) of this class uses only 4 entries. subclasses computing additional incremental statistics may need more arguments. so, to be on the safe side we allocate space for 20 args. be sure you access this arguments only in synchronized blocks like synchronized (arguments) { do it } by the way, the whole fuss would be unnecessary if java would know inout parameters (call by reference). constructs and returns an empty bin. adds the specified element to the receiver. element to be appended. sumsquares += element element; if (this.done == 0) { // initial setup this.min = element; this.max = element; } else { if (element  this.max) this.max = element; double oldmean = this.mean; this.mean += (element - this.mean)/(done+1); this.sumsq += (element-this.mean)(element-oldmean); // cool, huh? } this.done++; adds the part of the specified list between indexes from (inclusive) and to (inclusive) to the receiver. the list of which elements shall be added. the index of the first element to be added (inclusive). the index of the last element to be added (inclusive). @throws indexoutofboundsexception if list.size()&gt;0 && (from&lt;0 || from&gt;to || to&gt;=list.size()). removes all elements from the receiver. the receiver will be empty after this call returns. resets the values of all measures. returns false. returns whether a client can obtain all elements added to the receiver. in other words, tells whether the receiver internally preserves all added elements. if the receiver is rebinnable, the elements can be obtained via elements() methods. returns the maximum. returns the minimum. returns the number of elements contained in the receiver. @returns the number of elements contained in the receiver. returns the sum of all elements, which is sum( x[i] ). returns the sum of squares, which is sum( x[i] x[i] ). cached parameters min( x[i] ) max( x[i] ) sum( x[i] ) sum( x[i]x[i] ) prototyping implementation; inefficient; todo initial setup cool, huh? if (this.arguments == null) setupcache(); prepare arguments store the new parameters back"
hep.aida.IAxis "an iaxis represents a binned histogram axis. a 1d histogram would have one axis representing the x axis, while a 2d histogram would have two axes representing the x and y axis. centre of the bin specified. bin number (0...bins()-1) or overflow or underflow. lower edge of the specified bin. bin number (0...bins()-1) or overflow or underflow. lower edge of the bin; for the underflow bin this is double.negative_infinity. the number of bins (excluding underflow and overflow) on the axis. upper edge of the specified bin. bin number (0...bins()-1) or overflow or underflow. upper edge of the bin; for the overflow bin this is double.positive_infinity. width of the bin specified. bin number (0...bins()-1) or overflow or underflow. converts a coordinate on the axis to a bin number. if the coordinate is = upperedge returns overflow. lower axis edge. upper axis edge."
hep.aida.IHistogram "a common base interface for ihistogram1d, ihistogram2d and ihistogram3d. constant specifying the overflow bin (can be passed to any method expecting a bin number). constant specifying the underflow bin (can be passed to any method expecting a bin number). number of all entries in all (both in-range and under/overflow) bins in the histogram. returns 1 for one-dimensional histograms, 2 for two-dimensional histograms, and so on. number of in-range entries in the histogram. number of equivalent entries. sum[ weight ] ^ 2 / sum[ weight^2 ]. number of under and overflow entries in the histogram. reset contents; as if just constructed. sum of all (both in-range and under/overflow) bin heights in the histogram. sum of in-range bin heights in the histogram. sum of under/overflow bin heights in the histogram. title of the histogram (will be set only in the constructor)."
hep.aida.IHistogram1D "a java interface corresponding to the aida 1d histogram.  note all methods that accept a bin number as an argument will also accept the constants overflow or underflow as the argument, and as a result give the contents of the resulting overflow or underflow bin. @see aida number of entries in the corresponding bin (ie the number of times fill was called for this bin). the bin number (0...n-1) or overflow or underflow. the error on this bin. the bin number (0...n-1) or overflow or underflow. total height of the corresponding bin (ie the sum of the weights in this bin). the bin number (0...n-1) or overflow or underflow. fill histogram with weight 1. fill histogram with specified weight. returns the mean of the whole histogram as calculated on filling-time. indexes of the in-range bins containing the smallest and largest binheight(), respectively. {minbin,maxbin}. returns the rms of the whole histogram as calculated on filling-time. returns the x axis. wwwinfo.cern.ch/asd/lhc++/aida/">aida"
hep.aida.IHistogram2D "a java interface corresponding to the aida 2d histogram.  note all methods that accept a bin number as an argument will also accept the constants overflow or underflow as the argument, and as a result give the contents of the resulting overflow or underflow bin. @see aida the number of entries (ie the number of times fill was called for this bin). the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. equivalent to projectionx().binentries(indexx). equivalent to projectiony().binentries(indexy). the error on this bin. the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. total height of the corresponding bin (ie the sum of the weights in this bin). the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. equivalent to projectionx().binheight(indexx). equivalent to projectiony().binheight(indexy). fill the histogram with weight 1. fill the histogram with specified weight. returns the mean of the histogram, as calculated on filling-time projected on the x axis. returns the mean of the histogram, as calculated on filling-time projected on the y axis. indexes of the in-range bins containing the smallest and largest binheight(), respectively. {minbinx,minbiny, maxbinx,maxbiny}. create a projection parallel to the x axis. equivalent to slicex(underflow,overflow). create a projection parallel to the y axis. equivalent to slicey(underflow,overflow). returns the rms of the histogram as calculated on filling-time projected on the x axis. returns the rms of the histogram as calculated on filling-time projected on the y axis. slice parallel to the y axis at bin indexy and one bin wide. equivalent to slicex(indexy,indexy). create a slice parallel to the axis x axis, between "indexy1" and "indexy2" (inclusive). the returned ihistogram1d represents an instantaneous snapshot of the histogram at the time the slice was slice parallel to the x axis at bin indexx and one bin wide. equivalent to slicey(indexx,indexx). create a slice parallel to the axis y axis, between "indexx1" and "indexx2" (inclusive) the returned ihistogram1d represents an instantaneous snapshot of the histogram at the time the slice was return the x axis. return the y axis. wwwinfo.cern.ch/asd/lhc++/aida/">aida"
hep.aida.IHistogram3D "a java interface corresponding to the aida 3d histogram.  note all methods that accept a bin number as an argument will also accept the constants overflow or underflow as the argument, and as a result give the contents of the resulting overflow or underflow bin. @see aida the number of entries (ie the number of times fill was called for this bin). the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. the z bin number (0...nz-1) or overflow or underflow. the error on this bin. the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. the z bin number (0...nz-1) or overflow or underflow. total height of the corresponding bin (ie the sum of the weights in this bin). the x bin number (0...nx-1) or overflow or underflow. the y bin number (0...ny-1) or overflow or underflow. the z bin number (0...nz-1) or overflow or underflow. fill the histogram with weight 1; equivalent to fill(x,y,z,1).. fill the histogram with specified weight. returns the mean of the histogram, as calculated on filling-time projected on the x axis. returns the mean of the histogram, as calculated on filling-time projected on the y axis. returns the mean of the histogram, as calculated on filling-time projected on the z axis. indexes of the in-range bins containing the smallest and largest binheight(), respectively. {minbinx,minbiny,minbinz, maxbinx,maxbiny,maxbinz}. create a projection parallel to the xy plane. equivalent to slicexy(underflow,overflow). create a projection parallel to the xz plane. equivalent to slicexz(underflow,overflow). create a projection parallel to the yz plane. equivalent to sliceyz(underflow,overflow). returns the rms of the histogram as calculated on filling-time projected on the x axis. returns the rms of the histogram as calculated on filling-time projected on the y axis. returns the rms of the histogram as calculated on filling-time projected on the z axis. create a slice parallel to the xy plane at bin indexz and one bin wide. equivalent to slicexy(indexz,indexz). create a slice parallel to the xy plane, between "indexz1" and "indexz2" (inclusive). the returned ihistogram2d represents an instantaneous snapshot of the histogram at the time the slice was create a slice parallel to the xz plane at bin indexy and one bin wide. equivalent to slicexz(indexy,indexy). create a slice parallel to the xz plane, between "indexy1" and "indexy2" (inclusive). the returned ihistogram2d represents an instantaneous snapshot of the histogram at the time the slice was create a slice parallel to the yz plane at bin indexx and one bin wide. equivalent to sliceyz(indexx,indexx). create a slice parallel to the yz plane, between "indexx1" and "indexx2" (inclusive). the returned ihistogram2d represents an instantaneous snapshot of the histogram at the time the slice was return the x axis. return the y axis. return the z axis. wwwinfo.cern.ch/asd/lhc++/aida/">aida"
hep.aida.ref.AbstractHistogram1D "abstract base class extracting and implementing most of the redundancy of the interface. package private method to map from the external representation of bin number to our internal representation of bin number return entries[xaxis.under] + entries[xaxis.over]; return heights[xaxis.under] + heights[xaxis.over];"
hep.aida.ref.AbstractHistogram2D "abstract base class extracting and implementing most of the redundancy of the interface. the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexy1 and indexy2 use our internal bin numbering scheme note 1the slice is done between indexy1 and indexy2 inclusive note 2indexy1 and indexy2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) package private method to map from the external representation of bin number to our internal representation of bin number package private method to map from the external representation of bin number to our internal representation of bin number return internalslicex(newtitle,yaxis.under,yaxis.over); return internalslicey(newtitle,xaxis.under,xaxis.over); int start = yaxis.map(indexy); int start = yaxis.map(indexy1); int stop = yaxis.map(indexy2); int start = xaxis.map(indexx); int start = xaxis.map(indexx1); int stop = xaxis.map(indexx2);"
hep.aida.ref.AbstractHistogram3D "abstract base class extracting and implementing most of the redundancy of the interface. the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexy1 and indexy2 use our internal bin numbering scheme note 1the slice is done between indexy1 and indexy2 inclusive note 2indexy1 and indexy2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) package private method to map from the external representation of bin number to our internal representation of bin number package private method to map from the external representation of bin number to our internal representation of bin number package private method to map from the external representation of bin number to our internal representation of bin number"
hep.aida.ref.Converter "histogram conversions, for example to string and xml format; this class requires the colt distribution, whereas the rest of the package is entirelly stand-alone. creates a new histogram converter. returns all edges of the given axis. returns an array[h.xaxis().bins()]; ignoring extra bins. returns an array[h.xaxis().bins()][h.yaxis().bins()]; ignoring extra bins. returns an array[h.xaxis().bins()]; ignoring extra bins. returns an array[h.xaxis().bins()][h.yaxis().bins()]; ignoring extra bins. returns an array[h.xaxis().bins()][h.yaxis().bins()][h.zaxis().bins()]; ignoring extra bins. returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. returns a string representation of the given argument. returns a string representation of the given argument. + sep + "errors:" + sep + new cern.colt.matrix.doublealgo.formatter().totitlestring( errors,yedges,xedges,rowaxisname,columnaxisname,null,aggr); returns a string representation of the given argument. + sep + "errors:" + sep + new cern.colt.matrix.doublealgo.formatter().totitlestring( errors,yedges,xedges,rowaxisname,columnaxisname,null,aggr); returns a string representation of the given argument. + sep + "errors:" + sep + new cern.colt.matrix.doublealgo.formatter().totitlestring( errors,yedges,xedges,rowaxisname,columnaxisname,null,aggr); returns a xml representation of the given argument. returns a xml representation of the given argument. "x"; {hep.aida.bin.binfunctions1d.sum}; string format = "%1.2g"; cern.colt.matrix.doublematrix2d errors = new cern.colt.matrix.impl.densedoublematrix2d(1,h.xaxis().bins()); errors.viewrow(0).assign(toarrayerrors(h)); string format = "%1.2g"; keep coord. system keep the histo coord. system heights = heights.viewpart(1,1,heights.rows()-2,heights.columns()-2); // ignore under&overflows cern.colt.matrix.doublematrix2d errors = new cern.colt.matrix.impl.densedoublematrix2d(toarrayerrors(h)); errors = errors.viewdice().viewrowflip(); // keep the histo coord system //errors = errors.viewpart(1,1,errors.rows()-2,errors.columns()-2); // ignore under&overflows string format = "%1.2g"; keep coord. system keep coord. system keep the histo coord. system heights = heights.viewpart(1,1,heights.rows()-2,heights.columns()-2); // ignore under&overflows cern.colt.matrix.doublematrix2d errors = new cern.colt.matrix.impl.densedoublematrix2d(toarrayerrors(h)); errors = errors.viewdice().viewrowflip(); // keep the histo coord system //errors = errors.viewpart(1,1,errors.rows()-2,errors.columns()-2); // ignore under&overflows out.append(""); out.append(sep); out.append(""); out.append(sep); out.append(""); out.append(sep); out.append(""); out.append(sep); out.append(""); out.append(sep); out.append(""); out.append(sep); out.append(""); out.append(sep);"
hep.aida.ref.FixedAxis "fixed-width axis; a reference implementation of hep.aida.iaxis. create an axis number of bins minimum for axis maximum for axis this package private method is similar to coordtoindex except that it returns our internal definition for overflow/underflow package private method to map from the external representation of bin number to our internal representation of bin number package private for ease of use in histogram1d and histogram2d note, for internal consistency we save only min and binwidth and always use these quantities for all calculations. due to rounding errors the return value from upperedge is not necessarily exactly equal to max our internal definition of overflow/underflow differs from that of the outside world this.under = 0; this.over = bins+1;"
hep.aida.ref.Histogram "base class for histogram1d and histogram2d."
hep.aida.ref.Histogram1D "a reference implementation of hep.aida.ihistogram1d. the goal is to provide a clear implementation rather than the most efficient implementation. however, performance seems fine - filling 1.2 10^6 points/sec, both using fixedaxis or variableaxis. creates a variable-width histogram. example: edges = (0.2, 1.0, 5.0) yields an axis with 2 in-range bins [0.2,1.0), [1.0,5.0) and 2 extra bins [-inf,0.2), [5.0,inf]. the histogram title. the bin boundaries the axis shall have; must be sorted ascending and must not contain multiple identical elements. @throws illegalargumentexception if edges.length . creates a fixed-width histogram. the histogram title. the number of bins. the minimum value on the x axis. the maximum value on the x axis. creates a histogram with the given axis binning. the histogram title. the axis description to be used for binning. used internally for creating slices and projections total number of times fill called sum of all weights sum of the squares of the weights perhaps to be deleted (default impl. in superclass sufficient) return entries[xaxis.map(index)]; return math.sqrt(errors[xaxis.map(index)]); return heights[xaxis.map(index)]; int bin = xaxis.getbin(x); int bin = xaxis.getbin(x); todo: can we do anything sensible/useful with the other statistics?"
hep.aida.ref.Histogram2D "a reference implementation of hep.aida.ihistogram2d. the goal is to provide a clear implementation rather than the most efficient implementation. however, performance seems fine - filling 6 10^5 points/sec, both using fixedaxis or variableaxis. creates a variable-width histogram. example: xedges = (0.2, 1.0, 5.0, 6.0), yedges = (-5, 0, 7) yields 32 in-range bins. the histogram title. the bin boundaries the x-axis shall have; must be sorted ascending and must not contain multiple identical elements. the bin boundaries the y-axis shall have; must be sorted ascending and must not contain multiple identical elements. @throws illegalargumentexception if xedges.length . creates a fixed-width histogram. the histogram title. the number of bins on the x axis. the minimum value on the x axis. the maximum value on the x axis. the number of bins on the y axis. the minimum value on the y axis. the maximum value on the y axis. creates a histogram with the given axis binning. the histogram title. the x-axis description to be used for binning. the y-axis description to be used for binning. the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexy1 and indexy2 use our internal bin numbering scheme note 1the slice is done between indexy1 and indexy2 inclusive note 2indexy1 and indexy2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) used internally for creating slices and projections total number of times fill called sum of all weights sum of the squares of the weights return entries[xaxis.map(indexx)][yaxis.map(indexy)]; return math.sqrt(errors[xaxis.map(indexx)][yaxis.map(indexy)]); return heights[xaxis.map(indexx)][yaxis.map(indexy)]; int xbin = xaxis.getbin(x); int ybin = xaxis.getbin(y); int xbin = xaxis.getbin(x); int ybin = xaxis.getbin(y); attention: our internal definition of bins has been choosen so that this works properly even if the indeces passed in include the underflow or overflow bins for (int i=xaxis.under; i<=xaxis.over; i++) attention: our internal definition of bins has been choosen so that this works properly even if the indeces passed in include the underflow or overflow bins for (int j=yaxis.under; j<=yaxis.over; j++) todo: can we do anything sensible/useful with the other statistics?"
hep.aida.ref.Histogram3D "a reference implementation of hep.aida.ihistogram3d. the goal is to provide a clear implementation rather than the most efficient implementation. however, performance seems fine - filling 3 10^5 points/sec, both using fixedaxis or variableaxis. creates a variable-width histogram. example: xedges = (0.2, 1.0, 5.0, 6.0), yedges = (-5, 0, 7), zedges = (-5, 0, 7) yields 322 in-range bins. the histogram title. the bin boundaries the x-axis shall have; must be sorted ascending and must not contain multiple identical elements. the bin boundaries the y-axis shall have; must be sorted ascending and must not contain multiple identical elements. the bin boundaries the z-axis shall have; must be sorted ascending and must not contain multiple identical elements. @throws illegalargumentexception if xedges.length . creates a fixed-width histogram. the histogram title. the number of bins on the x axis. the minimum value on the x axis. the maximum value on the x axis. the number of bins on the y axis. the minimum value on the y axis. the maximum value on the y axis. the number of bins on the z axis. the minimum value on the z axis. the maximum value on the z axis. creates a histogram with the given axis binning. the histogram title. the x-axis description to be used for binning. the y-axis description to be used for binning. the z-axis description to be used for binning. the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexy1 and indexy2 use our internal bin numbering scheme note 1the slice is done between indexy1 and indexy2 inclusive note 2indexy1 and indexy2 may include the use of under and over flow bins note 3there is no note 3 (yet) the precise meaning of the arguments to the public slice methods is somewhat ambiguous, so we define this internal slice method and clearly specify its arguments.  note 0indexx1 and indexx2 use our internal bin numbering scheme note 1the slice is done between indexx1 and indexx2 inclusive note 2indexx1 and indexx2 may include the use of under and over flow bins note 3there is no note 3 (yet) total number of times fill called sum of all weights sum of the squares of the weights attention: our internal definition of bins has been choosen so that this works properly even if the indeces passed in include the underflow or overflow bins attention: our internal definition of bins has been choosen so that this works properly even if the indeces passed in include the underflow or overflow bins attention: our internal definition of bins has been choosen so that this works properly even if the indeces passed in include the underflow or overflow bins"
hep.aida.ref.Test "a very(!) basic test of the reference implementations of aida histograms. write the results as a plotml files! try some projections out.println(""); out.println(""); out.println(""); out.println(""); out.println(""); out.println(""); out.println("");"
hep.aida.ref.Test2 "a very(!) basic test of the reference implementations of aida histograms try { printwriter out = new printwriter(new filewriter(filename)); out.println(new converter().toxml(h)); out.close(); } catch (ioexception x) { x.printstacktrace(); } try { printwriter out = new printwriter(new filewriter(filename)); out.println(new converter().toxml(h)); out.close(); } catch (ioexception x) { x.printstacktrace(); } try { printwriter out = new printwriter(new filewriter(filename)); out.println(new converter().toxml(h)); out.close(); } catch (ioexception x) { x.printstacktrace(); } write the results as a plotml files! try some projections ihistogram1d h1 = new histogram1d("aida 1d histogram",2,-3,3); ihistogram2d h2 = new histogram2d("aida 2d histogram",2,-3,3, 2,-3,3); ihistogram3d h3 = new histogram3d("aida 3d histogram",new variableaxis(bounds),new variableaxis(bounds),new variableaxis(bounds)); write the results as a plotml files! try some projections system.out.println(new converter().toxml(h)); system.out.println(new converter().toxml(h)); system.out.println(new converter().toxml(h));"
hep.aida.ref.Util "convenient histogram utilities. creates a new utility object. returns the index of the in-range bin containing the maxbinheight(). returns the indexx of the in-range bin containing the maxbinheight(). returns the indexy of the in-range bin containing the maxbinheight(). returns the index of the in-range bin containing the minbinheight(). returns the indexx of the in-range bin containing the minbinheight(). returns the indexy of the in-range bin containing the minbinheight()."
hep.aida.ref.VariableAxis "variable-width axis; a reference implementation of hep.aida.iaxis. constructs and returns an axis with the given bin edges. example: edges = (0.2, 1.0, 5.0) yields an axis with 2 in-range bins [0.2,1.0), [1.0,5.0) and 2 extra bins [-inf,0.2), [5.0,inf]. the bin boundaries the partition shall have; must be sorted ascending and must not contain multiple identical elements. @throws illegalargumentexception if edges.length . returns a string representation of the specified array. the string representation consists of a list of the arrays's elements, enclosed in square brackets ("[]"). adjacent elements are separated by the characters ", " (comma and space). string representation of the specified array. check if really sorted and has no multiple identical elements int index = new doublearraylist(this.edges).binarysearch(coord); // just for debugging not found else index++; // found"
