#CANONICAL_CLASS_NAME "AUTHOR"
com.bulletphysics.BulletGlobals "bullet global settings and constants. cleans all current thread specific settings and caches. www.bulletphysics.com/ ////////////////////////////////////////////////////////////////////////// rigidbody ////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.BulletStats "bullet statistics and profile support. pushes profile node. use try/finally block to call {@link #popprofile} method. must be {@link string#intern interned} string (not needed for string literals) pops profile node. www.bulletphysics.com/ gjkpairdetector temp globals, to improve gjk/epa/penetration calculations discretedynamicsworld: java note: added for statistics in applet demo ////////////////////////////////////////////////////////////////////////// return 1000000f;"
com.bulletphysics.collision.broadphase.AxisSweep3 "axissweep3 is an efficient implementation of the 3d axis sweep and prune broadphase. it uses arrays rather then lists for storage of the 3 axis. also it operates using 16 bit integer coordinates instead of floats. for large worlds and many objects, use {@link axissweep3_32} instead. axissweep3_32 has higher precision and allows more than 16384 objects at the cost of more memory and bit of performance. = 16384 = 0 www.bulletphysics.com/ 1 handle is reserved as sentinel"
com.bulletphysics.collision.broadphase.AxisSweep3_32 "axissweep3_32 allows higher precision quantization and more objects compared to the {@link axissweep3} sweep and prune. this comes at the cost of more memory per handle, and a bit slower performance. = 1500000 = 0 www.bulletphysics.com/ 1 handle is reserved as sentinel"
com.bulletphysics.collision.broadphase.AxisSweep3Internal "axissweep3internal is an internal base class that implements sweep and prune. use concrete implementation {@link axissweep3} or {@link axissweep3_32}. = 16384 =0 for (int axis = 0; axis m_maxedges[axis]].m_pos m_minedges[axis]].m_pos || m_pedges[axis][phandleb->m_maxedges[axis]].m_pos m_minedges[axis]].m_pos) { return false; } } printf("btaxissweep3.h\n"); printf("numhandles = %d, maxhandles = %d\n",m_numhandles,m_maxhandles); printf("aabbmin=%f,%f,%f,aabbmax=%f,%f,%f\n",m_worldaabbmin.getx(),m_worldaabbmin.gety(),m_worldaabbmin.getz(), m_worldaabbmax.getx(),m_worldaabbmax.gety(),m_worldaabbmax.getz()); www.bulletphysics.com/ overall system bounds overall system bounds scaling factor for quantization number of active handles max number of handles handles pool free handles list edge arrays for the 3 axes (each array has m_maxhandles 2 + 2 sentinel entries) overlappingpaircallback is an additional optional java note: added need to add one sentinel handle assert(bounds.hasvolume()); init bounds allocate handles buffer and put all handles on free list handle 0 is reserved as the null index, and is also used as the sentinel allocate edge buffers removed overlap management make boundary sentinels #ifdef debug_broadphase debugprintaxis(axis); #endif //debug_broadphase java note: added allocation/deallocation optimization 1: check the array index (memory address), instead of the m_pos optimization 2: only 2 axis need to be tested (conflicts with 'delayed removal' optimization) #ifdef debug_broadphase void debugprintaxis(int axis,bool checkcardinality=true); #endif //debug_broadphase sorting a min edge downwards can only ever add overlaps if previous edge is a maximum check the bounds and add an overlap if necessary addoverlap(pedge->m_handle, pprev->m_handle); update edge reference in other handle swap the edges decrement #ifdef debug_broadphase debugprintaxis(axis); #endif //debug_broadphase sorting a min edge upwards can only ever remove overlaps if next edge is maximum remove any overlap between the two handles update edge reference in other handle swap the edges increment sorting a max edge downwards can only ever remove overlaps if previous edge was a minimum remove any overlap between the two handles this is done during the overlappingpairarray iteration/narrowphase collision update edge reference in other handle swap the edges decrement #ifdef debug_broadphase debugprintaxis(axis); #endif //debug_broadphase sorting a max edge upwards can only ever add overlaps if next edge is a minimum check the bounds and add an overlap if necessary update edge reference in other handle swap the edges increment perform a sort, to find duplicates and to sort 'invalid' pairs to the end callback->processoverlap(pair); remove duplicate should have no algorithm m_overlappingpairarray.swap(i,m_overlappingpairarray.size()-1); m_overlappingpairarray.pop_back(); if you don't like to skip the invalid pairs in the array, execute following code: #define clean_invalid_pairs 1 #ifdef clean_invalid_pairs perform a sort, to sort 'invalid' pairs to the end #endif//clean_invalid_pairs printf("overlappingpairarray.size()=%d\n",overlappingpairarray.size()); quantize the bounds allocate a handle phandle->m_poverlaps = 0; compute current limit of edge arrays insert new edges just inside the max boundary edge now sort the new edges to their correct position explicitly remove the pairs containing the proxy we could do it also in the sortminup (passing true) todo: compare performance compute current limit of edge arrays remove the edges by sorting them up to the end of the list #ifdef debug_broadphase debugprintaxis(axis,false); #endif //debug_broadphase free the handle quantize the new bounds update changed edges expand (only adds overlaps) shrink (only removes overlaps) #ifdef debug_broadphase debugprintaxis(axis); #endif //debug_broadphase public void processalloverlappingpairs(overlapcallback callback) { } optimization 1: check the array index (memory address), instead of the m_pos getaabb returns the axis aligned bounding box in the 'global' coordinate frame will add some transform later //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.broadphase.BroadphaseInterface "broadphaseinterface for aabb overlapping object pairs. www.bulletphysics.com/ /calculateoverlappingpairs is optional: incremental algorithms (sweep and prune) might do it during the set aabb /getaabb returns the axis aligned bounding box in the 'global' coordinate frame /will add some transform later"
com.bulletphysics.collision.broadphase.BroadphaseNativeType "dispatcher uses these types. important note: the types are ordered polyhedral, implicit convex and concave to facilitate type checking. www.bulletphysics.com/ polyhedral convex shapes: implicit convex shapes: concave shapes: keep all the convex shapetype below here, for the check isconvexshape in broadphase proxy! used for demo integration fast/swift collision library and bullet: terrain: used for gimpact trimesh integration: multimaterial mesh:"
com.bulletphysics.collision.broadphase.BroadphasePair "broadphasepair class contains a pair of aabb-overlapping objects. {@link dispatcher} can search a {@link collisionalgorithm} that performs exact/narrowphase collision detection on the actual collision shapes. && a.algorithm > b.m_algorithm www.bulletphysics.com/ java todo:"
com.bulletphysics.collision.broadphase.BroadphaseProxy "broadphaseproxy is the main class that can be used with the bullet broadphases. it stores collision shape type information, collision filter information and a client object, typically a {@link collisionobject} or {@link rigidbody}. www.bulletphysics.com/ usually the client collisionobject or rigidbody class todo: mask uniqueid is introduced for paircache. could get rid of this, by calculating the address offset etc."
com.bulletphysics.collision.broadphase.CollisionAlgorithm "collision algorithm for handling narrowphase or midphase collision detection between two collision object types. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); java note: added"
com.bulletphysics.collision.broadphase.CollisionAlgorithmConstructionInfo "construction information for collision algorithms. www.bulletphysics.com/ public int getdispatcherid();"
com.bulletphysics.collision.broadphase.CollisionFilterGroups "common collision filter groups. www.bulletphysics.com/ all bits sets: defaultfilter | staticfilter | kinematicfilter | debrisfilter | sensortrigger"
com.bulletphysics.collision.broadphase.Dbvt "unsigned sizeof(unsigned) sizeof(signs) sizeof(signs[0]) sizeof(unsigned)8 sizeof(signs) sizeof(signs[0]) insert 0 insert 1 3 2 stack element www.bulletphysics.com/ dbvt implementation by nathanael presson btalignedfree(m_free); dbvt_checktype dbvt_checktype dbvt_checktype dbvt_checktype dbvt_checktype dbvt_checktype dbvt_checktype dbvt_checktype stock.reserve(simple_stacksize); stack.reserve(simple_stacksize); ifree.reserve(simple_stacksize); java note: check #if dbvt_use_memmove memmove(&stack[j+1],&stack[j],sizeof(int)(stack.size()-j-1)); #else #endif #if dbvt_use_memmove memmove(&stack[j+1],&stack[j],sizeof(int)(stack.size()-j-1)); #else #endif dbvt_checktype ////////////////////////////////////////////////////////////////////////// volume+edge lengths btalignedfree(pdbvt->m_free); java note: check sets[0].reserve(splitcount[bestaxis][0]); sets[1].reserve(splitcount[bestaxis][1]); sets[0].reserve(leaves.size()/2+1); sets[1].reserve(leaves.size()/2); java todo: fix this //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.broadphase.DbvtAabbMm "www.bulletphysics.com/ dbvt implementation by nathanael presson public static dbvtaabbmm frompoints( btvector3 pts,int n); public static dbvtaabbmm frompoints( btvector3 ppts,int n); java note: check"
com.bulletphysics.collision.broadphase.DbvtBroadphase "moving www.bulletphysics.com/ dbvt implementation by nathanael presson dynamic set index fixed set index number of stages dbvt sets stages list pair cache frames predicted current stage % of fixed updates per frame % of dynamic updates per frame parse id gen id release pair cache on delete #if dbvt_bp_profile btclock m_clock; struct { unsigned long m_total; unsigned long m_ddcollide; unsigned long m_fdcollide; unsigned long m_cleanup; unsigned long m_jobcount; } m_profiling; #endif dbvt.benchmark(); #if dbvt_bp_profile clear(m_profiling); #endif spc(m_profiling.m_total); optimize: dynamic -> fixed set: collide dynamics: spc(m_profiling.m_fdcollide); spc(m_profiling.m_ddcollide); clean up: spc(m_profiling.m_cleanup); if(pa>pb) btswap(pa,pb); btalignedfree(proxy); fixed -> dynamic set dynamic set: #ifdef dbvt_bp_margin #else m_sets[0].update(proxy->leaf,aabb,deltam_predictedframes); #endif teleporting: #if dbvt_bp_profile if(0==(m_pid%dbvt_bp_profiling_rate)) { printf("fixed(%u) dynamics(%u) pairs(%u)\r\n",m_sets[1].m_leafs,m_sets[0].m_leafs,m_paircache->getnumoverlappingpairs()); printf("mode: %s\r\n",m_mode==mode_full?"full":"incremental"); printf("cleanup: %s\r\n",m_cleanupmode==cleanup_full?"full":"incremental"); unsigned int total=m_profiling.m_total; if(total<=0) total=1; printf("ddcollide: %u%% (%uus)\r\n",(50+m_profiling.m_ddcollide100)/total,m_profiling.m_ddcollide/dbvt_bp_profiling_rate); printf("fdcollide: %u%% (%uus)\r\n",(50+m_profiling.m_fdcollide100)/total,m_profiling.m_fdcollide/dbvt_bp_profiling_rate); printf("cleanup: %u%% (%uus)\r\n",(50+m_profiling.m_cleanup100)/total,m_profiling.m_cleanup/dbvt_bp_profiling_rate); printf("total: %uus\r\n",total/dbvt_bp_profiling_rate); const unsigned long sum=m_profiling.m_ddcollide+ m_profiling.m_fdcollide+ m_profiling.m_cleanup; printf("leaked: %u%% (%uus)\r\n",100-((50+sum100)/total),(total-sum)/dbvt_bp_profiling_rate); printf("job counts: %u%%\r\n",(m_profiling.m_jobcount100)/((m_sets[0].m_leafs+m_sets[1].m_leafs)dbvt_bp_profiling_rate)); clear(m_profiling); m_clock.reset(); } #endif"
com.bulletphysics.collision.broadphase.DbvtLeafCollider "www.bulletphysics.com/ dbvt implementation by nathanael presson #if dbvt_bp_discretpairs #endif if(pa>pb) btswap(pa,pb);"
com.bulletphysics.collision.broadphase.DbvtProxy "www.bulletphysics.com/ dbvt implementation by nathanael presson"
com.bulletphysics.collision.broadphase.DbvtTreeCollider "www.bulletphysics.com/ dbvt implementation by nathanael presson #if dbvt_bp_discretpairs #endif if(pa>pb) btswap(pa,pb);"
com.bulletphysics.collision.broadphase.Dispatcher "dispatcher abstract class can be used in combination with broadphase to dispatch calculations for overlapping pairs. for example for pairwise collision detection, calculating contact points stored in {@link persistentmanifold} or www.bulletphysics.com/ public abstract object allocatecollisionalgorithm(int size);"
com.bulletphysics.collision.broadphase.DispatcherInfo "current state of {@link dispatcher}. www.bulletphysics.com/ btstackalloc m_stackallocator;"
com.bulletphysics.collision.broadphase.DispatchFunc "www.bulletphysics.com/"
com.bulletphysics.collision.broadphase.HashedOverlappingPairCache "hash-space based {@link overlappingpaircache}. add a pair and return the new pair. if the pair already exists, no new pair is if (proxyid1 > proxyid2) btswap(proxyid1, proxyid2); missing swap here too, nat. if (proxyid1 > proxyid2) btswap(proxyid1, proxyid2); if (proxyid1 > proxyid2) btswap(proxyid1, proxyid2); for(int i=0;i%u\r\n",proxyid1,proxyid2); internalfindpair(proxy0, proxy1, hash); } } if (proxyid1 > proxyid2) btswap(proxyid1, proxyid2); www.bulletphysics.com/ java todo: overlappingpairarray.ensurecapacity(initialallocatedsize); java todo: optimize int pairindex = int(pair - &m_overlappingpairarray[0]); remove the pair from the hash table. we now move the last pair into spot of the pair being removed. we need to fix the hash table indices to support the move. if the removed pair is the last pair, we are done. remove the last pair from the hash table. copy the last pair into the remove pair's spot. insert the last pair into the hash table printf("m_overlappingpairarray.size()=%d\n",m_overlappingpairarray.size()); pair.algorithm.destroy(); btbroadphasepair getpairs() { return m_pairs; } new hash value with new mask this is where we add an actual pair, so also call the 'ghost' hash with new capacity pair->m_pproxy0 = proxy0; pair->m_pproxy1 = proxy1; grow hashtable and next table new hash value with new mask thomas wang's hash #if 0 // wrong, 'equalspair' use unsorted uids, copy-past devil striked again. nat. if (proxyid1 > proxyid2) btswap(proxyid1, proxyid2); #endif //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.broadphase.OverlapCallback "overlapcallback is used when processing all overlapping pairs in broadphase. @see overlappingpaircache#processalloverlappingpairs www.bulletphysics.com/ return true for deletion of the pair"
com.bulletphysics.collision.broadphase.OverlapFilterCallback "callback for filtering broadphase collisions. @see overlappingpaircache#setoverlapfiltercallback checks if given pair of collision objects needs collision. 0 first object 1 second object when pairs need collision www.bulletphysics.com/"
com.bulletphysics.collision.broadphase.OverlappingPairCache "overlappingpaircache provides an interface for overlapping pair management (add, remove, storage), used by the {@link broadphaseinterface} broadphases. www.bulletphysics.com/"
com.bulletphysics.collision.broadphase.OverlappingPairCallback "overlappingpaircallback class is an additional optional broadphase www.bulletphysics.com/"
com.bulletphysics.collision.broadphase.package-info "broadphase collision code for fast determining of overlapping pairs. www.bulletphysics.com/"
com.bulletphysics.collision.broadphase.SimpleBroadphase "simplebroadphase is just a unit-test for {@link axissweep3}, {@link axissweep3_32}, or {@link dbvtbroadphase}, so use those classes instead. it is a brute force aabb culling broadphase based on o(n^2) aabb checks. numhandles www.bulletphysics.com/ max number of handles java note: paircache.hasdeferredremoval() = true is not implemented system.out.printf("btsimplebroadphase.h\n"); system.out.printf("numhandles = %d, maxhandles = %d\n", /numhandles/ handles.size(), maxhandles);"
com.bulletphysics.collision.broadphase.SimpleBroadphaseProxy "www.bulletphysics.com/"
com.bulletphysics.collision.dispatch.CollisionAlgorithmCreateFunc "used by the collisiondispatcher to register and create instances for collisionalgorithm. www.bulletphysics.com/ java note: added"
com.bulletphysics.collision.dispatch.CollisionConfiguration "collisionconfiguration allows to configure bullet default collision algorithms. ///memory pools virtual btpoolallocator getpersistentmanifoldpool() = 0; virtual btpoolallocator getcollisionalgorithmpool() = 0; virtual btstackalloc getstackallocator() = 0; www.bulletphysics.com/ /memory pools"
com.bulletphysics.collision.dispatch.CollisionDispatcher "collisiondispatcher supports algorithms that handle convexconvex and convexconcave collision pairs. time of impact, closest points and penetration depth. void mem = 0; if (m_persistentmanifoldpoolallocator->getfreecount()) { mem = m_persistentmanifoldpoolallocator->allocate(sizeof(btpersistentmanifold)); } else { mem = btalignedalloc(sizeof(btpersistentmanifold),16); } btpersistentmanifold manifold = new(mem) btpersistentmanifold (body0,body1,0); manifold->m_index1a = m_manifoldsptr.size(); m_manifoldsptr.push_back(manifold); manifold->~btpersistentmanifold(); if (m_persistentmanifoldpoolallocator->validptr(manifold)) { m_persistentmanifoldpoolallocator->freememory(manifold); } else { btalignedfree(manifold); } www.bulletphysics.com/ private poolallocator m_collisionalgorithmpoolallocator; private poolallocator m_persistentmanifoldpoolallocator; private static int gnummanifold = 0; m_collisionalgorithmpoolallocator = collisionconfiguration->getcollisionalgorithmpool(); m_persistentmanifoldpoolallocator = collisionconfiguration->getpersistentmanifoldpool(); gnummanifold++; btassert(gnummanifold < 65535); gnummanifold--; printf("releasemanifold: gnummanifold %d\n",gnummanifold); todo: optimize #ifdef bt_debug broadphase filtering already deals with this #endif //bt_debug here you can do filtering no response between two static/kinematic bodies: m_blockedforchanges = true; m_blockedforchanges = false;"
com.bulletphysics.collision.dispatch.CollisionFlags "flags for collision objects. sets this collision object as static. sets this collision object as kinematic. disables contact response. enables calling {@link contactaddedcallback} for collision objects. this allows per-triangle material (friction/restitution). www.bulletphysics.com/"
com.bulletphysics.collision.dispatch.CollisionObject "collisionobject can be used to manage collision detection objects. it maintains all information that is needed for a collision detection: {@link collisionshape}, {@link transform} and {@link broadphaseproxy aabb proxy}. it can be added to {@link collisionworld}. avoid using this internal api call. internalsettemporarycollisionshape is used to temporary replace the actual collision shape by a child collision shape. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); island management, m_activationstate1 /m_interpolationworldtransform is used for ccd and interpolation /it can be either previous or future (predicted) transform those two are experimental: just added for bullet time effect, so you can still apply impulses (directly modifying velocities) without destroying the continuous interpolated motion (which uses this interpolation velocities) rootcollisionshape is temporarily used to store the original collision shape the collisionshape might be temporarily replaced by a child collision shape during collision detection purposes if it is null, the collisionshape is not temporarily replaced. / internaltype is reserved to distinguish bullet's collisionobject, rigidbody, softbody etc. do not assign your own internaltype unless you write a new dynamics object class. /time of impact calculation /swept sphere radius (0.0 by default), see btconvexconvexalgorithm:: / don't do continuous collision detection if the motion (in one step) is less then ccdmotionthreshold / if some object should have elaborate collision filtering by sub-classes /static objects, kinematic and object without contact response don't merge islands reserved for bullet internal usage swept sphere radius (0.0 by default), see btconvexconvexalgorithm:: swept sphere radius (0.0 by default), see btconvexconvexalgorithm:: don't do continuous collision detection if the motion (in one step) is less then ccdmotionthreshold java note: fixed bug with usage of ccdmotionthresholdccdmotionthreshold"
com.bulletphysics.collision.dispatch.CollisionObjectType "collision object type. www.bulletphysics.com/ =1 co_ghost_object keeps track of all objects overlapping its aabb and that pass its collision filter it is useful for collision sensors, explosion objects, character controller etc."
com.bulletphysics.collision.dispatch.CollisionWorld "collisionworld is interface and container for the collision detection. this constructor doesn't own the dispatcher and paircache/broadphase. objectquerysingle performs a collision detection query and calls the resultcallback. it is used internally by raytest. raytest performs a raycast on all objects in the collisionworld, and calls the resultcallback. this allows for several queries: first hit, all hits, any hit, dependent on the value returned by the callback. convextest performs a swept convex cast on all objects in the {@link collisionworld}, and calls the resultcallback this allows for several queries: first hit, all hits, any hit, dependent on the value return by the callback. localshapeinfo gives extra information for complex shapes. currently, only bttrianglemeshshape is available, so it just contains triangleindex and subpart. rayresultcallback is used to report new raycast results. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); protected btstackalloc m_stackalloc; clean up remaining objects  only clear the cached algorithms  check that the object isn't already added calculate new aabb todo: check if it's overwritten or not dispatcherinfo dispatchinfo = getdispatchinfo(); bool removefrombroadphase = false;  only clear the cached algorithms  swapremove java note: ported from 2.74, missing contact threshold stuff need to increase the aabb for contact thresholds moving objects should be moderately sized, probably something wrong if not todo: optimize something went wrong, investigate this assert is unwanted in 3d modelers (danger of loosing work) only update aabb of active objects todo #define use_subsimplex_convex_cast 1 #ifdef use_subsimplex_convex_cast #else btgjkconvexcast convexcaster(castshape,convexshape,&simplexsolver); btcontinuousconvexcollision convexcaster(castshape,convexshape,&simplexsolver,0); #endif //#use_subsimplex_convex_cast add hit #ifdef use_subsimplex_convex_cast rotate normal into worldspace #endif //use_subsimplex_convex_cast optimized version for bvhtrianglemeshshape todo: use aabb tree or other bvh acceleration structure! replace collision shape so that callback can determine the triangle restore ?? java todo: should be convexcaster1 continuousconvexcollision convexcaster1(castshape,convexshape,&simplexsolver,&gjkepapenetrationsolver); btsubsimplexconvexcast convexcaster3(castshape,convexshape,&simplexsolver); add hit rotation of box in local mesh space = meshrotation^-1 convextorotation rotation of box in local mesh space = meshrotation^-1 convextorotation todo: use aabb tree or other bvh acceleration structure! replace collision shape so that callback can determine the triangle restore go over all objects, and if the ray intersects their aabb, do a ray-shape query using convexcaster (ccd) terminate further ray tests, once the closesthitfraction reached zero only perform raycast if filtermask matches rigidcollisionobject collisionobject = ctrl->getrigidcollisionobject(); compute aabb that encompasses angular movement go over all objects, and if the ray intersects their aabb + cast shape aabb, do a ray-shape query using convexcaster (ccd) only perform raycast if filtermask matches rigidcollisionobject collisionobject = ctrl->getrigidcollisionobject(); could use resultcallback.closesthitfraction, but needs testing ////////////////////////////////////////////////////////////////////////// const btcollisionshape m_shapetemp; const bttransform m_shapelocaltransform; used to calculate hitpointworld from hitfraction caller already does the filter on the closesthitfraction need to transform normal into worldspace used to calculate hitpointworld from hitfraction caller already does the filter on the m_closesthitfraction need to transform normal into worldspace"
com.bulletphysics.collision.dispatch.CompoundCollisionAlgorithm "compoundcollisionalgorithm supports collision between {@link compoundshape}s and other collision shapes. www.bulletphysics.com/ childcollisionalgorithms.resize(numchildren); childcollisionalgorithms.get(i).destroy(); we will use the optimizedbvh, aabb tree to cull potential child-overlaps if both proxies are compound, we will deal with that directly, by performing sequential/parallel tree traversals given proxy0 and proxy1, if both have a tree, tree0 and tree1, this means: determine overlapping nodes of proxy1 using proxy0 aabb against tree1 then use each overlapping node aabb against tree0 and vise versa. temporarily exchange parent btcollisionshape with childshape, and recurse backup the contactpoint is still projected back using the original inverted worldtrans revert back we will use the optimizedbvh, aabb tree to cull potential child-overlaps if both proxies are compound, we will deal with that directly, by performing sequential/parallel tree traversals given proxy0 and proxy1, if both have a tree, tree0 and tree1, this means: determine overlapping nodes of proxy1 using proxy0 aabb against tree1 then use each overlapping node aabb against tree0 and vise versa. temporarily exchange parent btcollisionshape with childshape, and recurse backup bttransform newchildworldtrans = orgtranschildtrans ; revert back //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.ConvexConcaveCollisionAlgorithm "convexconcavecollisionalgorithm supports collision between convex shapes and (concave) trianges meshes. www.bulletphysics.com/ disable persistency. previously, some older algorithm calculated all contacts in one go, so you can clear it here. m_dispatcher->clearmanifold(m_btconvextrianglecallback.m_manifoldptr); quick approximation using raycast, todo: hook up to the continuous collision detection (one of the btconvexcast) only perform ccd above a certain threshold, this prevents blocking on the long run because object in a blocked ccd state (hitfractionm_worldtransform.getorigin(); btvector3 to = convexbody->m_interpolationworldtransform.getorigin(); todo: only do if the motion exceeds the 'radius' is this available? ////////////////////////////////////////////////////////////////////////// java note: moved here from processtriangle do a swept sphere for now bttransform ident; ident.setidentity(); gjkconvexcast convexcaster(&pointshape,convexshape,&simplexsolver); continuousconvexcollision convexcaster(&pointshape,convexshape,&simplexsolver,0); local space? //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.ConvexConvexAlgorithm "convexconvexalgorithm collision algorithm implements time of impact, convex closest points and penetration depth calculations. convex-convex collision algorithm. shape0->getmargin()+shape1->getmargin() www.bulletphysics.com/ swapped? #ifdef use_bt_gjkepa btconvexshape shape0(static_cast(body0->getcollisionshape())); btconvexshape shape1(static_cast(body1->getcollisionshape())); const btscalar radialmargin(0/shape0->getmargin()+shape1->getmargin()/); btgjkepasolver::sresults results; if(btgjkepasolver::collide( shape0,body0->getworldtransform(), shape1,body1->getworldtransform(), radialmargin,results)) { dispatchinfo.m_debugdraw->drawline(results.witnesses[1],results.witnesses[1]+results.normal,btvector3(255,0,0)); resultout->addcontactpoint(results.normal,results.witnesses[1],-results.depth); } #else java note: original: todo: if (dispatchinfo.m_usecontinuous) input.m_stackalloc = dispatchinfo.m_stackallocator; input.m_maximumdistancesquared = btscalar(1e30); #endif rather then checking all pairs, only calculate toi when motion exceeds threshold linear motion for one of objects needs to exceed m_ccdsquaremotionthreshold col0->m_worldtransform, an adhoc way of testing the continuous collision detection algorithms one object is approximated as a sphere, to simplify things starting in penetration should report no time of impact for proper ccd, better accuracy and handling of 'allowed' penetration should be added also the mainloop of the physics should have a kind of toi queue (something like brian mirtich's application of timewarp for rigidbodies) convex0 against sphere for convex1 todo: allow non-zero sphere sizes, for better approximation subsimplexconvexcast ccd0(&sphere,min0,&voronoisimplex); /simplification, one object is simplified as a sphere continuousconvexcollision ccd(min0,min1,&voronoisimplex,0); store result.m_fraction in both bodies sphere (for convex0) against convex1 todo: allow non-zero sphere sizes, for better approximation subsimplexconvexcast ccd0(&sphere,min0,&voronoisimplex); /simplification, one object is simplified as a sphere continuousconvexcollision ccd(min0,min1,&voronoisimplex,0); store result.m_fraction in both bodies should we use ownmanifold to avoid adding duplicates? //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.ConvexPlaneCollisionAlgorithm "convexplanecollisionalgorithm provides convex/plane collision detection. www.bulletphysics.com/ report a contact. internally this will be kept persistent, and contact reduction is done not yet //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.ConvexTriangleCallback "for each triangle in the concave mesh that overlaps with the aabb of a convex (see {@link #convexbody} field), processtriangle is called. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get();  create the manifold from the dispatcher 'manifold pool'  recalc aabbs collisionshape triangleshape = static_cast(tribody->m_collisionshape); just for debugging purposes printf("triangle %d",m_trianglecount++); aabb filter is already applied! debug drawing of the overlapping triangles btvector3 center = triangle[0] + triangle[1]+triangle[2]; center = btscalar(0.333333); m_dispatchinfoptr->m_debugdraw->drawline(tr(triangle[0]),tr(center),color); m_dispatchinfoptr->m_debugdraw->drawline(tr(triangle[1]),tr(center),color); m_dispatchinfoptr->m_debugdraw->drawline(tr(triangle[2]),tr(center),color); btcollisionobject colobj = static_cast(m_convexproxy->m_clientobject); this should use the btdispatcher, so the actual registered algorithm is used btconvexconvexalgorithm cvxcvxalgo(m_manifoldptr,ci,m_convexbody,m_tribody); cvxcvxalgo.setshapeidentifiers(-1,-1,partid,triangleindex); cvxcvxalgo.processcollision(m_convexbody,m_tribody,m_dispatchinfoptr,m_resultout); colalgo.destroy();"
com.bulletphysics.collision.dispatch.DefaultCollisionConfiguration "default implementation of {@link collisionconfiguration}. provides all core collision algorithms. some extra algorithms (like {@link gimpactcollisionalgorithm gimpact}) must be registered manually by calling appropriate register method. //default creationfunctions, filling the m_doubledispatch table m_sphereboxcf = new(mem) btsphereboxcollisionalgorithm::createfunc; m_boxspherecf = new (mem)btsphereboxcollisionalgorithm::createfunc; m_boxspherecf->m_swapped = true; m_spheretrianglecf = new (mem)btspheretrianglecollisionalgorithm::createfunc; m_trianglespherecf = new (mem)btspheretrianglecollisionalgorithm::createfunc; m_trianglespherecf->m_swapped = true; mem = btalignedalloc(sizeof(btboxboxcollisionalgorithm::createfunc),16); m_boxboxcf = new(mem)btboxboxcollisionalgorithm::createfunc; ///calculate maximum element size, big enough to fit any collision algorithm in the memory pool int maxsize = sizeof(btconvexconvexalgorithm); int maxsize2 = sizeof(btconvexconcavecollisionalgorithm); int maxsize3 = sizeof(btcompoundcollisionalgorithm); int maxsize4 = sizeof(btemptyalgorithm); int collisionalgorithmmaxelementsize = btmax(maxsize,maxsize2); collisionalgorithmmaxelementsize = btmax(collisionalgorithmmaxelementsize,maxsize3); collisionalgorithmmaxelementsize = btmax(collisionalgorithmmaxelementsize,maxsize4); if (stackalloc) { m_ownsstackallocator = false; this->m_stackalloc = stackalloc; } else { m_ownsstackallocator = true; void mem = btalignedalloc(sizeof(btstackalloc),16); m_stackalloc = new(mem)btstackalloc(default_stack_allocator_size); } if (persistentmanifoldpool) { m_ownspersistentmanifoldpool = false; m_persistentmanifoldpool = persistentmanifoldpool; } else { m_ownspersistentmanifoldpool = true; void mem = btalignedalloc(sizeof(btpoolallocator),16); m_persistentmanifoldpool = new (mem) btpoolallocator(sizeof(btpersistentmanifold),default_max_overlapping_pairs); } if (collisionalgorithmpool) { m_ownscollisionalgorithmpool = false; m_collisionalgorithmpool = collisionalgorithmpool; } else { m_ownscollisionalgorithmpool = true; void mem = btalignedalloc(sizeof(btpoolallocator),16); m_collisionalgorithmpool = new(mem) btpoolallocator(collisionalgorithmmaxelementsize,default_max_overlapping_pairs); } if ((proxytype0 == sphere_shape_proxytype) && (proxytype1==box_shape_proxytype)) { return m_sphereboxcf; } if ((proxytype0 == box_shape_proxytype ) && (proxytype1==sphere_shape_proxytype)) { return m_boxspherecf; } if ((proxytype0 == sphere_shape_proxytype ) && (proxytype1==triangle_shape_proxytype)) { return m_spheretrianglecf; } if ((proxytype0 == triangle_shape_proxytype ) && (proxytype1==sphere_shape_proxytype)) { return m_trianglespherecf; } if ((proxytype0 == box_shape_proxytype) && (proxytype1 == box_shape_proxytype)) { return boxboxcf; } www.bulletphysics.com/ default simplex/penetration depth solvers default creationfunctions, filling the m_doubledispatch table #define use_epa 1 #ifdef use_epa #else pdsolver = new minkowskipenetrationdepthsolver(); #endif//use_epa default creationfunctions, filling the m_doubledispatch table convex versus plane /calculate maximum element size, big enough to fit any collision algorithm in the memory pool failed to find an algorithm"
com.bulletphysics.collision.dispatch.DefaultNearCallback "default implementation of {@link nearcallback}. www.bulletphysics.com/ dispatcher will keep algorithms persistent in the collision pair manifoldresult contactpointresult = new manifoldresult(colobj0, colobj1); discrete collision detection query continuous collision detection query, time of impact (toi)"
com.bulletphysics.collision.dispatch.EmptyAlgorithm "empty algorithm, used as fallback when no collision algorithm is found for given shape type pair. www.bulletphysics.com/ //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.GhostObject "ghostobject can keep track of all objects that are overlapping. by default, this overlap is based on the aabb. this is useful for creating a character controller, collision sensors/triggers, explosions etc. this method is mainly for expert/internal use only. this method is mainly for expert/internal use only. www.bulletphysics.com/ if this linearsearch becomes too slow (too many overlapping objects) we should add a more appropriate data structure not found compute aabb that encompasses angular movement go over all objects, and if the ray intersects their aabb + cast shape aabb, do a ray-shape query using convexcaster (ccd) only perform raycast if filtermask matches rigidcollisionobject collisionobject = ctrl->getrigidcollisionobject(); could use resultcallback.closesthitfraction, but needs testing only perform raycast if filtermask matches  internal cast"
com.bulletphysics.collision.dispatch.GhostPairCallback "ghostpaircallback interfaces and forwards adding and removal of overlapping pairs from the {@link broadphaseinterface} to {@link ghostobject}. www.bulletphysics.com/ need to keep track of all ghost objects and call them here hashpaircache.removeoverlappingpairscontainingproxy(proxy0, dispatcher);"
com.bulletphysics.collision.dispatch.ManifoldResult "manifoldresult is helper class to manage contact results. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); we need this for compounds order in manifold needs to match bp mod, store contact triangles. / todo, check this for any side effects const btmanifoldpoint& oldpoint = m_manifoldptr->getcontactpoint(insertindex);  and if either of the two bodies requires custom material experimental feature info, for per-triangle material etc. /"
com.bulletphysics.collision.dispatch.NearCallback "callback for overriding collision filtering and more fine-grained control over collision detection. @see collisiondispatcher#setnearcallback @see collisiondispatcher#getnearcallback www.bulletphysics.com/"
com.bulletphysics.collision.dispatch.package-info "dispatching code for collisions between various shapes. www.bulletphysics.com/"
com.bulletphysics.collision.dispatch.PairCachingGhostObject "this method is mainly for expert/internal use only. www.bulletphysics.com/ if this linearsearch becomes too slow (too many overlapping objects) we should add a more appropriate data structure"
com.bulletphysics.collision.dispatch.SimulationIslandManager "simulationislandmanager creates and handles simulation islands, using {@link unionfind}. www.bulletphysics.com/ put the index into m_controllers into m_tag do the union find put the islandid ('find' value) into m_tag we are going to sort the unionfind array, and store the element id in the size afterwards, we clean unionfind, to make sure no-one uses it anymore update the sleeping state for bodies, if all are sleeping int numsleeping = 0; system.err.println("error in island management\n"); int idx; system.err.println("error in island management\n"); int idx; system.err.println("error in island management\n"); #define split_islands 1 #ifdef split_islands #endif //split_islands todo: check sleeping conditions! kinematic objects don't merge islands, but wake up all connected objects #ifdef split_islands filtering for response #endif //split_islands #ifndef split_islands btpersistentmanifold manifold = dispatcher->getinternalmanifoldpointer();  callback->processisland(&collisionobjects[0],collisionobjects.size(),manifold,maxnummanifolds, -1); #else sort manifolds, based on islands sort the vector using predicate and std::sort std::sort(islandmanifold.begin(), islandmanifold.end(), btpersistentmanifoldsortpredicate); we should do radix sort, it it much faster (o(n) instead of o (n log2(n)) islandmanifold.heapsort(btpersistentmanifoldsortpredicate()); java note: memory optimized sorting with caching of temporary array collections.sort(islandmanifold, persistentmanifoldcomparator); now process all active islands (sets of manifolds for now) int islandid; printf("start islands\n"); traverse the simulation islands, and call the solver, unless all objects are sleeping/deactivated find the accompanying contact manifold for this islandid objectarraylist startmanifold = null; startmanifold = &m_islandmanifold[startmanifoldindex]; startmanifold = islandmanifold.sublist(startmanifoldindex, islandmanifold.size()); process the actual simulation, only if not sleeping/deactivated printf("island callback of size:%d bodies, %d manifolds\n",islandbodies.size(),numislandmanifolds); #endif //split_islands //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.SphereSphereCollisionAlgorithm "provides collision detection between two spheres. www.bulletphysics.com/ #ifdef clear_manifold manifoldptr.clearmanifold(); // don't do this, it disables warmstarting #endif if distance positive, don't generate a new contact #ifndef clear_manifold #endif //clear_manifold distance (negative means penetration) point on a (worldspace) point on b (worldspace) report a contact. internally this will be kept persistent, and contact reduction is done #ifndef clear_manifold #endif //clear_manifold //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.dispatch.UnionFind "unionfind calculates connected subsets. implements weighted quick union with path compression. this is a special operation, destroying the content of unionfind. it sorts the elements, based on island id, in order to make it easy to iterate over islands. www.bulletphysics.com/ optimization: could use short ints instead of ints (halving memory, would limit the number of rigid bodies to 64k, sounds reasonable). first store the original body index, and islandid sort the vector using predicate and std::sort std::sort(m_elements.begin(), m_elements.end(), btunionfindelementsortpredicate); perhaps use radix sort? elements.heapsort(btunionfindelementsortpredicate()); collections.sort(elements); #ifndef use_path_compression //weighted quick union, this keeps the 'trees' balanced, and keeps performance of unite o( log(n) ) if (m_elements[i].m_sz = 0); not really a reason not to use path compression, and it flattens the trees/improves find performance dramatically #ifdef use_path_compression #endif // assert(x = 0); //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.narrowphase.ConvexCast "convexcast is an interface for casting. cast a convex against another convex object. rayresult stores the closest result. alternatively, add a callback method to decide about closest/all results. www.bulletphysics.com/ ////////////////////////////////////////////////////////////////////////// input and output"
com.bulletphysics.collision.narrowphase.ConvexPenetrationDepthSolver "convexpenetrationdepthsolver provides an interface for penetration depth calculation. , btstackalloc stackalloc www.bulletphysics.com/"
com.bulletphysics.collision.narrowphase.DiscreteCollisionDetectorInterface "this interface is made to be used by an iterative approach to do timeofimpact calculations. this interface allows to query for closest points and penetration depth between two (convex) objects the closest point is on the second object (b), and the normal points from the surface on b towards a. distance is between closest points on b and closest point on a. so you can calculate closest point on a by taking closestpointina = closestpointinb + distance normalonsurfaceb. give either closest points (distance > 0) or penetration (distance) the normal always points from b towards a. give either closest points (distance > 0) or penetration (distance) the normal always points from b towards a. www.bulletphysics.com/ /setshapeidentifiers provides experimental support for per-triangle material / custom material combiner btstackalloc m_stackalloc;"
com.bulletphysics.collision.narrowphase.GjkConvexCast "gjkconvexcast performs a raycast on a convex object using support mapping. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); #ifdef bt_use_double_precision private static final int max_iterations = 64; #else #endif compute linear velocity for this interval, to interpolate assume no rotation/angular velocity, assert here? btscalar epsilon = btscalar(0.001); first solution, using gjk result.drawcoordsystem(spheretr); penetrationdepthsolver); we don't use margins during ccd gjk.setignoremargin(true); not close enough todo: report a failure todo: next check with relative epsilon n.setvalue(0,0,0); break; interpolate to next lambda ?? is n normalized? don't report time of impact for motion away from the contact normal (or causes minor penetration)"
com.bulletphysics.collision.narrowphase.GjkEpaPenetrationDepthSolver "gjkepapenetrationdepthsolver uses the expanding polytope algorithm to calculate the penetration depth between two convex shapes. , btstackalloc stackalloc ,stackalloc www.bulletphysics.com/ java note: 2.70b1: update when gjkepasolver2 is ported debugdraw->drawline(results.witnesses[1],results.witnesses[1]+results.normal,btvector3(255,0,0)); resultout->addcontactpoint(results.normal,results.witnesses[1],-results.depth);"
com.bulletphysics.collision.narrowphase.GjkEpaSolver "gjk-epa collision solver by nathanael presson nov.2006 gjkepasolver contributed under zlib by nathanael presson. shapes doesnt penetrate shapes are penetrating gjk phase fail, no big issue, shapes are probably just 'touching' epa phase fail, bigger problem, need to save parameters, and debug [2] [2] [2] unsigned unsigned stackalloc psa, stackalloc psa, stackalloc psa, unsigned unsigned [4][3] [6][4] [6][3] [9][4] [2] prepare hull expand hull extract contact , btstackalloc stackalloc use gjk to locate origin stackalloc, then epa for penetration depth www.bulletphysics.com/ ////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// minkowski vertice ray protected final bulletstack stack = bulletstack.get(); public btstackalloc sa; public block sablock; sa =psa; sablock =sa->beginblock(); vdh: very dummy hash e = (he)sa->allocate(sizeof(he)); e = new he(); todo: optimize todo: optimize point line triangle tetrahedron hexahedron ////////////////////////////////////////////////////////////////////////// protected final bulletstack stack = bulletstack.get(); public btstackalloc sa; sa = pgjk->sa; face pf = new face(); mkv v = new mkv(); btblock sablock = sa->beginblock(); const u pfidx = 0; const u peidx = 0; tetrahedron pfidx=(const u)fidx; peidx=(const u)eidx; hexahedron pfidx=(const u)fidx; peidx=(const u)eidx; sa->endblock(sablock); sa->endblock(sablock); ////////////////////////////////////////////////////////////////////////// initialize"
com.bulletphysics.collision.narrowphase.GjkPairDetector "gjkpairdetector uses gjk to implement the {@link discretecollisiondetectorinterface}. ,input.stackalloc don't use setignoremargin, it's for bullet's internal use. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); must be above the machine epsilon some debugging to fix degeneracy problems for ccd we don't use margins this is to catch invalid input, perhaps check for #nan? while (true) potential exit, they don't overlap exit 0: the new point is already in the simplex, or we didn't come any closer are we getting any closer ? add current vertex to simplex calculate the closest point to the origin (update vector v) redundant m_simplexsolver->compute_points(pointona, pointonb); are we getting any closer ? degeneracy, this is typically due to invalid/uninitialized worldtransforms for a collisionobject #if defined(debug) || defined (_debug) #endif bool check = (!m_simplexsolver->fullsimplex() && squareddistance > simd_epsilon m_simplexsolver->maxvertex()); do we need this backup_closest here ? valid normal normalize if (checkpenetration && !isvalid) penetration case if there is no way to handle penetrations, bail out penetration depth case. only replace valid penetrations when the result is deeper (check) isvalid = false; #ifdef __spu__ //spu_printf("distance\n"); #endif //__cellos_lv2__ printf("gjk add:%f",distance);"
com.bulletphysics.collision.narrowphase.ManifoldPoint "manifoldpoint collects and maintains persistent contactpoints. used to improve stability and performance of rigidbody dynamics response. www.bulletphysics.com/ /m_positionworldona is redundant information, see getpositionworldona(), but for clarity bp mod, store contact triangles. lifetime of the contactpoint in frames return m_positionworldonb + m_normalworldonb m_distance1;"
com.bulletphysics.collision.narrowphase.package-info "narrow-phase collision. www.bulletphysics.com/"
com.bulletphysics.collision.narrowphase.PersistentManifold "persistentmanifold is a contact point cache, it stays persistent as long as objects are overlapping in the broadphase. those contact points are www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); / this two body pointers can point to the physics rigidbody class. / void will allow any rigidbody class / sort cached points so most isolated points come first calculate 4 possible cases areas, and take biggest area also need to keep 'deepest' #define keep_deepest_point 1 #ifdef keep_deepest_point #endif //keep_deepest_point private int findcontactpoint(manifoldpoint unused, int numunused, manifoldpoint pt); #ifdef debug_persistency int i; int occurance = 0; for (i = 0; i  1) { throw new internalerror(); } } } assert (occurance = 4 sort cache so best points come first, based on area #else #endif m_pointcache[index] = m_pointcache[lastusedindex]; todo: possible bug get rid of duplicated #define maintain_persistency 1 #ifdef maintain_persistency #else clear m_pointcache[insertindex] = newpoint; #endif / calculated new worldspace coordinates and depth, and reject points that exceed the collision margin #ifdef debug_persistency printf("refreshcontactpoints posa = (%f,%f,%f) posb = (%f,%f,%f)\n", tra.getorigin().getx(), tra.getorigin().gety(), tra.getorigin().getz(), trb.getorigin().getx(), trb.getorigin().gety(), trb.getorigin().getz()); #endif //debug_persistency first refresh worldspace positions and distance then contact becomes invalid when signed distance exceeds margin (projected on contactnormal direction) contact also becomes invalid when relative movement orthogonal to normal exceeds margin contact point processed callback #ifdef debug_persistency debugpersistency(); #endif //"
com.bulletphysics.collision.narrowphase.PointCollector "www.bulletphysics.com/ negative means penetration ?? negative means penetration"
com.bulletphysics.collision.narrowphase.SimplexSolverInterface "simplexsolverinterface can incrementally calculate distance between origin and up to 4 vertices. used by gjk or linear casting. can be implemented by the johnson-algorithm or alternative approaches based on voronoi regions or barycentric coordinates. www.bulletphysics.com/"
com.bulletphysics.collision.narrowphase.SubsimplexConvexCast "subsimplexconvexcast implements gino van den bergens' paper "ray casting against bteral convex objects with application to continuous collision detection" gjk based ray cast, optimized version objects should not start in overlap, otherwise results are not defined. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); typically the conservative advancement reaches solution in a few iterations, clip it to 32 for degenerate cases. see discussion about this here http://www.bulletphysics.com/phpbb2/viewtopic.php?t=565 #ifdef bt_use_double_precision #define max_iterations 64 #else #define max_iterations 32 #endif take relative motion #ifdef bt_use_double_precision btscalar epsilon = btscalar(0.0001); #else #endif interpolate to next lambda x = s + lambda r; m_simplexsolver->reset(); check next line todo: check this normal for validity n.set(v); printf("v=%f , %f, %f\n",v[0],v[1],v[2]); printf("dist2=%f\n",dist2); printf("numverts = %i\n",m_simplexsolver->numvertices()); int numiter = max_iterations - maxiter; printf("number of iterations: %d", numiter); don't report a time of impact when moving 'away' from the hitnormal don't report time of impact for motion away from the contact normal (or causes minor penetration)"
com.bulletphysics.collision.narrowphase.TriangleConvexcastCallback "btcontinuousconvexcast's normal is already in world space //#ifdef use_subsimplex_convex_cast // rotate normal into worldspace convexshapefrom.basis.transform(castresult.normal); //#endif //use_subsimplex_convex_cast www.bulletphysics.com/ #define use_subsimplex_convex_cast 1 if you reenable use_subsimplex_convex_cast see commented out code below #ifdef use_subsimplex_convex_cast todo: implement continuousconvexcollision #else //btgjkconvexcast convexcaster(m_convexshape,&triangleshape,&simplexsolver); btcontinuousconvexcollision convexcaster(m_convexshape,&triangleshape,&simplexsolver,&gjkepapenetrationsolver); #endif //#use_subsimplex_convex_cast add hit #ifdef use_subsimplex_convex_cast rotate normal into worldspace #endif //use_subsimplex_convex_cast"
com.bulletphysics.collision.narrowphase.TriangleRaycastCallback "www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); same sign now we have the intersection point on the plane, we'll see if it's inside the triangle add an epsilon as a tolerance for the raycast, in case the ray hits exacly on the edge of the triangle. it must be scaled for the triangle size."
com.bulletphysics.collision.narrowphase.VoronoiSimplexSolver "voronoisimplexsolver is an implementation of the closest point distance algorithm from a 1-4 points simplex to the origin. can be used with gjk, as an alternative to johnson distance algorithm. clear the simplex, remove all the vertices. return/calculate the closest vertex. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); == m_simplexvectorw[0] closest point origin from line segment reduce to 1 point reduce to 1 point closest point origin from triangle printf("sub distance got penetration\n"); degenerate case == false, penetration = true + zero closest point origin from tetrahedron check if p in vertex region outside a a; // barycentric coordinates (1,0,0) check if p in vertex region outside b b; // barycentric coordinates (0,1,0) check if p in edge region of ab, if so return projection of p onto ab return a + v ab; // barycentric coordinates (1-v,v,0) check if p in vertex region outside c c; // barycentric coordinates (0,0,1) check if p in edge region of ac, if so return projection of p onto ac return a + w ac; // barycentric coordinates (1-w,0,w) check if p in edge region of bc, if so return projection of p onto bc return b + w (c - b); // barycentric coordinates (0,1-w,w) p inside face region. compute q through its barycentric coordinates (u,v,w) return a + ab v + ac w; // = ua + vb + wc, u = va denom = btscalar(1.0) - v - w / test if point p and d lie on opposite sides of plane through abc [ap ab ac] [ad ab ac] #ifdef catch_degenerate_tetrahedron #ifdef bt_use_double_precision if (signd signd < (btscalar(1e-8) btscalar(1e-8))) { return -1; } #else printf("affine dependent/degenerate\n");// #endif #endif points on opposite sides if expression signs are opposite start out assuming point inside all halfspaces, so closest to itself if point outside face abc then compute closest point on abc update best closest point if (squared) distance is less than current best convert result bitmask! repeat test for face acd convert result bitmask! repeat test for face adb convert result bitmask! repeat test for face bdc convert result bitmask!  help! we ended up full ! btscalar maxv = btscalar(0.); w is in the current (reduced) simplex check in case lastw is already removed ////////////////////////////////////////////////////////////////////////// mask for m_usedvertices stores the simplex vertex-usage, using the mask, if m_usedvertices & mask then the related vertex is used"
com.bulletphysics.collision.shapes.BoxShape "boxshape is a box primitive around the origin, its sides axis aligned with length specified by half extents, in local shape coordinates. when used as part of a {@link collisionobject} or {@link rigidbody} it will be an oriented box in world space. www.bulletphysics.com/ changed in bullet 2.63: assume the scaling and margin are included correct the implicitshapedimensions for the margin btscalar margin = btscalar(0.); this plane might not be aligned... btscalar mindist = 2tolerance;"
com.bulletphysics.collision.shapes.BU_Simplex1to4 "bu_simplex1to4 implements feature based and implicit simplex of up to 4 vertices (tetrahedron, triangle, line, vertex). www.bulletphysics.com/ euler formula, f-e+v = 2, so e = f+v-2"
com.bulletphysics.collision.shapes.BvhSubtreeInfo "bvhsubtreeinfo provides info to gather a subtree of limited size. unsigned unsigned www.bulletphysics.com/ points to the root of the subtree"
com.bulletphysics.collision.shapes.BvhTriangleMeshShape "bvhtrianglemeshshape is a static-triangle mesh shape with several optimizations, such as bounding volume hierarchy. it is recommended to enable usequantizedaabbcompression for better memory usage. it takes a triangle mesh as input, for example a {@link trianglemesh} or {@link triangleindexvertexarray}. the bvhtrianglemeshshape class allows for triangle mesh deformations by a refit or partialrefit method. instead of building the bounding volume hierarchy acceleration structure, it is also possible to serialize (save) and deserialize (load) the structure from disk. see concavedemo for an example. optionally pass in a larger bvh aabb, used for quantization. this allows for deformations within this aabb. optionally pass in a larger bvh aabb, used for quantization. this allows for deformations within this aabb. perform bvh tree traversal and report overlapping triangles to 'callback'. for a fast incremental refit of parts of the tree. note: the entire aabb of the tree will become more conservative, it never shrinks. if (ownsbvh) { m_bvh->~btoptimizedbvh(); btalignedfree(m_bvh); } [3] perform ray vs. triangle collision here www.bulletphysics.com/ construct bvh from meshinterface #ifndef disable_bvh java note: moved from trianglemeshshape #endif //disable_bvh construct bvh from meshinterface #ifndef disable_bvh java note: moved from trianglemeshshape #endif //disable_bvh #ifdef disable_bvh // brute force traverse all triangles bttrianglemeshshape::processalltriangles(callback,aabbmin,aabbmax); #else first get all the nodes #endif//disable_bvh java note: update it for 2.70b1 bvh.refit(meshinterface, aabbmin, aabbmax); /m_localaabbmin/m_localaabbmax is already re-calculated in bttrianglemeshshape. we could just scale aabb, but this needs some more work rebuild the bvh... update the scaling without rebuilding the bvh //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.shapes.ByteBufferVertexData "www.bulletphysics.com/"
com.bulletphysics.collision.shapes.CapsuleShape "capsuleshape represents a capsule around the y axis, there is also the {@link capsuleshapex} aligned around the x axis and {@link capsuleshapez} around the z axis. the total height is height+2radius, so the height is just the height between the center of each "sphere" of the capsule caps. capsuleshape is a convex hull of two spheres. the {@link multisphereshape} is a more general collision shape that takes the convex hull of multiple sphere, so it can also represent a capsule when just using two spheres. www.bulletphysics.com/ only used for capsuleshapez and capsuleshapex subclasses. todo: implement as an approximation, take the inertia of the box that bounds the spheres"
com.bulletphysics.collision.shapes.CapsuleShapeX "capsuleshapex represents a capsule around the x axis. the total height is height+2radius, so the height is just the height between the center of each "sphere" of the capsule caps. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.CapsuleShapeZ "capsuleshapez represents a capsule around the z axis. the total height is height+2radius, so the height is just the height between the center of each "sphere" of the capsule caps. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.CollisionShape "collisionshape class provides an interface for collision shapes that can be shared among {@link collisionobject}s. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); /getaabb returns the axis aligned bounding box in the coordinate frame of the given transform t. /getangularmotiondisc returns the maximus radius needed for conservative advancement to handle time-of-impact with rotations. todo: stack /calculatetemporalaabb calculates the enclosing aabb for the moving object over interval [0..timestep) /result is conservative start with static aabb add linear motion todo: simd would have a vector max/min operation, instead of per-element access add conservative angular motion #ifndef __spu__ /isinfinite is used to catch simulation error (aabb check) todo: returns const debugging support #endif //__spu__ optional"
com.bulletphysics.collision.shapes.CompoundShape "compoundshape allows to store multiple other {@link collisionshape}s. this allows for moving concave collision objects. this is more general than the {@link bvhtrianglemeshshape}. remove all children shapes that contain the specified shape. getaabb's default implementation is brute force, expected derived classes to implement a fast dedicated version. re-calculate the local aabb. is called at the end of removechildshapes. use this yourself if you modify the children or their transforms. computes the exact moment of inertia and the transform from the coordinate system defined by the principal axes of the moment of inertia and the center of mass to the current coordinate system. "masses" points to an array of masses of the children. the resulting transform "principal" has to be applied inversely to all children transforms in order for the local coordinate system of the compound shape to be centered at the center of mass and to coincide with the principal axes. this also necessitates a correction of the world transform of the collision object by the principal transform. www.bulletphysics.com/ java note: compoundshape from 2.71 m_childtransforms.push_back(localtransform); m_childshapes.push_back(shape); extend the local aabbmin/aabbmax java note: rewritten for (int i=0;i _localaabbmin[i]) { this.localaabbmin[i] = _localaabbmin[i]; } if (this.localaabbmax[i] < _localaabbmax[i]) { this.localaabbmax[i] = _localaabbmax[i]; } } find the children containing the shape specified, and remove those children. do another iteration pass after removing from the vector recalculate the local aabb brute force, it iterates over all the shapes left. extend the local aabbmin/aabbmax approximation: take the inertia from the aabb for now this is optional, but should make collision queries faster, by culling non-overlapping nodes void createaabbtreefromchildren(); compute inertia tensor in coordinate system of compound shape add inertia tensor compute inertia tensor of pointmass at o add inertia tensor of pointmass"
com.bulletphysics.collision.shapes.CompoundShapeChild "compound shape child. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.ConcaveShape "concaveshape class provides an interface for non-moving (static) concave shapes. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.ConeShape "coneshape implements a cone shape primitive, centered around the origin and aligned with the y axis. the {@link coneshapex} is aligned around the x axis and {@link coneshapez} around the z axis. www.bulletphysics.com/ inertia.x() = scaledmass (y2+z2); inertia.y() = scaledmass (x2+z2); inertia.z() = scaledmass (x2+y2); choose upaxis index"
com.bulletphysics.collision.shapes.ConeShapeX "coneshape implements a cone shape, around the x axis. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.ConeShapeZ "coneshape implements a cone shape, around the z axis. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.ConvexHullShape "convexhullshape implements an implicit convex hull of an array of vertices. bullet provides a general and fast collision detector for convex shapes based on gjk and epa using localgetsupportingvertex. todo: this constructor optionally takes in a pointer to points. each point is assumed to be 3 consecutive float (x,y,z), the striding defines the number of bytes between each point, in memory. it is easier to not pass any points in the constructor, and just add one point at a time, using addpoint. convexhullshape make an internal copy of the points. currently just for debugging (drawing), perhaps future support for algebraic continuous collision detection. please note that you can debug-draw convexhullshape with the raytracer demo. www.bulletphysics.com/ todo: make better constuctors (bytebuffer, etc.) java note: rewritten java note: rewritten as code used w coord for temporary usage in vector3 todo: optimize it use 'w' component of supportverticesout? supportverticesout[i][3] = btscalar(-1e30); if (newdot > supportverticesout[j][3]) warning: don't swap next lines, the w component would get overwritten! supportverticesout[j][3] = newdot;"
com.bulletphysics.collision.shapes.ConvexInternalShape "convexinternalshape is an internal base class, shared by most convex shape implementations. getaabb's default implementation is brute force, expected derived classes to implement a fast dedicated version. www.bulletphysics.com/ local scaling. collisionmargin is not scaled !"
com.bulletphysics.collision.shapes.ConvexShape "convexshape is an abstract shape class. it describes general convex shapes using the {@link #localgetsupportingvertex localgetsupportingvertex} interface used in combination with gjk or convexcast. www.bulletphysics.com/ #ifndef __spu__ notice that the vectors should be unit length #endif"
com.bulletphysics.collision.shapes.CylinderShape "cylindershape class implements a cylinder shape primitive, centered around the origin. its central axis aligned with the y axis. {@link cylindershapex} is aligned with the x axis and {@link cylindershapez} around the z axis. www.bulletphysics.com/ mapping depends on how cylinder local orientation is extents of the cylinder is: x,y is for radius, and z for height"
com.bulletphysics.collision.shapes.CylinderShapeX "cylinder shape around the x axis. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.CylinderShapeZ "cylinder shape around the z axis. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.IndexedMesh "indexedmesh indexes into existing vertex and index arrays, in a similar way to opengl's gldrawelements. instead of the number of indices, we pass the number of triangles. www.bulletphysics.com/ the index type is set when adding an indexed mesh to the triangleindexvertexarray, do not set it manually"
com.bulletphysics.collision.shapes.InternalTriangleIndexCallback "callback for internal processing of triangles. @see stridingmeshinterface#internalprocessalltriangles www.bulletphysics.com/"
com.bulletphysics.collision.shapes.MinkowskiSumShape "minkowskisumshape is only for advanced www.bulletphysics.com/ btvector3 supvertexa = m_transa(m_shapea->localgetsupportingvertexwithoutmargin(-vecm_transa.getbasis())); btvector3 supvertexb = m_transb(m_shapeb->localgetsupportingvertexwithoutmargin(vecm_transb.getbasis())); return supvertexa - supvertexb; todo: could make recursive use of batching. probably this shape is not used frequently."
com.bulletphysics.collision.shapes.NodeOverlapCallback "callback for operating with {@link optimizedbvh}. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.OptimizedBvh "optimizedbvh store an aabb tree that can be quickly traversed on cpu (and spu, gpu in future). [3] != 0 != 0 rootnode quick pruning by quantized box add box cast extents to bounding box add box cast extents otherwise fallback to aabb overlap test slow path: construct the bounding box for the entire box cast and send that down the tree www.bulletphysics.com/ java note: optimizedbvh still from 2.66, update it for 2.70b1 protected final bulletstack stack = bulletstack.get(); note: currently we have 16 bytes per quantized node 10 gives the potential for 1024 parts, with at most 2^21 (2097152) (minus one actually) triangles each (since the sign bit is reserved ////////////////////////////////////////////////////////////////////////// quantization data this is only used for serialization so we don't have to add serialization directly to btalignedobjectarray two versions, one for quantized and normal nodes. this allows code-reuse while maintaining readability (no template/macro!) this might be refactored into a virtual, it is usually not calculated at run-time non-quantized non-quantized enlarge the aabb to avoid division by zero when initializing the quantization values non-quantized java note: changing reference instead of copy with quantization? for child nodes protected final bulletstack stack = bulletstack.get(); for quantization the partid and triangle index must fit in the same (positive) integer negative indices are reserved for escapeindex pck: add these checks for zero dimensions of aabb nodearray trianglenodes; initialize quantization values now we have an array of leafnodes in m_leafnodes now we have an array of leafnodes in m_leafnodes todo: check contiguousnodes.resize(2numleafnodes); if the entire tree is small then subtree size, we need to create a header info for the tree pck: update the copy of the size pck: clear m_quantizedleafnodes and m_leafnodes, they are temporary calculate new aabb now update all subtree headers java note: added for testing, it's too slow for practical use // incrementally initialize quantization values assert (usequantization);  btassert(aabbmin.getx() > m_bvhaabbmin.getx()); btassert(aabbmin.gety() > m_bvhaabbmin.gety()); btassert(aabbmin.getz() > m_bvhaabbmin.getz());  btassert(aabbmax.getx() m_subtreeheaders.size();i++) { btbvhsubtreeinfo& subtree = m_subtreeheaders[i];  //pck: unsigned instead of bool unsigned overlap = testquantizedaabbagainstquantizedaabb(quantizedqueryaabbmin,quantizedqueryaabbmax,subtree.m_quantizedaabbmin,subtree.m_quantizedaabbmax); if (overlap != 0) { updatebvhnodes(meshinterface,subtree.m_rootnodeindex,subtree.m_rootnodeindex+subtree.m_subtreesize,i);  subtree.setaabbfromquantizenode(m_quantizedcontiguousnodes[subtree.m_rootnodeindex]); } } recalc aabb from triangle data triangles->getlockedreadonlyvertexindexbase(vertexbase,numverts, combine aabb from both children quantizedcontiguousnodes #ifdef debug_tree_building #endif //debug_tree_building #ifdef debug_tree_building #endif //debug_tree_building calculate best splitting axis and where to split it. sort the incoming 'leafnodes' array within range 'startindex/endindex'. internalnode->m_escapeindex; build left child tree build right child tree #ifdef debug_tree_building #endif //debug_tree_building escapeindex is the number of nodes of this subtree btquantizedbvhnode& leftchildnode = m_quantizedcontiguousnodes[leftchildnodexindex]; btquantizedbvhnode& rightchildnode = m_quantizedcontiguousnodes[rightchildnodexindex]; pck: update the copy of the size sort leafnodes so all values larger then splitvalue comes first, and smaller values start from 'splitindex'. vector3f center = new vector3f(); swap if the splitindex causes unbalanced trees, fix this by using the center in between startindex and endindex otherwise the tree-building might fail due to stack-overflows in certain cases. unbalanced1 is unsafe: it can cause stack overflows bool unbalanced1 = ((splitindex==startindex) || (splitindex == (endindex-1))); unbalanced2 should work too: always use center (perfect balanced trees) bool unbalanced2 = true; this should be safe too: diff2 = diff2 diff2; either choose recursive traversal (walktree) or stackless (walkstacklesstree) quantize query aabb java todo: case stackless_cache_friendly: walkstacklessquantizedtreecachefriendly(nodecallback, quantizedqueryaabbmin, quantizedqueryaabbmax); break; unsupported java note: rewritten contiguousnodes.get(0); pck: unsigned instead of bool unsigned aabboverlap; catch bugs in tree data pck: unsigned instead of bool pck: unsigned instead of bool process left and right children #define rayaabb2 #ifdef rayaabb2 boolean sign_x = raydirection.x m_quantizedaabbmin); aabbmax = unquantize(rootnode->m_quantizedaabbmax); btvector3 color(1,0,0); debugdrawerptr->drawaabb(aabbmin,aabbmax,color); } #endif//visually_analyze_bvh catch bugs in tree data only interested if this is closer than any previous hit #if 0 bool ra2 = btrayaabb2 (raysource, raydirection, sign, bounds, param, 0.0, lambda_max); bool ra = btrayaabb (raysource, raytarget, bounds[0], bounds[1], param, normal); if (ra2 != ra) { printf("functions don't match\n"); } #endif #ifdef rayaabb2 rayboxoverlap = aabbutil2.rayaabb2 (raysource, raydirection, sign, bounds, param, 0.0, lambda_max); #else #endif //#define visually_analyze_bvh 1 #ifdef visually_analyze_bvh //some code snippet to debugdraw aabb, to visually analyze bvh structure static int drawpatch = 0; //need some global access to a debugdrawer extern btidebugdraw debugdrawerptr; if (curindex==drawpatch) { btvector3 aabbmin,aabbmax; aabbmin = unquantize(rootnode->m_quantizedaabbmin); aabbmax = unquantize(rootnode->m_quantizedaabbmax); btvector3 color(1,0,0); debugdrawerptr->drawaabb(aabbmin,aabbmax,color); } #endif//visually_analyze_bvh catch bugs in tree data"
com.bulletphysics.collision.shapes.OptimizedBvhNode "optimizedbvhnode contains both internal and leaf node information. www.bulletphysics.com/ for child nodes"
com.bulletphysics.collision.shapes.package-info "collision shapes. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.PolyhedralConvexShape "polyhedralconvexshape is an internal interface class for polyhedral convex shapes. optional hull is for optional separating axis test hull collision detection, see hull.cpp www.bulletphysics.com/ / optional hull is for optional separating axis test hull collision detection, see hull.cpp / public hull optionalhull = null; java note: rewritten as code used w coord for temporary usage in vector3 todo: optimize it todo: used w in vector3: supportverticesout[i].w = -1e30f; if (newdot > supportverticesout[j].w) warning: don't swap next lines, the w component would get overwritten! supportverticesout[j].w = newdot; not yet, return box inertia lazy evaluation of local aabb #if 1 #else for (int i=0; i<3; i++) { vector3f vec = stack.alloc(vector3f.class); vec.set(0f, 0f, 0f); vectorutil.setcoord(vec, i, 1f); vector3f tmp = localgetsupportingvertex(vec, stack.alloc(vector3f.class)); vectorutil.setcoord(localaabbmax, i, vectorutil.getcoord(tmp, i) + collisionmargin); vectorutil.setcoord(vec, i, -1f); localgetsupportingvertex(vec, tmp); vectorutil.setcoord(localaabbmin, i, vectorutil.getcoord(tmp, i) - collisionmargin); } #endif public abstract int getindex(int i) const = 0 ;"
com.bulletphysics.collision.shapes.QuantizedBvhNodes "quantizedbvhnodes is array of compressed aabb nodes, each of 16 bytes. node can be used for leaf node or internal node. leaf nodes can point to 32-bit triangle index (non-negative range). implementation note: the nodes are internally stored in int[] array and bit packed. the actual structure is:  unsigned short quantizedaabbmin[3] unsigned short quantizedaabbmax[3] signed int escapeindexortriangleindex  www.bulletphysics.com/ 16 bytes save field access: save field access: skipindex is negative (internal node), triangleindex >=0 (leafnode) get only the lower bits where the triangle index is stored get only the highest bits where the part index is stored"
com.bulletphysics.collision.shapes.ScalarType "scalar type, used when accessing triangle mesh data. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.ScaledBvhTriangleMeshShape "the scaledbvhtrianglemeshshape allows to instance a scaled version of an existing {@link bvhtrianglemeshshape}. note that each {@link bvhtrianglemeshshape} still can have its own local scaling, independent from this scaledbvhtrianglemeshshape 'localscaling'. www.bulletphysics.com/ java note: scaledbvhtrianglemeshshape from 2.73 sp1 support negative scaling //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.shapes.ShapeHull "shapehull takes a {@link convexshape}, builds the convex hull using {@link hulllibrary} and provides triangle indices and vertices. www.bulletphysics.com/ #ifdef bt_use_double_precision hd.mvertices = &supportpoints[0]; hd.mvertexstride = sizeof(btvector3); #else hd.vertexstride = 3 4; #endif free temporary hull result that we just copied //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.collision.shapes.SphereShape "sphereshape implements an implicit sphere, centered around a local origin with radius. www.bulletphysics.com/ to improve gjk behaviour, use radius+margin as the full margin, so never get into the penetration case this means, non-uniform scaling is not supported anymore"
com.bulletphysics.collision.shapes.StaticPlaneShape "staticplaneshape simulates an infinite non-moving (static) collision plane. www.bulletphysics.com/ this is where the triangles are generated, given aabb and plane equation (normal/constant) tangentdir0/tangentdir1 can be precalculated moving concave objects not supported"
com.bulletphysics.collision.shapes.StridingMeshInterface "stridingmeshinterface is the abstract class for high performance access to triangle meshes. it allows for sharing graphics and collision meshes. also it provides locking/unlocking of graphics meshes that are in gpu memory. [3] get read and write access to a subpart of a triangle mesh. this subpart has a continuous array of vertices and indices. in this way the mesh can be handled as chunks of memory with striding very similar to opengl vertexarray support. make a call to unlockvertexbase when the read and write access is finished. =0 =0 unlockvertexbase finishes the access to a subpart of the triangle mesh. make a call to unlockvertexbase when the read and write access (using getlockedvertexindexbase) is finished. getnumsubparts returns the number of seperate subparts. each subpart has a continuous array of vertices and indices. www.bulletphysics.com/ first calculate the total aabb for all triangles"
com.bulletphysics.collision.shapes.TraversalMode "traversal mode for {@link optimizedbvh}. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.TriangleCallback "trianglecallback provides a callback for each overlapping triangle when calling processalltriangles. this callback is called by processalltriangles for all {@link concaveshape} derived classes, such as {@link bvhtrianglemeshshape}, {@link staticplaneshape} and {@link heightfieldterrainshape}. www.bulletphysics.com/"
com.bulletphysics.collision.shapes.TriangleIndexVertexArray "triangleindexvertexarray allows to use multiple meshes, by indexing into existing triangle/index arrays. additional meshes can be added using {@link #addindexedmesh addindexedmesh}. no duplicate is made of the vertex/index data, it only indexes into external vertex/index arrays. so keep those arrays around during the lifetime of this triangleindexvertexarray. just to be backwards compatible. unlockvertexbase finishes the access to a subpart of the triangle mesh. make a call to unlockvertexbase when the read and write access (using getlockedvertexindexbase) is finished. getnumsubparts returns the number of seperate subparts. each subpart has a continuous array of vertices and indices. www.bulletphysics.com/ #ifdef bt_use_double_precision type = phy_double; #else #endif"
com.bulletphysics.collision.shapes.TriangleMeshShape "concave triangle mesh abstract class. use {@link bvhtrianglemeshshape} as concrete implementation. trianglemeshshape constructor has been disabled/protected, so that www.bulletphysics.com/ java note: moved to bvhtrianglemeshshape recalclocalaabb(); moving concave objects not supported ////////////////////////////////////////////////////////////////////////// check aabb in triangle-space, before doing this"
com.bulletphysics.collision.shapes.TriangleShape "single triangle shape. [3] float www.bulletphysics.com/ java note: added java note: added btassert(0); distance to plane inside check on edge-planes"
com.bulletphysics.collision.shapes.UniformScalingShape "uniformscalingshape allows to re-use uniform scaled instances of {@link convexshape} in a memory efficient way. istead of using {@link uniformscalingshape}, it is better to use the non-uniform setlocalscaling method on convex shapes that implement it. www.bulletphysics.com/ this linear upscaling is not realistic, but we don't deal with large mass ratios..."
com.bulletphysics.collision.shapes.VertexData "allows accessing vertex data. www.bulletphysics.com/"
com.bulletphysics.ContactAddedCallback "called when contact has been www.bulletphysics.com/"
com.bulletphysics.ContactDestroyedCallback "called when contact has been destroyed between two collision objects. @see bulletglobals#setcontactdestroyedcallback www.bulletphysics.com/"
com.bulletphysics.ContactProcessedCallback "called when existing contact between two collision objects has been processed. @see bulletglobals#setcontactprocessedcallback www.bulletphysics.com/"
com.bulletphysics.demos.applet.Cylinder "cylinder.java constructor for cylinder. draws a cylinder oriented along the z axis. the base of the cylinder is placed at z = 0, and the top at z=height. like a sphere, a cylinder is subdivided around the z axis into slices, and along the z axis into stacks. note that if topradius is set to zero, then this routine will generate a cone. if the orientation is set to glu.outside (with glu.quadricorientation), then any generated normals point away from the z axis. otherwise, they point toward the z axis. if texturing is turned on (with glu.quadrictexture), then texture coordinates are generated so that t ranges linearly from 0.0 at z = 0 to 1.0 at z = height, and s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis. specifies the radius of the cylinder at z = 0. specifies the radius of the cylinder at z = height. specifies the height of the cylinder. specifies the number of subdivisions around the z axis. specifies the number of subdivisions along the z axis. gl11.glbegin(gl11.gl_points); for (i = 0; i < slices; i++) { x = cos((i da)); y = sin((i da)); normal3f(x nsign, y nsign, nz nsign); z = 0.0f; r = baseradius; for (j = 0; j <= stacks; j++) { gl11.glvertex3f((x r), (y r), z); z += dz; r += dr; } } gl11.glend(); // draw rings if (super.drawstyle == glu_line) { z = 0.0f; r = baseradius; for (j = 0; j <= stacks; j++) { gl11.glbegin(gl11.gl_line_loop); for (i = 0; i < slices; i++) { x = cos((i da)); y = sin((i da)); normal3f(x nsign, y nsign, nz nsign); gl11.glvertex3f((x r), (y r), z); } gl11.glend(); z += dz; r += dr; } } else { // draw one ring at each end if (baseradius != 0.0) { gl11.glbegin(gl11.gl_line_loop); for (i = 0; i < slices; i++) { x = cos((i da)); y = sin((i da)); normal3f(x nsign, y nsign, nz nsign); gl11.glvertex3f((x baseradius), (y baseradius), 0.0f); } gl11.glend(); gl11.glbegin(gl11.gl_line_loop); for (i = 0; i < slices; i++) { x = cos((i da)); y = sin((i da)); normal3f(x nsign, y nsign, nz nsign); gl11.glvertex3f((x topradius), (y topradius), height); } gl11.glend(); } } // draw length lines gl11.glbegin(gl11.gl_lines); for (i = 0; i < slices; i++) { x = cos((i da)); y = sin((i da)); normal3f(x nsign, y nsign, nz nsign); gl11.glvertex3f((x baseradius), (y baseradius), 0.0f); gl11.glvertex3f((x topradius), (y topradius), (height)); } gl11.glend(); z component of normal vectors draw rings draw one ring at each end draw length lines for slices for stacks"
com.bulletphysics.demos.applet.DemoPanel "img.getheight() - 1 - img.getheight() - 1 - img.getheight() - 1 -"
com.bulletphysics.demos.applet.Disk "disk.java constructor for disk. renders a disk on the z = 0 plane. the disk has a radius of outerradius, and contains a concentric circular hole with a radius of innerradius. if innerradius is 0, then no hole is generated. the disk is subdivided around the z axis into slices (like pizza slices), and also about the z axis into rings (as specified by slices and loops, respectively). with respect to orientation, the +z side of the disk is considered to be "outside" (see glu.quadricorientation). this means that if the orientation is set to glu.outside, then any normals generated point along the +z axis. otherwise, they point along the -z axis. if texturing is turned on (with glu.quadrictexture), texture coordinates are generated linearly such that where r=outerradius, the value at (r, 0, 0) is (1, 0.5), at (0, r, 0) it is (0.5, 1), at (-r, 0, 0) it is (0, 0.5), and at (0, -r, 0) it is (0.5, 0). normal vectors texture of a gludisk is a cut out of the texture unit square x, y in [-outerradius, +outerradius]; s, t in [0, 1] (linear mapping) draw loops draw spokes int l, s; / draw loops / for (l = 0; l <= loops; l++) { float r = innerradius + l dr; gl11.glbegin(gl11.gl_line_loop); for (s = 0; s < slices; s++) { float a = s da; gl11.glvertex2f(r sin(a), r cos(a)); } gl11.glend(); } / draw spokes / for (s = 0; s < slices; s++) { float a = s da; float x = sin(a); float y = cos(a); gl11.glbegin(gl11.gl_line_strip); for (l = 0; l <= loops; l++) { float r = innerradius + l dr; gl11.glvertex2f(r x, r y); } gl11.glend(); } int s; gl11.glbegin(gl11.gl_points); for (s = 0; s < slices; s++) { float a = s da; float x = sin(a); float y = cos(a); int l; for (l = 0; l <= loops; l++) { float r = innerradius l dr; gl11.glvertex2f(r x, r y); } } gl11.glend(); if (innerradius != 0.0) { float a; gl11.glbegin(gl11.gl_line_loop); for (a = 0.0f; a < 2.0 glu.pi; a += da) { float x = innerradius sin(a); float y = innerradius cos(a); gl11.glvertex2f(x, y); } gl11.glend(); } { float a; gl11.glbegin(gl11.gl_line_loop); for (a = 0; a < 2.0f glu.pi; a += da) { float x = outerradius sin(a); float y = outerradius cos(a); gl11.glvertex2f(x, y); } gl11.glend(); }"
com.bulletphysics.demos.applet.Graphics3D "software opengl-like 3d renderer (c) 2008 martin dvorak  this software is provided 'as-is', without any express or implied warranty. in no event will the  //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.demos.applet.JBulletApplet "initializes the applet jbulletapplet this method is called from within the init() method to initialize the form. warning: do not modify this code. the content of this method is always regenerated by the form editor. ignored rundemo((demoentry)e.getitem()); //gen-begin:initcomponents //gen-end:initcomponents frm.setsize(512, 384+50); variables declaration - do not modify//gen-begin:variables end of variables declaration//gen-end:variables"
com.bulletphysics.demos.applet.Light "software opengl-like 3d renderer (c) 2008 martin dvorak  this software is provided 'as-is', without any express or implied warranty. in no event will the"
com.bulletphysics.demos.applet.LookUtil ""
com.bulletphysics.demos.applet.Quadric "quadric.java constructor for quadric. call glnormal3f after scaling normal to unit length. specifies the draw style for quadrics. the legal values are as follows: glu.fill: quadrics are rendered with polygon primitives. the polygons are drawn in a counterclockwise fashion with respect to their normals (as defined with glu.quadricorientation). glu.line: quadrics are rendered as a set of lines. glu.silhouette: quadrics are rendered as a set of lines, except that edges separating coplanar faces will not be drawn. glu.point: quadrics are rendered as a set of points. the drawstyle to set specifies what kind of normals are desired for quadrics. the legal values are as follows: glu.none: no normals are generated. glu.flat: one normal is generated for every facet of a quadric. glu.smooth: one normal is generated for every vertex of a quadric. this is the default. the normals to set specifies what kind of orientation is desired for. the orientation values are as follows: glu.outside: quadrics are drawn with normals pointing outward. glu.inside: normals point inward. the default is glu.outside. note that the interpretation of outward and inward depends on the quadric being drawn. the orientation to set specifies if texture coordinates should be generated for quadrics rendered with qobj. if the value of texturecoords is true, then texture coordinates are generated, and if texturecoords is false, they are not.. the default is false. the manner in which texture coordinates are generated depends upon the specific quadric rendered. the textureflag to set returns the drawstyle. returns the normals. returns the orientation. returns the textureflag. if (textureflag) gl11.gltexcoord2f(x,y);"
com.bulletphysics.demos.applet.Rasterizer "software opengl-like 3d renderer (c) 2008 martin dvorak  this software is provided 'as-is', without any express or implied warranty. in no event will the  if ((outcode & edge_bottom) != 0) http://cs.unc.edu/~mcmillan/comp136/lecture6/lines.html dy is now 2dy dx is now 2dx same as 2dy - dx same as fraction -= 2dx same as fraction -= 2dy"
com.bulletphysics.demos.applet.SoftwareGL "glrotatef(-90f, 0.0f, 1.0f, 0.0f); glrotatef(-90.0f, 1.0f, 0.0f, 0.0f); the glucylinder subroutine draws a cylinder that is oriented along the z axis. the base of the cylinder is placed at z = 0; the top of the cylinder is placed at z=height. like a sphere, the cylinder is subdivided around the z axis into slices and along the z axis into stacks."
com.bulletphysics.demos.applet.Span "software opengl-like 3d renderer (c) 2008 martin dvorak  this software is provided 'as-is', without any express or implied warranty. in no event will the"
com.bulletphysics.demos.applet.Sphere "sphere.java constructor draws a sphere of the given radius centered around the origin. the sphere is subdivided around the z axis into slices and along the z axis into stacks (similar to lines of longitude and latitude). if the orientation is set to glu.outside (with glu.quadricorientation), then any normals generated point away from the center of the sphere. otherwise, they point toward the center of the sphere. if texturing is turned on (with glu.quadrictexture), then texture coordinates are generated so that t ranges from 0.0 at z=-radius to 1.0 at z=radius (t increases linearly along longitudinal lines), and s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis. else if ( super.drawstyle == glu_line || super.drawstyle == glu_silhouette) { // draw stack lines for (i = 1; i < stacks; i++) { // stack line at i==stacks-1 was missing here rho = i drho; gl11.glbegin(gl11.gl_line_loop); for (j = 0; j < slices; j++) { theta = j dtheta; x = cos(theta) sin(rho); y = sin(theta) sin(rho); z = cos(rho); if (normals) gl11.glnormal3f(x nsign, y nsign, z nsign); gl11.glvertex3f(x radius, y radius, z radius); } gl11.glend(); } // draw slice lines for (j = 0; j < slices; j++) { theta = j dtheta; gl11.glbegin(gl11.gl_line_strip); for (i = 0; i <= stacks; i++) { rho = i drho; x = cos(theta) sin(rho); y = sin(theta) sin(rho); z = cos(rho); if (normals) gl11.glnormal3f(x nsign, y nsign, z nsign); gl11.glvertex3f(x radius, y radius, z radius); } gl11.glend(); } } else if (super.drawstyle == glu.glu_point) { // top and bottom-most points gl11.glbegin(gl11.gl_points); if (normals) gl11.glnormal3f(0.0f, 0.0f, nsign); gl11.glvertex3f(0.0f, 0.0f, radius); if (normals) gl11.glnormal3f(0.0f, 0.0f, -nsign); gl11.glvertex3f(0.0f, 0.0f, -radius); // loop over stacks for (i = 1; i < stacks - 1; i++) { rho = i drho; for (j = 0; j < slices; j++) { theta = j dtheta; x = cos(theta) sin(rho); y = sin(theta) sin(rho); z = cos(rho); if (normals) gl11.glnormal3f(x nsign, y nsign, z nsign); gl11.glvertex3f(x radius, y radius, z radius); } } gl11.glend(); } todo draw +z end as a triangle fan because loop now runs from 0 draw intermediate stacks as quad strips draw -z end as a triangle fan draw stack lines stack line at i==stacks-1 was missing here draw slice lines top and bottom-most points loop over stacks"
com.bulletphysics.demos.applet.Utils "marked methods are from lwjgl library with following license: copyright (c) 2002-2004 lwjgl project all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of 'lwjgl' nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided by the copyright holders and contributors "as is" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. in no event shall the copyright owner or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.  side = forward x up recompute up as: up = side x forward translate and scale the picked region to the entire window from lwjgl: from lwjgl: from lwjgl: from lwjgl: from lwjgl: map x, y and z to range 0-1 map x,y to viewport from lwjgl: map x and y from window coordinates map to range -1 to 1"
com.bulletphysics.demos.basic.BasicDemo "basicdemo is good starting point for learning the code base and porting. www.bulletphysics.com/ create 125 (5x5x5) dynamic object maximum number of objects (and allow keep the collision shapes, for deletion/cleanup simple dynamics world doesn't handle fixed-time-stepping step the simulation optional but useful: debug drawing glflush(); glutswapbuffers(); optional but useful: debug drawing to detect problems glflush(); glutswapbuffers(); collision configuration contains default setup for memory, collision setup use the default collision dispatcher. for parallel processing you can use a diffent dispatcher (see extras/bulletmultithreaded) the default constraint solver. for parallel processing you can use a different solver (see extras/bulletmultithreaded) todo: needed for simpledynamicsworld sol.setsolvermode(sol.getsolvermode() & ~solvermode.solver_cache_friendly.getmask()); create a few basic rigid bodies collisionshape groundshape = new staticplaneshape(new vector3f(0, 1, 0), 50); we can also use demoapplication::localcreaterigidbody, but for clarity it is provided here: rigidbody is dynamic if and only if mass is non zero, otherwise static using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects add the body to the dynamics world create a few dynamic rigidbodies re-using the same collision is better for memory usage and performance collisionshape colshape = new sphereshape(1f); create dynamic objects rigidbody is dynamic if and only if mass is non zero, otherwise static using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects bullet.sf.net", ccddemo);"
com.bulletphysics.demos.bsp.BspConverter "www.bulletphysics.com/"
com.bulletphysics.demos.bsp.BspDemo "bspdemo shows the convex collision detection, by converting a quake bsp file into convex objects and allowing interaction with boxes. www.bulletphysics.com/ keep the collision shapes, for deletion/cleanup setup a physics simulation environment btcollisionshape groundshape = new btboxshape(btvector3(50,3,50)); broadphase = new axissweep3(worldmin, worldmax); broadphase = new simplebroadphase(); btoverlappingpaircache broadphase = new btsimplebroadphase(); constraintsolver solver = new odeconstraintsolver; optional but useful: debug drawing glflush(); glutswapbuffers(); glflush(); glutswapbuffers(); bullet.sf.net", demo); ////////////////////////////////////////////////////////////////////////// can use a shift this create an internal copy of the vertices btrigidbody body = m_demoapp->localcreaterigidbody(mass, starttransform,shape);"
com.bulletphysics.demos.character.CharacterDemo "www.bulletphysics.com/ java note: the original demo scaled the bsp room, we scale up the character keep the collision shapes, for deletion/cleanup during idle mode, just run 1 simulation step maximum set walkdirection for our character printf("forwarddir=%f,%f,%f\n",forwarddir[0],forwarddir[1],forwarddir[2]); 4 km/h -> 1.1 m/s optional but useful: debug drawing glflush(); glutswapbuffers(); glflush(); glutswapbuffers(); /wtf if (usedefaultcamera) { look at the vehicle update opengl camera settings bullet.sf.net", demo); ////////////////////////////////////////////////////////////////////////// can use a shift java note: port change, we want y to be up. starttransform.origin.set(0, 0, -10f); this create an internal copy of the vertices btrigidbody body = m_demoapp->localcreaterigidbody(mass, starttransform,shape);"
com.bulletphysics.demos.concave.ConcaveDemo "www.bulletphysics.com/ java todo: update for 2.70b1 enable to test serialization of bvh to speedup loading: set to false to read the bvh from disk (first run the demo once to create the bvh): keep the collision shapes, for deletion/cleanup 0.f, #define use_trimesh_shape 1 #ifdef use_trimesh_shape int index=0; we can serialize the bvh data #else btcollisionshape groundshape = new btboxshape(btvector3(50,3,50)); m_collisionshapes.push_back(groundshape); #endif //use_trimesh_shape //#ifdef use_parallel_dispatcher #ifdef use_win32_threading  int maxnumoutstandingtasks = 4;//number of maximum outstanding tasks win32threadsupport threadsupport = new win32threadsupport(win32threadsupport::win32threadconstructioninfo( "collision", processcollisiontask, createcollisionlocalstorememory, maxnumoutstandingtasks)); #else ///todo other platform threading ///playstation 3 spu (spurs) version is available through ps3 devnet ///libspe2 spu support will be available soon ///pthreads version ///you can hook it up to your custom task scheduler by deriving from btthreadsupportinterface #endif  m_dispatcher = new spugatheringcollisiondispatcher(threadsupport,maxnumoutstandingtasks,m_collisionconfiguration); #else #endif//use_parallel_dispatcher broadphase = new axissweep3(worldmin, worldmax); broadphase = new simplebroadphase(); #ifdef use_parallel_dispatcher m_dynamicsworld->getdispatchinfo().m_enablespu=true; #endif //use_parallel_dispatcher java note: added btcollisionshape colshape = new btcapsuleshape(0.5,2.0);//boxshape = new btsphereshape(1.f); enable custom material callback java note: 2.70b1: replace with proper code clear all contact points involving mesh proxy. note: this is a slow/unoptimized operation. optional but useful: debug drawing glflush(); glutswapbuffers(); optional but useful: debug drawing glflush(); glutswapbuffers(); partid0,index0 partid1,index1 this return value is currently ignored, but to be on the safe side: return false if you don't calculate friction"
com.bulletphysics.demos.concaveconvexcast.ConcaveConvexcastDemo "www.bulletphysics.com/ keep the collision shapes, for deletion/cleanup 0.f, #define use_trimesh_shape 1 #ifdef use_trimesh_shape int index=0; comment out the next line to read the bvh from disk (first run the demo once to create the bvh) #define serialize_to_disk 1 #ifdef serialize_to_disk broadphase = new axissweep3(worldmin, worldmax); java note: added btcollisionshape colshape = new btcapsuleshape(0.5,2.0);//boxshape = new btsphereshape(1.f); enable custom material callback java note: 2.70b1: replace with proper code clear all contact points involving mesh proxy. note: this is a slow/unoptimized operation. optional but useful: debug drawing glflush(); glutswapbuffers(); optional but useful: debug drawing glflush(); glutswapbuffers();"
com.bulletphysics.demos.concaveconvexcast.ConvexcastBatch "scrolls back and forth over terrain. www.bulletphysics.com/ #ifdef use_bt_clock #endif //use_bt_clock rotate around by alpha degrees y direction[i].set(direction[i]); #ifdef use_bt_clock #endif //use_bt_clock #ifdef use_bt_clock #endif //use_bt_clock gl.glbegin(gl_lines); easier to see if this is big"
com.bulletphysics.demos.dynamiccontrol.DynamicControlDemo "www.bulletphysics.com/ in milliseconds setup the basic world in milliseconds broadphaseinterface overlappingpaircache = new axissweep3(worldaabbmin, worldaabbmax); broadphaseinterface overlappingpaircache = new simplebroadphase(); setup a big ground box todo m_collisionshapes.push_back(groundshape); spawn one testrig simple dynamics world doesn't handle fixed-time-stepping  set per-frame sinusoidal position targets using angular motor (hacky?)  optional but useful: debug drawing glflush(); glutswapbuffers(); glflush(); glutswapbuffers(); x y z bullet.sf.net", demoapp);"
com.bulletphysics.demos.dynamiccontrol.TestRig "www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get();  setup geometry   setup rigid bodies  root legs thigh shin setup some damping on the bodies  setup the constraints  conetwistconstraint conec; hip joints hingec.setlimit(-0.1f, 0.1f); knee joints hingec.setlimit(-0.01f, 0.01f); remove all constraints joints[i].destroy(); remove all bodies and shapes bodies[i].getmotionstate().destroy(); shapes[i].destroy();"
com.bulletphysics.demos.forklift.ForkLiftDemo ",worldboundsmin,worldboundsmax www.bulletphysics.com/ by default, bullet vehicle uses y as up axis. you can override the up axis, for example z-axis up. enable this define to see how to: //#define force_zaxis_up 1 #ifdef force_zaxis_up private int rightindex = 0; private int upindex = 2; private int forwardindex = 1; private btvector3 wheeldirectioncs0(0,0,-1); private btvector3 wheelaxlecs(1,0,0); #else #endif raycastvehicle is the interface for the constraint that implements the raycast vehicle notice that for higher-quality slow-moving vehicles, another approach might be better implementing explicit hinged-wheel constraints with cylinder collision, rather then raycasts this should be engine/velocity dependent 1e30f; 1.0f; ////////////////////////////////////////////////////////////////////////// ---------------------------- ---------------------------- during idle mode, just run 1 simulation step maximum #define verbose_feedback #ifdef verbose_feedback if (!numsimsteps) printf("interpolated transforms\n"); else { if (numsimsteps > maxsimsubsteps) { //detect dropping frames printf("dropped (%i) simulation steps out of %i\n",numsimsteps - maxsimsubsteps,numsimsteps); } else { printf("simulated (%i) steps\n",numsimsteps); } } #endif //verbose_feedback #ifdef use_quickprof btprofiler::beginblock("render"); #endif //use_quickprof optional but useful: debug drawing #ifdef use_quickprof btprofiler::endblock("render"); #endif synchronize the wheels with the (interpolated) chassis worldtransform optional but useful: debug drawing /a very basic camera following the vehicle //#define disable_camera 1 #ifdef disable_camera demoapplication::updatecamera(); return; #endif //disable_camera look at the vehicle interpolate the camera height #ifdef force_zaxis_up m_cameraposition[2] = (15.0m_cameraposition[2] + m_cameratargetposition[2] + m_cameraheight)/16.0; #else #endif keep distance between min and max distance update opengl camera settings glutpostredisplay(); float[] m = new float[16]; int i; synchronize the wheels with the (interpolated) chassis worldtransform draw wheels (cylinders) #ifdef force_zaxis_up cameraup.set(0,0,1); forwardaxis = 1; #endif overlappingpaircache = new axissweep3(worldmin,worldmax); #ifdef force_zaxis_up m_dynamicsworld->setgravity(btvector3(0,0,-10)); #endif m_dynamicsworld->setgravity(btvector3(0,0,0)); either use heightfield or triangle mesh #define use_trimesh_ground 1 #ifdef use_trimesh_ground create a triangle-mesh ground height set to zero, but can also use curved landscape, just uncomment out the code 20.fsinf(float(i)wl)cosf(float(j)wl); #ifdef force_zaxis_up m_vertices[i+jnum_verts_x].setvalue( (i-num_verts_x0.5f)triangle_size, (j-num_verts_y0.5f)triangle_size, height ); #else #endif int index=0; #else //testing btheightfieldterrainshape int width=128; int length=128; unsigned char heightfielddata = new unsigned char[widthlength]; { for (int i=0;isetusediamondsubdivision(true);  btvector3 localscaling(20,20,20); localscaling[upindex]=1.f; groundshape->setlocalscaling(localscaling);  tr.setorigin(btvector3(0,-64.5f,0));  #endif // create ground object #ifdef force_zaxis_up // indexrightaxis = 0; // indexupaxis = 2; // indexforwardaxis = 1; btcollisionshape chassisshape = new btboxshape(btvector3(1.f,2.f, 0.5f)); btcompoundshape compound = new btcompoundshape(); bttransform localtrans; localtrans.setidentity(); //localtrans effectively shifts the center of mass with respect to the chassis localtrans.setorigin(btvector3(0,0,1)); #else localtrans effectively shifts the center of mass with respect to the chassis #endif localtrans effectively shifts the center of mass with respect to the chassis chassisshape); m_carchassis->setdamping(0.2,0.2); create vehicle never deactivate the vehicle choose coordinate system #ifdef force_zaxis_up btvector3 connectionpointcs0(cube_half_extents-(0.3wheelwidth),2cube_half_extents-wheelradius, connectionheight); #else #endif #ifdef force_zaxis_up connectionpointcs0 = btvector3(-cube_half_extents+(0.3wheelwidth),2cube_half_extents-wheelradius, connectionheight); #else #endif #ifdef force_zaxis_up connectionpointcs0 = btvector3(-cube_half_extents+(0.3wheelwidth),-2cube_half_extents+wheelradius, connectionheight); #else #endif //force_zaxis_up #ifdef force_zaxis_up connectionpointcs0 = btvector3(cube_half_extents-(0.3wheelwidth),-2cube_half_extents+wheelradius, connectionheight); #else #endif"
com.bulletphysics.demos.genericjoint.GenericJointDemo "setup the basic world broadphaseinterface overlappingpaircache = new axissweep3(worldaabbmin, worldaabbmax); broadphaseinterface overlappingpaircache = new simplebroadphase(); #ifdef use_ode_quickstep btconstraintsolver constraintsolver = new odeconstraintsolver(); #else #endif setup a big ground box spawn one ragdoll simple dynamics world doesn't handle fixed-time-stepping optional but useful: debug drawing glflush(); glutswapbuffers(); glflush(); glutswapbuffers();"
com.bulletphysics.demos.genericjoint.RagDoll "protected final bulletstack stack = bulletstack.get(); setup the geometry setup all the rigid bodies setup some damping on the m_bodies /////////////////////////// setting the constraints /////////////////////////////////////////////7777 now setup the constraints / spine head /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / left shoulder /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / right shoulder /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / left elbow /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / right elbow /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / pelvis /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / left hip /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / right hip /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / left knee ///  #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// / right knee /// #ifdef rigid joint6dof->setangularlowerlimit(btvector3(-simd_epsilon,-simd_epsilon,-simd_epsilon)); joint6dof->setangularupperlimit(btvector3(simd_epsilon,simd_epsilon,simd_epsilon)); #else #endif / /// remove all constraints joints[i].destroy(); remove all bodies and shapes bodies[i].getmotionstate().destroy(); shapes[i].destroy();"
com.bulletphysics.demos.helloworld.HelloWorld "this is a hello world program for running a basic bullet physics simulation. it is a direct translation of the c++ helloworld app. www.bulletphysics.com/ collision configuration contains default setup for memory, collision setup. advanced use the default collision dispatcher. for parallel processing you can use a diffent dispatcher (see extras/bulletmultithreaded) the maximum size of the collision world. make sure objects stay within these boundaries don't make the world aabb size too large, it will harm simulation quality and performance broadphaseinterface overlappingpaircache = new simplebroadphase( maxproxies); the default constraint solver. for parallel processing you can use a different solver (see extras/bulletmultithreaded) create a few basic rigid bodies keep track of the shapes, we release memory at exit. make sure to re-use collision shapes among rigid bodies whenever possible! rigidbody is dynamic if and only if mass is non zero, otherwise static using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects add the body to the dynamics world create a dynamic rigidbody btcollisionshape colshape = new btboxshape(btvector3(1,1,1)); create dynamic objects rigidbody is dynamic if and only if mass is non zero, otherwise static using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects do some simulation print positions of all objects"
com.bulletphysics.demos.movingconcave.Bunny "www.bulletphysics.com/ //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.demos.movingconcave.MovingConcaveDemo "www.bulletphysics.com/ simple dynamics world doesn't handle fixed-time-stepping step the simulation optional but useful: debug drawing glflush(); glutswapbuffers(); optional but useful: debug drawing to detect problems glflush(); glutswapbuffers(); create trimesh register algorithm collision configuration contains default setup for memory, collision setup use the default collision dispatcher. for parallel processing you can use a diffent dispatcher (see extras/bulletmultithreaded) the default constraint solver. for parallel processing you can use a different solver (see extras/bulletmultithreaded) todo: needed for simpledynamicsworld sol.setsolvermode(sol.getsolvermode() & ~solvermode.solver_cache_friendly.getmask()); dynamicsworld = new simpledynamicsworld(dispatcher, overlappingpaircache, solver, collisionconfiguration); floor left wall right wall front wall back wall static scenario enable custom material callback staticbody.setcollisionflags(staticbody.getcollisionflags() | collisionflags.custom_material_callback); static plane a plane"
com.bulletphysics.demos.opengl.DemoApplication "light_position is not default value todo: check page_up todo: checkpage_down //quickly search some issue at a certain simulation frame, pressing space to reset int fixed=18; for (int i=0;istepsimulation(1./60.f,1); } www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); 1 rigidbody has 1 shape (no re-use of shapes) for deactivation state todo: class cprofileiterator m_profileiterator; java note: added this is the most important class constraint for mouse picking look at todo: cprofilemanager::release_iterator(m_profileiterator); if (m_shootboxshape) delete m_shootboxshape; glenable(gl_cull_face); glcullface(gl_back); rads per deg rads per deg case ' ' : newrandom(); break; std::cout getmotionstate(); delete obj; std::cout setworldtransform(starttransform); #endif// see http://www.lighthouse3d.com/opengl/glut/index.php?bmpfontortho switch to projection mode save previous matrix which contains the settings for the perspective projection reset matrix set a 2d orthographic projection invert the y axis, down is positive mover the origin from the bottom left corner to the upper left corner recompute profiling data, and store profile strings wants deactivation color differently for active, sleeping, wantsdeactivation states active wirecolor.add(new vector3f(1f, 0f, 0f)); wirecolor.add(new vector3f(0.5f, 0f, 0f)); island_sleeping wirecolor.add(new vector3f(0f, 1f, 0f)); wirecolor.add(new vector3f(0f, 0.5f, 0f)); #ifdef use_quickprof if ( getdebugmode() & btidebugdraw::dbg_profiletimings) { static int counter = 0; counter++; std::map::iterator iter; for (iter = btprofiler::mprofileblocks.begin(); iter != btprofiler::mprofileblocks.end(); ++iter) { char blocktime[128]; sprintf(blocktime, "%s: %lf",&((iter).first[0]),btprofiler::getblocktime((iter).first, btprofiler::block_cycle_seconds));//block_total_percent)); glrasterpos3f(xoffset,ystart,0); bmf_drawstring(bmf_getfont(bmf_khelvetica10),blocktime); ystart += yincr;  } } #endif //use_quickprof java note: added not yet hooked up again after refactoring... java note: added buf = "p to toggle profiling (+results to file)"; drawstring(buf, math.round(xoffset), math.round(ystart), text_color); bool usebulletlcp = !(getdebugmode() & btidebugdraw::dbg_disablebulletlcp); bool useccd = (getdebugmode() & btidebugdraw::dbg_enableccd); glrasterpos3f(xoffset,ystart,0); sprintf(buf,"1 ccd mode (adhoc) = %i",useccd); bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); ystart += yincr; glrasterpos3f(xoffset, ystart, 0); buf = string.format(%10.2f", shootboxinitialspeed); #ifdef show_num_deep_penetrations buf = string.format("gnumalignedallocs = %d", bulletglobals.gnumalignedallocs); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); ystart += yincr; buf = string.format("gnumalignedfree= %d", bulletglobals.gnumalignedfree); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); ystart += yincr; buf = string.format("# alloc-free = %d", bulletglobals.gnumalignedallocs - bulletglobals.gnumalignedfree); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); ystart += yincr; enable bt_debug_memory_allocations define in bullet/src/linearmath/btalignedallocator.h for memory leak detection #ifdef bt_debug_memory_allocations glrasterpos3f(xoffset,ystart,0); sprintf(buf,"gtotalbytesalignedallocs = %d",gtotalbytesalignedallocs); bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); ystart += yincr; #endif //bt_debug_memory_allocations #endif //show_num_deep_penetrations java note: added #ifdef show_num_deep_penetrations #endif //show_num_deep_penetrations removed cached contact points quickly search some issue at a certain simulation frame, pressing space to reset #ifdef use_bt_clock #else return btscalar(16666.); #endif"
com.bulletphysics.demos.opengl.FastFormat "www.bulletphysics.com/"
com.bulletphysics.demos.opengl.FontRender "file f = new file(cachedir, getfontfilename(family, size, bold)); if (f.exists()) { gf.load(f); return gf; } www.bulletphysics.com/ private static final file cachedir = new file("/path/to/font/cache/dir/"); gf.save(f); bufferedimage img = new bufferedimage(imgw, 1024, bufferedimage.type_int_argb); glcolor4f(1, 1, 1, 1); x += g.w; gltranslatef(g.w, 0, 0); glteximage2d(gl_texture_2d, 0, alpha? gl_rgba:gl_rgb, img.getwidth(), img.getheight(), 0, alpha? gl_rgba:gl_rgb, gl_unsigned_byte, buf); glubuild2dmipmaps(gl_texture_2d, gl_compressed_rgb, img.getwidth(), img.getheight(), gl_rgb, gl_unsigned_byte, buf);"
com.bulletphysics.demos.opengl.GLDebugDrawer "www.bulletphysics.com/ java note: added glrasterpos3f(location.x, location.y, location.z); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),textstring); java note: added java note: added glrasterpos3f(from.x, from.y, from.z); char buf[12]; sprintf(buf," %d",lifetime); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf);"
com.bulletphysics.demos.opengl.GLShapeDrawer "private static map g_display_lists = new hashmap(); private static int ogl_get_displaylist_for_shape(collisionshape shape) { // java note: rewritten trimeshkey trimesh = g_display_lists.get(shape); if (trimesh != null) { return trimesh.dlist; } return 0; } private static void ogl_displaylist_clean() { // java note: rewritten for (trimeshkey trimesh : g_display_lists.values()) { gldeletelists(trimesh.dlist, 1); } g_display_lists.clear(); } glpointsize(10f); glbegin(gl_points); glvertex3f(0f, 0f, 0f); glend(); glpointsize(1f); glbegin(gl_lines); glcolor3f(1, 1, 0); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[0].getx(), triangle[0].gety(), triangle[0].getz()); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[1].getx(), triangle[1].gety(), triangle[1].getz()); glcolor3f(1, 1, 0); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[2].getx(), triangle[2].gety(), triangle[2].getz()); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[1].getx(), triangle[1].gety(), triangle[1].getz()); glcolor3f(1, 1, 0); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[2].getx(), triangle[2].gety(), triangle[2].getz()); glnormal3d(normal.getx(),normal.gety(),normal.getz()); glvertex3d(triangle[0].getx(), triangle[0].gety(), triangle[0].getz()); glend(); www.bulletphysics.com/ import static org.lwjgl.opengl.gl11.; import static org.lwjgl.opengl.glu.glu.; java note: rewritten java note: rewritten system.out.println("shape="+shape+" type="+broadphasenativetypes.forvalue(shape.getshapetype())); if (shape.getshapetype() == broadphasenativetypes.uniform_scaling_shape_proxytype.getvalue()) { const btuniformscalingshape scalingshape = static_cast(shape); const btconvexshape convexshape = scalingshape->getchildshape(); float scalingfactor = (float)scalingshape->getuniformscalingfactor(); { btscalar tmpscaling[4][4]={{scalingfactor,0,0,0}, {0,scalingfactor,0,0}, {0,0,scalingfactor,0}, {0,0,0,1}};  drawopengl( (btscalar)tmpscaling,convexshape,color,debugmode); } glpopmatrix(); return; } drawcoordsystem(); glpushmatrix(); you can comment out any of the specific cases, and use the default the benefit of 'default' is that it approximates the actual collision shape including collision margin radius doesn't include the margin, so draw with margin todo: glutsolidsphere(radius,10,10); sphere.draw(radius, 8, 8); case cone_shape_proxytype: { const btconeshape coneshape = static_cast(shape); int upindex = coneshape->getconeupindex(); float radius = coneshape->getradius();//+coneshape->getmargin(); float height = coneshape->getheight();//+coneshape->getmargin(); switch (upindex) { case 0: glrotatef(90.0, 0.0, 1.0, 0.0); break; case 1: glrotatef(-90.0, 1.0, 0.0, 0.0); break; case 2: break; default: { } };  gltranslatef(0.0, 0.0, -0.5height); glutsolidcone(radius,height,10,10); usewireframefallback = false; break;  } create a hull approximation java note: not needed /// cleanup memory m_shapehulls.push_back(hull); printf("numtriangles = %d\n", hull->numtriangles ()); printf("numindices = %d\n", hull->numindices ()); printf("numvertices = %d\n", hull->numvertices ()); glutsolidcube(1.0); printf("unhandled drawing\n"); for polyhedral shapes if (debugmode==btidebugdraw::dbg_drawfeaturestext) { glrasterpos3f(0.0, 0.0, 0.0); //bmf_drawstring(bmf_getfont(bmf_khelvetica10),polyshape->getextradebuginfo());  glcolor3f(1.f, 1.f, 1.f); for (i=0;igetnumvertices();i++) { btpoint3 vtx; polyshape->getvertex(i,vtx); glrasterpos3f(vtx.x(), vtx.y(), vtx.z()); char buf[12]; sprintf(buf," %d",i); bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf); }  for (i=0;igetnumplanes();i++) { btvector3 normal; btpoint3 vtx; polyshape->getplane(normal,vtx,i); btscalar d = vtx.dot(normal);  glrasterpos3f(normal.x()d, normal.y()d, normal.z()d); char buf[12]; sprintf(buf," plane %d",i); bmf_drawstring(bmf_getfont(bmf_khelvetica10),buf);  } } #ifdef use_display_lists  if (shape->getshapetype() == triangle_mesh_shape_proxytype||shape->getshapetype() == gimpact_shape_proxytype) { gluint dlist = ogl_get_displaylist_for_shape((btcollisionshape )shape); if (dlist) { glcalllist(dlist); } else { #else >getshapetype() == triangle_mesh_shape_proxytype||shape->getshapetype() == gimpact_shape_proxytype) if (shape->getshapetype() == triangle_mesh_shape_proxytype) btvector3 aabbmax(btscalar(1e30),btscalar(1e30),btscalar(1e30)); btvector3 aabbmax(100,100,100);//btscalar(1e30),btscalar(1e30),btscalar(1e30)); todo pass camera, for some culling #endif #ifdef use_display_lists } } #endif if (shape->getshapetype() == convex_trianglemesh_shape_proxytype) { btconvextrianglemeshshape convexmesh = (btconvextrianglemeshshape) shape;  //todo: pass camera for some culling btvector3 aabbmax(btscalar(1e30),btscalar(1e30),btscalar(1e30)); btvector3 aabbmin(-btscalar(1e30),-btscalar(1e30),-btscalar(1e30)); trianglegldrawcallback drawcallback; convexmesh->getmeshinterface()->internalprocessalltriangles(&drawcallback,aabbmin,aabbmax);  } todo: error in original sources gl_depth_buffer_bit instead of gl_depth_test gl.gldisable(gl_depth_test); glrasterpos3f(0, 0, 0);//mvtx.x(), vtx.y(), vtx.z()); todo: bmf_drawstring(bmf_getfont(bmf_khelvetica10),shape->getname()); bmf_drawstring(bmf_getfont(bmf_khelvetica10),shape->getextradebuginfo()); gl.glenable(gl_depth_test); glpopmatrix(); ////////////////////////////////////////////////////////////////////////// opengl display list lines);"
com.bulletphysics.demos.opengl.IGL "www.bulletphysics.com/"
com.bulletphysics.demos.opengl.LWJGL "www.bulletphysics.com/"
com.bulletphysics.demos.opengl.LwjglGL "www.bulletphysics.com/ font = fontrender.createfont("dialog", 11, false, true); ////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// the glucylinder subroutine draws a cylinder that is oriented along the z axis. the base of the cylinder is placed at z = 0; the top of the cylinder is placed at z=height. like a sphere, the cylinder is subdivided around the z axis into slices and along the z axis into stacks. //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.demos.vehicle.VehicleDemo "vehicledemo shows how to setup and use the built-in raycast vehicle. sizeof(btvector3) 3sizeof(int) www.bulletphysics.com/ by default, bullet vehicle uses y as up axis. you can override the up axis, for example z-axis up. enable this define to see how to: //#define force_zaxis_up 1 #ifdef force_zaxis_up int rightindex = 0; int upindex = 2; int forwardindex = 1; btvector3 wheeldirectioncs0(0,0,-1); btvector3 wheelaxlecs(1,0,0); #else #endif raycastvehicle is the interface for the constraint that implements the raycast vehicle notice that for higher-quality slow-moving vehicles, another approach might be better implementing explicit hinged-wheel constraints with cylinder collision, rather then raycasts this should be engine/velocity dependent 1e30f; 1.0f; ////////////////////////////////////////////////////////////////////////// #ifdef force_zaxis_up m_cameraup = btvector3(0,0,1); m_forwardaxis = 1; #endif overlappingpaircache = new axissweep3(worldmin, worldmax); overlappingpaircache = new simplebroadphase(); #ifdef force_zaxis_up dynamicsworld.setgravity(new vector3f(0, 0, -10)); #endif m_dynamicsworld->setgravity(btvector3(0,0,0)); either use heightfield or triangle mesh #define use_trimesh_ground 1 #ifdef use_trimesh_ground create a triangle-mesh ground height set to zero, but can also use curved landscape, just uncomment out the code 20f (float)math.sin(i wl) (float)math.cos(j wl); #ifdef force_zaxis_up m_vertices[i+jnum_verts_x].setvalue( (i-num_verts_x0.5f)triangle_size, (j-num_verts_y0.5f)triangle_size, height ); #else #endif int index=0; #else //testing btheightfieldterrainshape int width=128; int length=128; unsigned char heightfielddata = new unsigned char[widthlength]; { for (int i=0;isetusediamondsubdivision(true);  btvector3 localscaling(20,20,20); localscaling[upindex]=1.f; groundshape->setlocalscaling(localscaling);  tr.setorigin(btvector3(0,-64.5f,0));  #endif create ground object #ifdef force_zaxis_up // indexrightaxis = 0; // indexupaxis = 2; // indexforwardaxis = 1; btcollisionshape chassisshape = new btboxshape(btvector3(1.f,2.f, 0.5f)); btcompoundshape compound = new btcompoundshape(); bttransform localtrans; localtrans.setidentity(); //localtrans effectively shifts the center of mass with respect to the chassis localtrans.setorigin(btvector3(0,0,1)); #else localtrans effectively shifts the center of mass with respect to the chassis #endif chassisshape); m_carchassis->setdamping(0.2,0.2); create vehicle never deactivate the vehicle choose coordinate system #ifdef force_zaxis_up btvector3 connectionpointcs0(cube_half_extents-(0.3wheelwidth),2cube_half_extents-wheelradius, connectionheight); #else #endif #ifdef force_zaxis_up connectionpointcs0 = btvector3(-cube_half_extents+(0.3wheelwidth),2cube_half_extents-wheelradius, connectionheight); #else #endif #ifdef force_zaxis_up connectionpointcs0 = btvector3(-cube_half_extents+(0.3wheelwidth),-2cube_half_extents+wheelradius, connectionheight); #else #endif //force_zaxis_up #ifdef force_zaxis_up connectionpointcs0 = btvector3(cube_half_extents-(0.3wheelwidth),-2cube_half_extents+wheelradius, connectionheight); #else #endif to be implemented by the demo synchronize the wheels with the (interpolated) chassis worldtransform draw wheels (cylinders) during idle mode, just run 1 simulation step maximum #define verbose_feedback #ifdef verbose_feedback if (!numsimsteps) printf("interpolated transforms\n"); else { if (numsimsteps > maxsimsubsteps) { //detect dropping frames printf("dropped (%i) simulation steps out of %i\n",numsimsteps - maxsimsubsteps,numsimsteps); } else { printf("simulated (%i) steps\n",numsimsteps); } } #endif //verbose_feedback #ifdef use_quickprof btprofiler::beginblock("render"); #endif //use_quickprof optional but useful: debug drawing #ifdef use_quickprof btprofiler::endblock("render"); #endif optional but useful: debug drawing synchronize the wheels with the (interpolated) chassis worldtransform printf("key = %i x=%i y=%i\n",key,x,y); glutpostredisplay(); //#define disable_camera 1 #ifdef disable_camera demoapplication::updatecamera(); return; #endif //disable_camera look at the vehicle interpolate the camera height #ifdef force_zaxis_up m_cameraposition[2] = (15.0m_cameraposition[2] + m_cameratargetposition[2] + m_cameraheight)/16.0; #else #endif keep distance between min and max distance update opengl camera settings"
com.bulletphysics.dynamics.ActionInterface "basic interface to allow actions such as vehicles and characters to be updated inside a {@link dynamicsworld}. www.bulletphysics.com/"
com.bulletphysics.dynamics.character.KinematicCharacterController "kinematiccharactercontroller is an object that supports a sliding motion in a world. it uses a {@link ghostobject} and convex sweep test to test for upcoming collisions. this is combined with discrete collision detection to recover from penetrations. interaction between kinematiccharactercontroller and dynamic rigid bodies needs to be explicity implemented by the this should probably be called setpositionincrementpersimulatorstep. this is neither a direction nor a velocity, but the amount to increment the position each simulation iteration, regardless of dt. this call will reset any velocity set by {@link #setvelocityfortimeinterval}. caller provides a velocity with which the character should move for the given time period. after the time period, velocity is reset to zero. this call will reset any walk direction set by {@link #setwalkdirection}. negative time intervals will result in no motion. returns the reflection direction of a ray going 'direction' hitting a surface with normal 'normal'. from: http://www-cs-students.stanford.edu/~adityagp/final/node3.html returns the portion of 'direction' that is parallel to 'normal' returns the portion of 'direction' that is perpindicular to 'normal' fixme: handle penetration properly if (touchingcontact) { if (normalizeddirection.dot(touchingnormal) > 0.0f) { updatetargetpositionbasedoncollision(touchingnormal); } } && !onground() www.bulletphysics.com/ is also in ghostobject, but it needs to be convex, so we store it here to avoid upcast slope angle that is set (used for returning the exact value) cosine equivalent of m_maxsloperadians (calculated once when set, for optimization) @todo: remove this and fix the code this is the desired walk direction, set by the some internal variables keep track of the contact manifolds 1g acceleration terminal velocity of a sky diver in m/s. ? actioninterface interface actioninterface interface printf("character could not recover from penetration = %d\n", numpenetrationloops); printf("m_targetposition=%f,%f,%f\n",m_targetposition[0],m_targetposition[1],m_targetposition[2]); printf("playerstep(): "); printf(" dt = %f", dt); quick check... printf("\n"); no motion update fall velocity. printf("walkdirection(%f,%f,%f)\n",walkdirection[0],walkdirection[1],walkdirection[2]); printf("walkspeed=%f\n",walkspeed); system.out.println("playerstep 3"); printf(" time: %f", m_velocitytimeinterval); still have some time left for moving! how far will we move while we are moving? printf(" dtmoving: %f", dtmoving); okay, step printf("\n"); #if 0 currently no jumping. bttransform xform; m_rigidbody->getmotionstate()->getworldtransform (xform); btvector3 up = xform.getbasis()[1]; up.normalize (); btscalar magnitude = (btscalar(1.0)/m_rigidbody->getinvmass()) btscalar(8.0); m_rigidbody->applycentralimpulse (up magnitude); #endif static helper method www-cs-students.stanford.edu/~adityagp/final/node3.html return direction - (btscalar(2.0) direction.dot(normal)) normal; btscalar magnitude = direction.dot(normal); return normal magnitude; return direction - parallelcomponent(direction, normal); ?? printf("touching %f\n", dist); manifold->clearmanifold(); printf("m_touchingnormal = %f,%f,%f\n",m_touchingnormal[0],m_touchingnormal[1],m_touchingnormal[2]); system.out.println("recoverfrompenetration "+penetration+" "+touchingnormal); phase 1: up find only sloped/flat surface hits, avoid wall and ceiling hits... we moved up only a fraction of the step height tangentmag != 0.0) printf("parcomponent=%f,%f,%f\n",parcomponent[0],parcomponent[1],parcomponent[2]); printf("perpcomponent=%f,%f,%f\n",perpcomponent[0],perpcomponent[1],perpcomponent[2]); printf("movementlength don't normalize a zero vector\n"); printf("m_normalizeddirection=%f,%f,%f\n", m_normalizeddirection[0],m_normalizeddirection[1],m_normalizeddirection[2]); phase 2: forward and strafe printf("distance2=%f\n",distance2); we moved only a fraction float hitdistance = hitdistancevec.length(); if the distance is farther than the collision margin, move if (hitdistance > addedmargin) { //printf("callback.m_closesthitfraction=%f\n",callback.m_closesthitfraction); currentposition.interpolate(currentposition, targetposition, callback.closesthitfraction); } see quake2: "if velocity is against original velocity, stop ead to avoid tiny oscilations in sloping corners." printf("currentdir: don't normalize a zero vector\n"); we moved whole way if (callback.m_closesthitfraction == 0.f) break; phase 3: down we dropped a fraction of the height -> hit floor we dropped the full height ////////////////////////////////////////////////////////////////////////// ////////////////////////////////////////////////////////////////////////// need to transform normal into worldspace"
com.bulletphysics.dynamics.constraintsolver.ConeTwistConstraint "conetwistconstraint can be used to simulate ragdoll joints (upper arm, leg etc). [3] [3] 3 orthogonal linear constraints set bias, sign, clear accumulator todo: stack get frame into world space swing1 = scalarutil.atan2fast(b2axis1.dot(b1axis2), b2axis1.dot(b1axis1)); swing2 = scalarutil.atan2fast(b2axis1.dot(b1axis3), b2axis1.dot(b1axis1)); calculate necessary axis & factors twist limits vector3f b2axis2 = stack.alloc(vector3f.class); linear part positional error (zeroth order error) this is the error projected on the normal solve angular part solve swing limit clamp the accumulated impulse solve twist limit clamp the accumulated impulse"
com.bulletphysics.dynamics.constraintsolver.ConstraintPersistentData "stores some extra information to each contact point. it is not in the contact point, because that want to keep the collision detection independent from the constraint solver. total applied impulse during most recent frame www.bulletphysics.com/ some data doesn't need to be persistent over frames: todo: clean/reuse this"
com.bulletphysics.dynamics.constraintsolver.ConstraintSolver "abstract class for constraint solvers. solve a group of constraints. , btstackalloc stackalloc , btstackalloc stackalloc clear internal cached data and reset random seed. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get();"
com.bulletphysics.dynamics.constraintsolver.ContactConstraint "functions for resolving contacts. bilateral constraint between two dynamic objects. response between two dynamic objects with friction. velocity + friction response between two dynamic objects with friction www.bulletphysics.com/ this jacobian entry could be re-used for all iterations todo: move this into proper structure #ifdef only_use_linear_mass btscalar massterm = btscalar(1.) / (body1.getinvmass() + body2.getinvmass()); impulse = - contactdamping rel_vel massterm; #else #endif constant over all iterations btscalar damping = solverinfo.m_damping ; damping; see erin catto's gdc 2006 paper: clamp the accumulated impulse #ifdef use_internal_apply_impulse #else //use_internal_apply_impulse body1.applyimpulse(normal(normalimpulse), rel_pos1); body2.applyimpulse(-normal(normalimpulse), rel_pos2); #endif //use_internal_apply_impulse friction apply friction in the 2 tangential directions 1st tangent calculate j that moves us to zero relative velocity 2nd tangent calculate j that moves us to zero relative velocity #ifdef use_internal_apply_impulse #else //use_internal_apply_impulse body1.applyimpulse((j1 cpd->m_frictionworldtangential0)+(j2 cpd->m_frictionworldtangential1), rel_pos1); body2.applyimpulse((j1 -cpd->m_frictionworldtangential0)+(j2 -cpd->m_frictionworldtangential1), rel_pos2); #endif //use_internal_apply_impulse btscalar damping = solverinfo.m_damping ; damping; see erin catto's gdc 2006 paper: clamp the accumulated impulse #ifdef use_internal_apply_impulse #else //use_internal_apply_impulse body1.applyimpulse(normal(normalimpulse), rel_pos1); body2.applyimpulse(-normal(normalimpulse), rel_pos2); #endif //use_internal_apply_impulse friction"
com.bulletphysics.dynamics.constraintsolver.ContactConstraintEnum "todo: name www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.ContactSolverFunc "contact solving function. www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.ContactSolverInfo "current state of contact solver. www.bulletphysics.com/ used as baumgarte factor used in split impulse"
com.bulletphysics.dynamics.constraintsolver.Generic6DofConstraint "2007-09-09 btgeneric6dofconstraint refactored by francisco len email: projectileman@yahoo.com http://gimpact.sf.net ! generic6dofconstraint between two rigidbodies each with a pivot point that descibes the axis location in local space. generic6dofconstraint can leave any of the 6 degree of freedom "free" or "locked". currently this limit supports rotational motors.  for linear limits, use {@link #setlinearupperlimit}, {@link #setlinearlowerlimit}. you can set the parameters with the {@link translationallimitmotor} structure accsesible through the {@link #gettranslationallimitmotor} method. at this moment translational motors are not supported. may be in the future. for angular limits, use the {@link rotationallimitmotor} structure for configuring the limit. this is accessible through {@link #getrotationallimitmotor} method, this brings support for limit parameters and motors. angulars limits have these possible ranges:   axis min angle max angle  x -pi pi  y -pi/2 pi/2  z -pi/2 pi/2     [3] [3] [3] [3] matrixtoeulerxyz from http://www.geometrictools.com/libfoundation/mathematics/wm4matrix3.inl.html calcs the euler angles between the two bodies. calcs global transform of the offsets. calcs the global transform for the joint offset for body a an b, and also calcs the agle differences between the bodies. see also: generic6dofconstraint.getcalculatedtransforma, generic6dofconstraint.getcalculatedtransformb, generic6dofconstraint.calculateangleinfo jacobianentry jaclinear jacobianentry jacangular test angular limit. calculates angular correction and returns true if limit needs to be corrected. generic6dofconstraint.buildjacobian must be called previously. jaclinear[i] jacang[i] get the rotation axis in global coordinates. generic6dofconstraint.buildjacobian must be called previously. get the relative euler angle. generic6dofconstraint.buildjacobian must be called previously. gets the global transform of the offset for body a. see also: generic6dofconstraint.getframeoffseta, generic6dofconstraint.getframeoffsetb, generic6dofconstraint.calculateangleinfo. gets the global transform of the offset for body b. see also: generic6dofconstraint.getframeoffseta, generic6dofconstraint.getframeoffsetb, generic6dofconstraint.calculateangleinfo. retrieves the angular limit informacion. retrieves the limit informacion. first 3 are linear, next 3 are angular test limit. - free means upper &lt; lower, - locked means upper == lower - limited means upper &gt; lower - limitindex: first 3 are linear, next 3 are angular www.bulletphysics.com/ gimpact.sf.net / !reporterrorwarning(buff); } test limits clear accumulated impulses for the next simulation step calculates transform const btvector3& pivotainw = m_calculatedtransforma.getorigin(); const btvector3& pivotbinw = m_calculatedtransformb.getorigin(); not used here btvector3 rel_pos1 = pivotainw - m_rba.getcenterofmassposition(); btvector3 rel_pos2 = pivotbinw - m_rbb.getcenterofmassposition(); linear part angular part calculates error angle create angular atom calculatetransforms(); linear angular get axis overridable"
com.bulletphysics.dynamics.constraintsolver.HingeConstraint "hinge constraint by dirk gregorius. limits added by marcus hennix at starbreeze studios hinge constraint between two rigid bodies each with a pivot point that descibes the axis location in local space. axis defines the orientation of the hinge axis. [3] [3] [3] www.bulletphysics.com/ 3 orthogonal linear constraints 2 orthogonal angular constraints+ 1 for limit/motor constraint axii. assumes z is hinge axis. since no frame is given, assume this to be zero angle and just pick rb transform axis start with free since no frame is given, assume this to be zero angle and just pick rb transform axis fixed axis in worldspace start with free flip axis start with free not providing rigidbody b means implicitly using worldspace for body b flip axis start with free calculate two perpendicular jointaxis, orthogonal to hingeaxis these two jointaxis require equal angular velocities for both bodies this is unused for now, it's a todo todo: check this getrigidbodya().getcenterofmasstransform().getbasis() m_rbaframe.getbasis().getcolumn(2); java note: reused mat1 and mat2, as recomputation is not needed java note: reused mat1 and mat2, as recomputation is not needed compute limit information set bias, sign, clear accumulator compute k = jwj' for hinge axis linear part positional error (zeroth order error) this is the error projected on the normal solve angular part get axes in world space solve orthogonal angular velocity correction scale for mass and relaxation todo: expose this 0.9 factor to developer solve angular positional correction todo: check vector3f angularerror = -axisa.cross(axisb) (btscalar(1.)/timestep); solve limit clamp the accumulated impulse apply motor todo: add limits too todo: should clip against accumulated impulse"
com.bulletphysics.dynamics.constraintsolver.JacobianEntry "jacobian entry is an abstraction that allows to describe constraints. it can be used in combination with a constraint solver. can be used to relate the effect of an impulse to the constraint error. constraint between two different rigidbodies. angular constraint between two different rigidbodies. angular constraint between two different rigidbodies. constraint on one rigidbody. for two constraints on the same rigidbody (for example vehicle friction). for two constraints on sharing two same rigidbodies (for example two contact points between two rigidbodies). www.bulletphysics.com/ notes: another memory optimization would be to store m_1minvjt in the remaining 3 w components which makes the btjacobianentry memory layout 16 bytes if you only are interested in angular part, just feed massinva and massinvb zero protected final bulletstack stack = bulletstack.get(); optimization: can be stored in the w/last component of one of the vectors"
com.bulletphysics.dynamics.constraintsolver.package-info "constraints and solvers. www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.Point2PointConstraint "point to point constraint between two rigid bodies each with a pivot point that descibes the "ballsocket" location in local space. [3] //velocity error (first order error) btscalar rel_vel = m_jac[i].getrelativevelocity(m_rba.getlinearvelocity(),angvela, m_rbb.getlinearvelocity(),angvelb); www.bulletphysics.com/ 3 orthogonal linear constraints btvector3 angvela = m_rba.getcenterofmasstransform().getbasis().transpose() m_rba.getangularvelocity(); btvector3 angvelb = m_rbb.getcenterofmasstransform().getbasis().transpose() m_rbb.getangularvelocity(); this jacobian entry could be re-used for all iterations velocity error (first order error) positional error (zeroth order error) this is the error projected on the normal //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.dynamics.constraintsolver.RotationalLimitMotor "2007-09-09 btgeneric6dofconstraint refactored by francisco len email: projectileman@yahoo.com http://gimpact.sf.net rotation limit structure for generic joints. is limited? need apply correction? calculates error. calculates currentlimit and currentlimiterror. apply the correction impulses for two bodies. www.bulletphysics.com/ gimpact.sf.net protected final bulletstack stack = bulletstack.get(); !< joint limit !< joint limit !< target motor velocity !< max force on motor !< max force on limit !< damping. ! relaxation factor !< error tolerance factor when joint is at limit !< restitution factor ! how much is violated this limit !< 0=free, 1=at lo limit, 2=at hi limit free from violation low limit violation high limit violation free from violation current error correction current velocity difference correction velocity no need for applying force correction impulse clip correction impulse todo: should clip against accumulated impulse sort with accumulated impulses"
com.bulletphysics.dynamics.constraintsolver.SequentialImpulseConstraintSolver "sequentialimpulseconstraintsolver uses a propagation method and sequentially applies impulses. the approach is the 3d version of erin catto's gdc 2006 tutorial. see http://www.gphysics.com although sequential impulse is more intuitive, it is mathematically equivalent to projected successive overrelaxation (iterative lcp). applies impulses for combined restitution and penetration recovery and to simulate friction. velocity + friction response between two dynamic objects with friction ,btstackalloc stackalloc { for (int i=0;igetislandtag() >= 0)) { btassert(rb->getcompanionid() setcompanionid(solverbodyid); } } } ,btstackalloc stackalloc ,btstackalloc stackalloc , stackalloc , stackalloc printf("m_tmpsolverbodypool.size() = %i\n",m_tmpsolverbodypool.size()); printf("m_tmpsolverconstraintpool.size() = %i\n",m_tmpsolverconstraintpool.size()); printf("m_tmpsolverfrictionconstraintpool.size() = %i\n",m_tmpsolverfrictionconstraintpool.size()); printf("m_tmpsolverbodypool.capacity() = %i\n",m_tmpsolverbodypool.capacity()); printf("m_tmpsolverconstraintpool.capacity() = %i\n",m_tmpsolverconstraintpool.capacity()); printf("m_tmpsolverfrictionconstraintpool.capacity() = %i\n",m_tmpsolverfrictionconstraintpool.capacity()); sequentially applies impulses. ,stackalloc advanced: override the default contact solving function for contacts, for certain types of rigidbody see rigidbody.contactsolvertype and rigidbody.frictionsolvertype advanced: override the default friction solving function for contacts, for certain types of rigidbody see rigidbody.contactsolvertype and rigidbody.frictionsolvertype www.bulletphysics.com/ www.gphysics.com ////////////////////////////////////////////////////////////////////////// btseed2 is used for re-arranging the constraint rows. improves convergence/quality of friction btalignedfree(cpd); printf("totalcpd = %i. deleted ptr %x\n",totalcpd, initialize default friction/contact funcs see ode: adam's all-int straightforward(?) drandint (0..n-1) seems good; xor-fold and modulus note: probably more aggressive than it needs to be -- might be able to get away without one or two of the innermost branches. todo: check modulo c vs java mismatch optimized version of projected relative velocity, use precomputed cross products with normal body1.getvelocityinlocalpoint(contactconstraint.m_rel_posa,vel1); body2.getvelocityinlocalpoint(contactconstraint.m_rel_posb,vel2); btvector3 vel = vel1 - vel2; btscalar rel_vel = contactconstraint.m_contactnormal.dot(vel); btscalar positionalerror = contactconstraint.m_penetration; damping; see erin catto's gdc 2006 paper: clamp the accumulated impulse optimized version of projected relative velocity, use precomputed cross products with normal body1.getvelocityinlocalpoint(contactconstraint.m_rel_posa,vel1); body2.getvelocityinlocalpoint(contactconstraint.m_rel_posb,vel2); btvector3 vel = vel1 - vel2; btscalar rel_vel = contactconstraint.m_contactnormal.dot(vel); damping; see erin catto's gdc 2006 paper: clamp the accumulated impulse friction calculate j that moves us to zero relative velocity #define clamp_accumulated_friction_impulse 1 #ifdef clamp_accumulated_friction_impulse #else if (limit computeimpulsedenominator(pos1,solverconstraint.m_contactnormal); btscalar denom1 = rb1->computeimpulsedenominator(pos2,solverconstraint.m_contactnormal); #else #endif //compute_impulse_denom printf("empty\n"); btrigidbody rb0=0,rb1=0; //#ifdef force_refesh_contact_manifolds  begin_profile("refreshmanifolds");  int i;    for (i=0;igetbody1(); rb0 = (btrigidbody)manifold->getbody0();  manifold->refreshcontactpoints(rb0->getcenterofmasstransform(),rb1->getcenterofmasstransform());  }  end_profile("refreshmanifolds"); //#endif //force_refesh_contact_manifolds int sizeofsb = sizeof(btsolverbody); int sizeofsc = sizeof(btsolverconstraint); if (1) if m_stackalloc, try to pack bodies/constraints to speed up solving btblock sablock; sablock = stackalloc->beginblock(); int memsize = 16; unsigned char stackmemory = stackalloc->allocate(memsize); todo: use stack allocator for this temp memory int minreservation = nummanifolds 2; m_tmpsolverbodypool.reserve(minreservation); don't convert all bodies, only the one we need so solver the constraints m_tmpsolverconstraintpool.reserve(minreservation); m_tmpsolverfrictionconstraintpool.reserve(minreservation); body has already been converted create a static body create a static body #ifdef compute_impulse_denom btscalar denom0 = rb0->computeimpulsedenominator(pos1,cp.m_normalworldonb); btscalar denom1 = rb1->computeimpulsedenominator(pos2,cp.m_normalworldonb); #else #endif //compute_impulse_denom solverconstraint.m_penetration = cp.getdistance(); warm starting (or zero if disabled) 0.0f) ?? re-calculate friction direction every frame, todo: check if this is really needed todo: btcontactsolverinfo info = infoglobal; todo: use stack allocator for such temporarily memory, same for solver bodies/constraints should traverse the contacts random order... todo: use solver bodies, so we don't need to copy from/to btrigidbody do a callback here? printf("m_tmpsolverconstraintpool.size() = %i\n",m_tmpsolverconstraintpool.size()); todo: solver cache friendly you need to provide at least some bodies simpledynamicsworld needs to switch off solver_cache_friendly should traverse the contacts random order... java note: swaps references instead of copying values (but that's fine in this context) only necessary to refresh the manifold once (first iteration). the integration is done outside the loop #ifdef force_refesh_contact_manifolds manifoldptr->refreshcontactpoints(body0->getcenterofmasstransform(),body1->getcenterofmasstransform()); #endif //force_refesh_contact_manifolds this jacobian entry is re-used for all iterations might be invalid printf("invalid: cpd->m_persistentlifetime = %i cp.getlifetime() = %i\n",cpd->m_persistentlifetime,cp.getlifetime()); new (cpd) btconstraintpersistentdata; printf("persistent: cpd->m_persistentlifetime = %i cp.getlifetime() = %i\n",cpd->m_persistentlifetime,cp.getlifetime()); todo: should this be in a pool? void mem = btalignedalloc(sizeof(btconstraintpersistentdata),16); cpd = new (mem)btconstraintpersistentdata; assert(cpd != null); printf("totalcpd = %i printf(" dependent on rigidbody a and b types, fetch the contact/friction response func perhaps do a similar thing for friction/restutution combiner funcs... /btscalar(info.m_numiterations); restitution and penetration work in same direction so rel_vel for friction re-calculate friction direction every frame, todo: check if this is really needed #define no_friction_warmstart 1 #ifdef no_friction_warmstart #endif //no_friction_warmstart btvector3 totalimpulse = //#ifndef no_friction_warmstart //cpd->m_frictionworldtangential0cpd->m_accumulatedtangentimpulse0+ //cpd->m_frictionworldtangential1cpd->m_accumulatedtangentimpulse1+ //#endif //no_friction_warmstart cp.normalworldonbcpd.appliedimpulse; / / apply previous frames impulse on both bodies btconstraintpersistentdata cpd = (btconstraintpersistentdata) cp.m_ //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.dynamics.constraintsolver.SliderConstraint "added by roman ponomarev (rponom@gmail.com) april 04, 2008 todo: - add clamping od accumulated impulse to improve stability - add conversion for ode constraint solver  3 3 www.bulletphysics.com/ java note: sliderconstraint from 2.71 use framea fo define limits, if true linear limits angular limits softness, restitution and damping for different cases dirlin - moving inside linear limits limlin - hitting linear limit dirang - moving inside angular limits limang - hitting angular limit ortholin, orthoang - against constraint axis for interlal use access for ode solver internal calculate transforms along x linear part angular part clear accumulator for motors linear calculate positional error get parameters calcutate and apply impulse apply linear motor clamp accumulated impulse apply clamped impulse angular get axes in world space solve orthogonal angular velocity correction solve angular positional correction apply impulse solve angular limits apply angular motor clamp accumulated impulse apply clamped impulse shared code used by ode solver along x linear part access for pe solver"
com.bulletphysics.dynamics.constraintsolver.SolverBody "solverbody is an internal data structure for the constraint solver. only necessary data is packed to increase cache coherence/performance. optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); m_originalbody->setcompanionid(-1); correct the position/orientation based on push/turn recovery m_originalbody->setcompanionid(-1);"
com.bulletphysics.dynamics.constraintsolver.SolverConstraint "1d constraint along a normal axis between bodya and bodyb. it can be combined to solve contact and friction constraints. www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.SolverConstraintType "solver constraint type. www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.SolverMode "solver flags. www.bulletphysics.com/"
com.bulletphysics.dynamics.constraintsolver.TranslationalLimitMotor "2007-09-09 btgeneric6dofconstraint refactored by francisco len email: projectileman@yahoo.com http://gimpact.sf.net  test limit. - free means upper &lt; lower, - locked means upper == lower - limited means upper &gt; lower - limitindex: first 3 are linear, next 3 are angular www.bulletphysics.com/ gimpact.sf.net protected final bulletstack stack = bulletstack.get(); !< the constraint lower limits !< the constraint upper limits !< softness for linear limit !< damping for linear limit ! bounce parameter for linear limit find relative velocity rel_pos1.sub(pointina, body1.getcenterofmassposition(tmpvec)); rel_pos2.sub(pointinb, body2.getcenterofmassposition(tmpvec)); apply displacement correction positional error (zeroth order error) handle the limits"
com.bulletphysics.dynamics.constraintsolver.TypedConstraint "typedconstraint is the base class for bullet constraints and vehicles. final www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); todo: stack allocation = new rigidbody(0, null, null);"
com.bulletphysics.dynamics.constraintsolver.TypedConstraintType "typed constraint type. www.bulletphysics.com/"
com.bulletphysics.dynamics.DiscreteDynamicsWorld "discretedynamicsworld provides discrete rigid body simulation. apply gravity, call this once per timestep. ,m_stackalloc ,m_stackalloc ,m_stackalloc , m_stackalloc www.bulletphysics.com/ for variable timesteps for variable timesteps transform predictedtrans = new transform(); to calculate velocities next frame btcollisionobject oba = static_cast(contactmanifold->getbody0()); btcollisionobject obb = static_cast(contactmanifold->getbody1()); todo: iterate over awake simulation islands! m_vehicles[i]->getwheelinfo(v).m_raycastinfo.m_wheelaxlews debug wheels (cylinders) todo: iterate over awake simulation islands! todo: iterate over awake simulation islands! todo: iterate over awake simulation islands! we need to call the update at least once, even for sleeping objects otherwise the 'graphics' transform never updates properly so todo: add 'dirty' flag if (body->getactivationstate() != island_sleeping) synchronize the wheels with the (interpolated) chassis worldtransform fixed timestep with interpolation variable timestep process some debugging flags clamp the number of substeps, to prevent simulation grinding spiralling down to a halt #ifndef bt_no_profile #endif //bt_no_profile apply gravity, predict motion perform collision detection solve contact and other joint constraints callbacktriggers(); integrate transforms update vehicle simulation update vehicle simulation public stackalloc m_stackalloc; we don't split islands, so all constraints/contact manifolds/bodies are passed into the solver regardless the island id also add all non-contact constraints/joints for this island objectarraylist startconstraint = null; find the first constraint for this island startconstraint = &m_sortedconstraints[i]; startconstraint = sortedconstraints.sublist(i, sortedconstraints.size()); count the number of constraints in this island only call solvegroup if there is some work: avoid virtual function call, its overhead can be excessive sorted version of all bttypedconstraint, based on islandid collections.sort(sortedconstraints, sortconstraintonislandpredicate); solve all the constraints for this island store the island id in each body convexshape convexshape = (convexshape)body.getcollisionshape(); btconvexshape convexshape = static_cast(body->getcollisionshape()); java note: added closesthitfraction test to prevent objects being stuck system.out.printf("clamped integration to hit fraction = %f\n", sweepresults.closesthitfraction); damping #ifndef bt_no_profile #endif //bt_no_profile xy xz yz draw a small simplex at the center of the object java todo: debugdrawobject, note that this commented code is from old version, use actual version when implementing if (shape->getshapetype() == compound_shape_proxytype) { const btcompoundshape compoundshape = static_cast(shape); for (int i=compoundshape->getnumchildshapes()-1;i>=0;i--) { bttransform childtrans = compoundshape->getchildtransform(i); const btcollisionshape colshape = compoundshape->getchildshape(i); debugdrawobject(worldtransformchildtrans,colshape,color); }  } else { switch (shape->getshapetype()) {  case sphere_shape_proxytype: { const btsphereshape sphereshape = static_cast(shape); btscalar radius = sphereshape->getmargin();//radius doesn't include the margin, so draw with margin  debugdrawsphere(radius, worldtransform, color); break; } case multi_sphere_shape_proxytype: { const btmultisphereshape multisphereshape = static_cast(shape);  for (int i = multisphereshape->getspherecount()-1; i>=0;i--) { bttransform childtransform = worldtransform; childtransform.getorigin() += multisphereshape->getsphereposition(i); debugdrawsphere(multisphereshape->getsphereradius(i), childtransform, color); }  break; } case capsule_shape_proxytype: { const btcapsuleshape capsuleshape = static_cast(shape);  btscalar radius = capsuleshape->getradius(); btscalar halfheight = capsuleshape->gethalfheight();  // draw the ends { bttransform childtransform = worldtransform; childtransform.getorigin() = worldtransform btvector3(0,halfheight,0); debugdrawsphere(radius, childtransform, color); }  { bttransform childtransform = worldtransform; childtransform.getorigin() = worldtransform btvector3(0,-halfheight,0); debugdrawsphere(radius, childtransform, color); }  // draw some additional lines btvector3 start = worldtransform.getorigin(); getdebugdrawer()->drawline(start+worldtransform.getbasis() btvector3(-radius,halfheight,0),start+worldtransform.getbasis() btvector3(-radius,-halfheight,0), color); getdebugdrawer()->drawline(start+worldtransform.getbasis() btvector3(radius,halfheight,0),start+worldtransform.getbasis() btvector3(radius,-halfheight,0), color); getdebugdrawer()->drawline(start+worldtransform.getbasis() btvector3(0,halfheight,-radius),start+worldtransform.getbasis() btvector3(0,-halfheight,-radius), color); getdebugdrawer()->drawline(start+worldtransform.getbasis() btvector3(0,halfheight,radius),start+worldtransform.getbasis() btvector3(0,-halfheight,radius), color);  break; } case cone_shape_proxytype: { const btconeshape coneshape = static_cast(shape); btscalar radius = coneshape->getradius();//+coneshape->getmargin(); btscalar height = coneshape->getheight();//+coneshape->getmargin(); btvector3 start = worldtransform.getorigin();  int upaxis= coneshape->getconeupindex();   btvector3 offsetheight(0,0,0); offsetheight[upaxis] = height btscalar(0.5); btvector3 offsetradius(0,0,0); offsetradius[(upaxis+1)%3] = radius; btvector3 offset2radius(0,0,0); offset2radius[(upaxis+2)%3] = radius;  getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight),start+worldtransform.getbasis() (-offsetheight+offsetradius),color); getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight),start+worldtransform.getbasis() (-offsetheight-offsetradius),color); getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight),start+worldtransform.getbasis() (-offsetheight+offset2radius),color); getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight),start+worldtransform.getbasis() (-offsetheight-offset2radius),color);    break;  } case cylinder_shape_proxytype: { const btcylindershape cylinder = static_cast(shape); int upaxis = cylinder->getupaxis(); btscalar radius = cylinder->getradius(); btscalar halfheight = cylinder->gethalfextentswithmargin()[upaxis]; btvector3 start = worldtransform.getorigin(); btvector3 offsetheight(0,0,0); offsetheight[upaxis] = halfheight; btvector3 offsetradius(0,0,0); offsetradius[(upaxis+1)%3] = radius; getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight+offsetradius),start+worldtransform.getbasis() (-offsetheight+offsetradius),color); getdebugdrawer()->drawline(start+worldtransform.getbasis() (offsetheight-offsetradius),start+worldtransform.getbasis() (-offsetheight-offsetradius),color); break; } default: {  if (shape->isconcave()) { btconcaveshape concavemesh = (btconcaveshape) shape;  //todo pass camera, for some culling btvector3 aabbmax(btscalar(1e30),btscalar(1e30),btscalar(1e30)); btvector3 aabbmin(btscalar(-1e30),btscalar(-1e30),btscalar(-1e30));  debugdrawcallback drawcallback(getdebugdrawer(),worldtransform,color); concavemesh->processalltriangles(&drawcallback,aabbmin,aabbmax);  }  if (shape->getshapetype() == convex_trianglemesh_shape_proxytype) { btconvextrianglemeshshape convexmesh = (btconvextrianglemeshshape) shape; //todo: pass camera for some culling btvector3 aabbmax(btscalar(1e30),btscalar(1e30),btscalar(1e30)); btvector3 aabbmin(btscalar(-1e30),btscalar(-1e30),btscalar(-1e30)); //debugdrawcallback drawcallback; debugdrawcallback drawcallback(getdebugdrawer(),worldtransform,color); convexmesh->getmeshinterface()->internalprocessalltriangles(&drawcallback,aabbmin,aabbmax); }   /// for polyhedral shapes if (shape->ispolyhedral()) { btpolyhedralconvexshape polyshape = (btpolyhedralconvexshape) shape;  int i; for (i=0;igetnumedges();i++) { btpoint3 a,b; polyshape->getedge(i,a,b); btvector3 wa = worldtransform a; btvector3 wb = worldtransform b; getdebugdrawer()->drawline(wa,wb,color);  }   } } } } btalignedfree( m_constraintsolver); java note: not part of the original api java note: not part of the original api ////////////////////////////////////////////////////////////////////////// private static class debugdrawcallback implements trianglecallback, internaltriangleindexcallback { private idebugdraw debugdrawer; private final vector3f color = new vector3f(); private final transform worldtrans = new transform();  public debugdrawcallback(idebugdraw debugdrawer, transform worldtrans, vector3f color) { this.debugdrawer = debugdrawer; this.worldtrans.set(worldtrans); this.color.set(color); }  public void internalprocesstriangleindex(vector3f[] triangle, int partid, int triangleindex) { processtriangle(triangle,partid,triangleindex); }  private final vector3f wv0 = new vector3f(),wv1 = new vector3f(),wv2 = new vector3f();  public void processtriangle(vector3f[] triangle, int partid, int triangleindex) { wv0.set(triangle[0]); worldtrans.transform(wv0); wv1.set(triangle[1]); worldtrans.transform(wv1); wv2.set(triangle[2]); worldtrans.transform(wv2);  debugdrawer.drawline(wv0, wv1, color); debugdrawer.drawline(wv1, wv2, color); debugdrawer.drawline(wv2, wv0, color); } } tob.getorigin()-fromb.getorigin(); don't report time of impact for motion away from the contact normal (or causes minor penetration) don't collide with itself don't do ccd when the collision filters are not matching call needsresponse, see http://code.google.com/p/bullet/issues/detail?id=179 don't do ccd when there are already contact points (touching contact/penetration) manifoldarray.resize(0);"
com.bulletphysics.dynamics.DynamicsWorld "dynamicsworld is the interface class for several dynamics implementation, basic, discrete, parallel, and continuous etc. proceeds the simulation over 'timestep', units in preferably in seconds. by default, bullet will subdivide the timestep in constant substeps of each 'fixedtimestep'. in order to keep the simulation real-time, the maximum number of substeps can be clamped to 'maxsubsteps'. you can disable subdividing the timestep/substepping by passing maxsubsteps=0 as second argument to stepsimulation, but in that case you have to keep the timestep constant. once a rigidbody is added to the dynamics world, it will get this gravity assigned. existing rigidbodies in the world get gravity assigned too, during this method. set the callback for when an internal tick (simulation substep) happens, optional www.bulletphysics.com/ java note: not part of the original api java note: not part of the original api"
com.bulletphysics.dynamics.DynamicsWorldType "dynamics world type. www.bulletphysics.com/"
com.bulletphysics.dynamics.InternalTickCallback "callback called for each internal tick. @see dynamicsworld#setinternaltickcallback www.bulletphysics.com/"
com.bulletphysics.dynamics.package-info "dynamicsworld and rigidbody. www.bulletphysics.com/"
com.bulletphysics.dynamics.RigidBody "rigidbody is the main class for rigid body objects. it is derived from {@link collisionobject}, so it keeps reference to {@link collisionshape}. it is recommended for performance and memory use to share {@link collisionshape} objects whenever possible. there are 3 types of rigid bodies:  dynamic rigid bodies, with positive mass. motion is controlled by rigid body dynamics. fixed objects with zero mass. they are not moving (basically collision objects). kinematic objects, which are objects without mass, but the to keep collision detection and dynamics separate we don't store a rigidbody pointer, but a rigidbody is derived from collisionobject, so we can safely perform an upcast. continuous collision detection needs prediction. damps the velocity, using the given lineardamping and angulardamping. optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position. is this rigidbody added to a collisionworld/dynamicsworld/broadphase? www.bulletphysics.com/ optionalmotionstate allows to automatic synchronize the world transform for active objects keep track of typed constraints referencing this rigid body for experimental overriding of friction/contact solver func moved to collisionobject no constraints should point to this rigidbody remove constraints from the dynamics world before you delete the related rigidbodies. todo: clamp to some ( if we use motionstate to synchronize world transforms, get the new kinematic/animated world transform vector3f linvel = new vector3f(), angvel = new vector3f(); printf("angular = %f %f %f\n",m_angularvelocity.getx(),m_angularvelocity.gety(),m_angularvelocity.getz()); on new damping: see discussion/issue report here: http://code.google.com/p/bullet/issues/detail?id=74 todo: do some performance comparisons (but other parts of the engine are probably bottleneck anyway #define use_old_damping_method 1 #ifdef use_old_damping_method linearvelocity.scale(miscutil.gen_clamped((1f - timestep lineardamping), 0f, 1f)); angularvelocity.scale(miscutil.gen_clamped((1f - timestep angulardamping), 0f, 1f)); #else #endif additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc. such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete clamp angular velocity. collision calculations will fail on higher angular velocities we also calculate lin/ang velocity for kinematic objects for kinematic objects, we could also use use: return (m_worldtransform(rel_pos) - m_interpolationworldtransform(rel_pos)) / m_kinematictimestep; disable deactivation todo: change to cast"
com.bulletphysics.dynamics.RigidBodyConstructionInfo "rigidbodyconstructioninfo provides information to create a rigid body. setting mass to zero creates a fixed (non-dynamic) rigid body. for dynamic objects, you can use the collision shape to approximate the local inertia tensor, otherwise use the zero vector (default argument). you can use {@link motionstate} to synchronize the world transform between physics and graphics objects. and if the motion state is provided, the rigid body will initialize its initial world transform from the motion state, {@link #startworldtransform startworldtransform} is only used when you don't provide a motion state. when a motionstate is provided, the rigid body will initialize its world transform from the motion state. in this case, startworldtransform is ignored. best simulation results when friction is non-zero. best simulation results using zero restitution. additional damping can help avoiding lowpass jitter motion, help stability for ragdolls etc. such damping is undesirable, so once the overall simulation quality of the rigid body dynamics system has improved, this should become obsolete. www.bulletphysics.com/"
com.bulletphysics.dynamics.SimpleDynamicsWorld "simpledynamicsworld serves as unit-test and to verify more complicated and optimized dynamics worlds. please use {@link discretedynamicsworld} instead (or continuousdynamicsworld once it is finished). maxsubsteps/fixedtimestep for interpolation is currently ignored for simpledynamicsworld, use discretedynamicsworld instead. , m_stackalloc , m_stackalloc www.bulletphysics.com/ apply gravity, predict motion perform collision detection solve contact constraints integrate transforms todo: iterate over awake simulation islands! todo: iterate over awake simulation islands! btalignedfree(m_constraintsolver); todo: throw new unsupportedoperationexception("not supported yet.");"
com.bulletphysics.dynamics.vehicle.DefaultVehicleRaycaster "default implementation of {@link vehicleraycaster}. www.bulletphysics.com/ rayresultcallback& resultcallback;"
com.bulletphysics.dynamics.vehicle.RaycastVehicle "raycast vehicle, very special constraint that turn a rigidbody into a vehicle. basically most of the code is general for 2 or 4 wheel vehicles, but some of it needs to be reviewed. if (getrigidbody()->getmotionstate()) { bttransform chassisworldtrans; getrigidbody()->getmotionstate()->getworldtransform(chassisworldtrans); return chassisworldtrans; } worldspace forward vector. velocity of vehicle (positive if velocity vector has same direction as foward vector). www.bulletphysics.com/ constructor to create a car from an existing rigidbody up = right.cross(fwd); up.normalize(); rotate around steering over de wheelaxlews wheel.m_steering); wheel_info.setcontactfriction(btscalar(0.0)); todo for driving on dynamic/movable objects!; wheel.m_raycastinfo.m_groundobject = object; clamp on max suspension travel put wheel info as in rest position  simulate suspension  apply suspension force damping of rotation when not in contact spring damper result calculate j that moves us to zero relative velocity calculate the impulse, so that the wheels don't move sidewards collapse all those loops into one! switch between active rolling (throttle), braking and non-active rolling friction (no throttle/break) wheelinfo.m_engineforce timestep; apply the impulses apply friction impulse on the ground not yet not yet //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.dynamics.vehicle.VehicleRaycaster "vehicleraycaster is provides interface for between vehicle simulation and raycasting. www.bulletphysics.com/"
com.bulletphysics.dynamics.vehicle.VehicleRaycasterResult "vehicle raycaster result. www.bulletphysics.com/"
com.bulletphysics.dynamics.vehicle.VehicleTuning "vehicle tuning parameters. www.bulletphysics.com/"
com.bulletphysics.dynamics.vehicle.WheelInfo "wheelinfo contains information per wheel about friction and suspension. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get(); const const const or modified by steering const const const const const can be used to store pointer to sync transforms... calculated by suspension not in contact : position wheel in a nice (rest length) position ////////////////////////////////////////////////////////////////////////// set by raycaster contactnormal raycast hitpoint raycast starting point direction in worldspace axle in worldspace could be general void ptr"
com.bulletphysics.dynamics.vehicle.WheelInfoConstructionInfo "www.bulletphysics.com/"
com.bulletphysics.extras.gimpact.BoxCollision "returns the dot product between a vec3f and the col of a matrix. compairison of transformation objects. calc the transformation relative 1 to 0. inverts matrics by transposing. calcs the full invertion of the matrices. useful for scaling matrices. apply a transform to an aabb. apply a transform to an aabb. merges a box. merges a point. gets the extend and center. finds the intersecting box between this box and the other. finds the ray intersection parameter. aligned box a vec3f with the origin of the ray a vec3f with the direction of the ray transcache is the transformation cache from box to this aabb. simple test for planes. test for a triangle, with edges. gimpact.sourceforge.net/ bt_swap_numbers(pmin,pmax); ////////////////////////////////////////////////////////////////////////// transforms translation of model1 to model 0 transforms rotation of model1 to model 0, equal to r0' r1 absolute value of m_r1to0 static const btvector3 vepsi(1e-6f,1e-6f,1e-6f); m_ar[0] = vepsi + m_r1to0[0].absolute(); m_ar[1] = vepsi + m_r1to0[1].absolute(); m_ar[2] = vepsi + m_r1to0[2].absolute(); ////////////////////////////////////////////////////////////////////////// compute new center compute new center 0 1 2 taken from opcode extends extends class i : a's basis vectors class ii : b's basis vectors class iii : 9 cross products first axis test with x axis test with y axis test with z axis test with x axis test with y axis test with z axis test with x axis test with y axis test with z axis"
com.bulletphysics.extras.gimpact.BvhDataArray "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.BvhTree "tells if the node is a leaf. gimpact.sourceforge.net/ average of centers sort leafnodes so all values larger then splitvalue comes first, and smaller values start from 'splitindex'. swap swapleafnodes(i,splitindex); if the splitindex causes unbalanced trees, fix this by using the center in between startindex and endindex otherwise the tree-building might fail due to stack-overflows in certain cases. unbalanced1 is unsafe: it can cause stack overflows bool unbalanced1 = ((splitindex==startindex) || (splitindex == (endindex-1))); unbalanced2 should work too: always use center (perfect balanced trees) bool unbalanced2 = true; this should be safe too: we have a leaf node setnodebound(curindex,primitive_boxes[startindex].m_bound); m_node_array[curindex].setdataindex(primitive_boxes[startindex].m_data); calculate best splitting axis and where to split it. sort the incoming 'leafnodes' array within range 'startindex/endindex'. split axis calc this node bounding box build left branch build right branch initialize node count to 0 allocate nodes"
com.bulletphysics.extras.gimpact.BvhTreeNodeArray "gimpact.sourceforge.net/ skipindex is negative (internal node), triangleindex >=0 (leafnode) btassert(m_escapeindexordataindex = 0);"
com.bulletphysics.extras.gimpact.ClipPolygon "vector blending. takes two vectors a, b, blends them together. this function calcs the distance from a 3d plane. clips a polygon by a plane. count of the clipped counts clips a polygon by a plane. must be an array of 16 points. count of the clipped counts gimpact.sourceforge.net/ clip first point return to first point clip first point0 point 1 point 2 return to first point0"
com.bulletphysics.extras.gimpact.GeometryOperations "calc a plane from a triangle edge an a normal. finds the closest point(cp) to (v) on a segment (e1,e2). line plane collision. -0 if the ray never intersects, -1 if the ray collides in front, -2 if the ray collides in back find closest points on segments. closest point on segment gimpact.sourceforge.net/ plane are paralele project b over a bt_swap_numbers(_m[0],_m[1]); mid points get point a as the plane collision point"
com.bulletphysics.extras.gimpact.GIM_ShapeRetriever "gimpact.sourceforge.net/ select retriever //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.extras.gimpact.GImpactBvh "this constructor doesn't build the tree. you must call buildset. this constructor doesn't build the tree. you must call buildset. this attemps to refit the box set. this rebuild the entire set. returns the indices of the primitives in the primitive_manager field. returns the indices of the primitives in the primitive_manager field. returns the indices of the primitives in the primitive_manager field. tells if this set has hierarchy. tells if this set is a trimesh. tells if the node is a leaf. stackless recursive collision routine. gimpact.sourceforge.net/ stackless refit const bt_bvh_tree_node nodepointer = get_node_pointer(nodecount); get left bound obtain primitive boxes primitive_manager.get_primitive_box(i,primitive_boxes[i].bound); catch bugs in tree data next subnode skip node catch bugs in tree data next subnode skip node box1.appy_transform_trans_cache(trans_cache_1to0); return box0.has_collision(box1); avoid colliding internal nodes collision result collide left recursive collide right recursive collide left recursive collide right recursive collide left0 left1 collide left0 right1 collide right0 left1 collide right0 right1 else if node1 is not a leaf else if node0 is not a leaf public static float getaveragetreecollisiontime(); #ifdef tri_collision_profiling bt_begin_gim02_tree_time(); #endif //tri_collision_profiling #ifdef tri_collision_profiling bt_end_gim02_tree_time(); #endif //tri_collision_profiling"
com.bulletphysics.extras.gimpact.GImpactCollisionAlgorithm "collision algorithm for gimpact shapes. for register this algorithm in bullet, proceed as following:  collisiondispatcher dispatcher = (collisiondispatcher)dynamicsworld.getdispatcher(); gimpactcollisionalgorithm.registeralgorithm(dispatcher);  creates a new contact point. call before process collision. call before process collision. call before process collision. protected void collide_gjk_triangles(collisionobject body0, collisionobject body1, gimpactmeshshapepart shape0, gimpactmeshshapepart shape1, intarraylist pairs, int pair_count) { } use this function for register the algorithm externally. gimpact.sourceforge.net/ specialized function #ifdef bullet_triangle_collision collide_gjk_triangles(body0,body1,shapepart0,shapepart1,&pairset[0].m_index1,pairset.size()); #else #endif general function collide two convex shapes #ifdef gimpact_vs_plane_collision #endif collide two shapes restore transforms collide child shape restore transforms create the callback getting the trimesh aabb convex_algorithm.destroy(); triface0 = pairs.get(pair_pointer); triface1 = pairs.get(pair_pointer + 1); pair_pointer += 2; #ifdef tri_collision_profiling bt_begin_gim02_tri_time(); #endif build planes test conservative #ifdef tri_collision_profiling bt_end_gim02_tri_time(); #endif post : checkmanifold is called algor.destroy(); test box against plane add contact //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.extras.gimpact.GImpactMassUtil "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.GImpactMeshShape "gimpact.sourceforge.net/ #ifdef calc_exact_inertia //#else  // calc box inertia  btscalar lx= m_localaabb.m_max[0] - m_localaabb.m_min[0]; btscalar ly= m_localaabb.m_max[1] - m_localaabb.m_min[1]; btscalar lz= m_localaabb.m_max[2] - m_localaabb.m_min[2]; const btscalar x2 = lxlx; const btscalar y2 = lyly; const btscalar z2 = lzlz; const btscalar scaledmass = mass btscalar(0.08333333);  inertia = scaledmass (btvector3(y2+z2,x2+z2,x2+y2)); //#endif"
com.bulletphysics.extras.gimpact.GImpactMeshShapePart "this class manages a sub part of a mesh supplied by the stridingmeshinterface interface. - simply create this shape by passing the stridingmeshinterface to the constructor gimpactmeshshapepart, then you must call updatebound() after creating the mesh - when making operations with this shape, you must call lock before accessing to the trimesh primitives, and then call unlock - you can handle deformable meshes with this shape, by calling postupdate() every time when changing the mesh vertices. gimpact.sourceforge.net/ #define calc_exact_inertia 1 #ifdef calc_exact_inertia #else  // calc box inertia  float lx= localaabb.max.x - localaabb.min.x; float ly= localaabb.max.y - localaabb.min.y; float lz= localaabb.max.z - localaabb.min.z; float x2 = lxlx; float y2 = lyly; float z2 = lzlz; float scaledmass = mass 0.08333333f;  inertia.set(y2+z2,x2+z2,x2+y2); inertia.scale(scaledmass);  #endif"
com.bulletphysics.extras.gimpact.GImpactShapeInterface "base class for gimpact shapes. performs refit operation. updates the entire box set of this shape. postupdate() must be called for attemps to calculating the box set, else this function will does nothing. if m_needs_update == true, then it calls calclocalaabb(); if the bounding box is not updated, then this class attemps to calculate it. calls updatebound() for update the box set. tells to this object that is needed to refit the box set. obtains the local box, which is the global calculated box of the total of subshapes. you must call updatebound() for update the box set. base method for determinig which kind of gimpact shape we get. determines if this class has a hierarchy structure for sorting its primitives. obtains the primitive manager. gets the number of children. if true, then its children must get transforms. determines if this shape has triangles. determines if this shape has tetrahedrons. call when reading child shapes. if this trimesh. use this function for perfofm refit in bounding boxes. retrieves the bound from a child. gets the children. gets the children transform. sets the children transform. you must call updatebound() for update the box set. virtual method for ray collision. function for retrieve triangles. it gives the triangles in local space. gimpact.sourceforge.net/ optionally boxset"
com.bulletphysics.extras.gimpact.GImpactTriangleCallback "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.package-info "provides support for moving concave triangle meshes. www.bulletphysics.com/"
com.bulletphysics.extras.gimpact.Pair "overlapping pair. gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.PairSet "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.PlaneIntersectionType "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.PlaneShape "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.PrimitiveManagerBase "prototype base class for primitive classification. this class is a wrapper for primitive collections. this tells relevant info for the bounding box set classes, which take care of space classification. this class can manage compound shapes and trimeshes, and if it is managing trimesh then the hierarchy bounding box classes will take advantage of primitive vs box overlapping tests for getting optimal results and less per box compairisons. determines if this manager consist on only triangles, which special case will be optimized. retrieves only the points of the triangle, and the collision margin. gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.PrimitiveTriangle "test if triangles could collide. calcs the plane which is paralele to the edge and perpendicular to the triangle plane. this triangle must have its plane calculated. clips the triangle against this. _points must have max_tri_clipping size, and this triangle must have its plane calculated. number of clipped points find collision using the clipping method. this triangle and other must have their triangles calculated. gimpact.sourceforge.net/ classify points on other triangle classify points on this triangle edge 0 edge 1 edge 2 create planes plane v vs u points reject find most deep interval face1 too far normal pointing to this triangle clip tri1 by tri2 edges reject find most deep interval face1 too far check most dir for contacts"
com.bulletphysics.extras.gimpact.Quantization "gimpact.sourceforge.net/ enlarge the aabb to avoid division by zero when initializing the quantization values"
com.bulletphysics.extras.gimpact.ShapeType "gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.TetrahedronShapeEx "helper class for tetrahedrons. gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.TriangleContact "classify points that are closer. gimpact.sourceforge.net/"
com.bulletphysics.extras.gimpact.TriangleShapeEx "gimpact.sourceforge.net/ classify points on other triangle classify points on this triangle"
com.bulletphysics.extras.gimpact.TrimeshPrimitiveManager "gimpact.sourceforge.net/"
com.bulletphysics.linearmath.AabbUtil2 "utility functions for axis aligned bounding boxes (aabb). conservative test for overlap between two aabbs. conservative test for overlap between triangle and aabb. www.bulletphysics.com/ btsetmin(lambda_exit, lambda);"
com.bulletphysics.linearmath.Clock "clock is a portable basic clock that measures accurate time in seconds, use for profiling. creates a new clock and resets it. resets clock by setting start time to current. returns the time in milliseconds since the last call to reset or since the clock was returns the time in microseconds since the last call to reset or since the clock was www.bulletphysics.com/"
com.bulletphysics.linearmath.convexhull.HullDesc "describes point cloud data and other input for conversion to polygonal representation. flags to use when generating the convex hull, see {@link hullflags}. number of vertices in the input point cloud. array of vertices. stride of each vertex, in bytes. epsilon value for removing duplicates. this is a normalized value, if normalized bit is on. maximum number of vertices to be considered for the hull. maximum number of faces to be considered for the hull. www.melax.com/"
com.bulletphysics.linearmath.convexhull.HullFlags "flags that affects convex hull generation, used in {@link hulldesc#flags}. www.melax.com/ report results as triangles, not polygons. reverse order of the triangle indices."
com.bulletphysics.linearmath.convexhull.HullLibrary "hulllibrary class can create a convex hull from a collection of vertices, using the computehull method. the {@link shapehull} class uses this hulllibrary to create a approximate convex mesh given a general (non-polyhedral) convex shape. converts point cloud to polygonal representation. describes the input request contains the result conversion was successful release memory allocated for this result, we are done with it. 3 java note: redudant for (int i=0; i<vcount; i++) { usedindices.set(i, 0); } close enough to consider two btscalaring point numbers to be 'the same'. stride stride www.melax.com/ includes modifications/improvements by john ratcliff, see bringoutyourdead below. normalize point cloud, remove duplicates! if ( 1 ) // scale vertices back to their original size. re-index triangle mesh so it refers to only used vertices, rebuild a new vertex table. if he wants the results as triangle! if ( 1 ) int j; isextreme.reserve(verts_count); allow.reserve(verts_count); simplex failed a valid interior point wtf we've already done this vertex if(v==p0 || v==p1 || v==p2 || v==p3) continue; // done these already now check for those degenerate cases where we have a flipped triangle or a really skinny triangle already done that vertex - algorithm needs to be able to terminate. private convexh convexhcrop(convexh convex,plane slice); private convexh test_cube(); bringoutyourdead (john ratcliff): when you create a convex hull you hand it a large input set of vertices forming a 'point cloud'. after the hull is generated it give you back a set of polygon faces which index the original point cloud. the thing is, often times, there are many 'dead vertices' in the point cloud that are on longer referenced by the hull. the routine 'bringoutyourdead' find only the referenced vertices, copies them to an new buffer, and re-indexes the hull so that it is a minimal representation. original array index if already remapped index to new array new index mapping copy old vert to new vert array increment output vert count assign new index remapping output number of vertices location to store the results. if ( 1 ) one centimeter 1/5th the shortest non-zero edge. return cube normalize normalize normalize if ( 1 ) / xxx might be broken ok, it is close enough to the old one now let us see if it is further from the center of the point cloud than the one we already recorded. in which case we keep this one instead. ok..now make sure we didn't prune so many vertices it is now invalid. if ( 1 ) one centimeter 1/5th the shortest non-zero edge. add box ////////////////////////////////////////////////////////////////////////// yuck - this is really ugly return the normal of the triangle inscribed by v0, v1, and v2 epsilon??? xxx, might be broken"
com.bulletphysics.linearmath.convexhull.HullResult "contains resulting polygonal representation. depending on the {@link #polygons} flag, array of indices consists of: for triangles: indices are array indexes into the vertex list for polygons: indices are in the form (number of points in face) (p1, p2, p3, ...) true if indices represents polygons, false indices are triangles. number of vertices in the output hull. array of vertices. number of faces produced. total number of indices. array of indices. www.melax.com/"
com.bulletphysics.linearmath.convexhull.Int3 "www.melax.com/"
com.bulletphysics.linearmath.convexhull.Int4 "www.melax.com/"
com.bulletphysics.linearmath.convexhull.IntRef "www.bulletphysics.com/"
com.bulletphysics.linearmath.convexhull.package-info "convex hull library for converting point clouds to polygonal representation. www.melax.com/"
com.bulletphysics.linearmath.convexhull.PHullResult "www.melax.com/"
com.bulletphysics.linearmath.convexhull.Tri "www.melax.com/"
com.bulletphysics.linearmath.CProfileIterator "real-time hierarchical profiling for game programming gems 3 by greg hjelstrom & byon garrabrant iterator to navigate through profile tree. make the given child the new parent. make the current parent's parent the new parent. www.bulletphysics.com/ access all the children of the current parent public void enterlargestchild(); // make the largest child the new parent access the current child access the current parent"
com.bulletphysics.linearmath.CProfileManager "real-time hierarchical profiling for game programming gems 3 by greg hjelstrom & byon garrabrant manager for the profile system. must be {@link string#intern interned} string (not needed for string literals) delete ( iterator); www.bulletphysics.com/ return will indicate whether we should back up to our parent (we may be profiling a recursive function)"
com.bulletphysics.linearmath.CProfileNode "real-time hierarchical profiling for game programming gems 3 by greg hjelstrom & byon garrabrant a node in the profile hierarchy tree. www.bulletphysics.com/ try to find this sub node we didn't find it, so add it"
com.bulletphysics.linearmath.DebugDrawModes "debug draw modes, used by demo framework. www.bulletphysics.com/"
com.bulletphysics.linearmath.DefaultMotionState "defaultmotionstate provides a common implementation to synchronize world transforms with offsets. current interpolated world transform, used to draw object. center of mass offset transform, used to adjust graphics world transform. initial world transform. creates a new defaultmotionstate with all transforms set to identity. creates a new defaultmotionstate with initial world transform and center of mass offset transform set to identity. creates a new defaultmotionstate with initial world transform and center of mass offset transform. www.bulletphysics.com/"
com.bulletphysics.linearmath.GeometryUtil "geometryutil helper class provides a few methods to convert between plane equations and vertices. www.bulletphysics.com/ brute force: check if inside, and replace supportingvertexout if needed brute force: point p out of 3 plane equations: d1 ( n2 n3 ) + d2 ( n3 n1 ) + d3 ( n1 n2 ) p = ------------------------------------------------------------------------- n1 . ( n2 n3 ) check if inside, and replace supportingvertexout if needed"
com.bulletphysics.linearmath.IDebugDraw "idebugdraw interface class allows hooking up a debug renderer to visually debug simulations. typical use case: create a debug drawer object, and assign it to a {@link collisionworld} or {@link dynamicsworld} using setdebugdrawer and call debugdrawworld. a class that implements the idebugdraw interface has to implement the drawline method at a minimum. www.bulletphysics.com/ protected final bulletstack stack = bulletstack.get();"
com.bulletphysics.linearmath.MatrixUtil "utility functions for matrices. sets rotation matrix from euler angles. the euler angles are applied in zyx order. this means a vector is first rotated about x then y and then z axis. diagonalizes this matrix by the jacobi method. rot stores the rotation from the coordinate system in which the matrix is diagonal to the original coordinate system, i.e., old_this = rot new_this rot^t. the iteration stops when all off-diagonal elements are less than the threshold multiplied by the sum of the absolute values of the diagonal, or when maxsteps have been executed. note that this matrix is assumed to be symmetric. www.bulletphysics.com/ java note: diagonalize method from 2.71 find off-diagonal element [p][q] with largest magnitude compute jacobi rotation j which leads to a zero for element [p][q] approximation for large theta-value, i.e., a nearly diagonal matrix apply rotation to matrix (this = j^t this j) apply rotation to rot (rot = rot j)"
com.bulletphysics.linearmath.MiscUtil "miscellaneous utility functions. ensures valid index in provided list by filling list with provided values until the index is valid. resizes list to exact size, filling with given value when expanding. resizes list to exact size, filling with given value when expanding. resizes list to exact size, filling with new instances of given class type when expanding. searches object in array. index of match, or -1 when not found pre: a[k+1..n] is a heap post: a[k..n] is a heap k has child(s) pick larger child move child up sorts list using heap sort. implementation from: http://www.csse.monash.edu.au/~lloyd/tildealgds/sort/heap/ sort a[0..n-1], n.b. 0 to n-1 a[1..n] is now a heap largest of a[0..n-1] restore a[1..i-1] heap sorts list using quick sort. www.bulletphysics.com/ www.csse.monash.edu.au/~lloyd/tildealgds/sort/heap/ don't sort 0 or 1 elements lo is the lower index, hi is the upper index of the region of array a that is to be sorted partition recursion"
com.bulletphysics.linearmath.MotionState "motionstate allows the dynamics world to synchronize the updated world transforms with graphics. for optimizations, potentially only moving objects get synchronized (using {@link #setworldtransform setworldtransform} method). returns world transform. sets world transform. this method is called by jbullet whenever an active object represented by this motionstate is moved or rotated. www.bulletphysics.com/"
com.bulletphysics.linearmath.package-info "vector math library. www.bulletphysics.com/"
com.bulletphysics.linearmath.QuaternionUtil "utility functions for quaternions. www.bulletphysics.com/ game programming gems 2.10. make sure v0,v1 are normalized just pick any vector"
com.bulletphysics.linearmath.ScalarUtil "utility functions for scalars (floats). www.bulletphysics.com/"
com.bulletphysics.linearmath.Transform "transform represents translation and rotation (rigid transform). scaling and shearing is not supported. you can use local shape scaling or {@link uniformscalingshape} for static rescaling of collision objects. rotation matrix of this transform. translation vector of this transform. www.bulletphysics.com/ protected bulletstack stack;"
com.bulletphysics.linearmath.TransformUtil "utility functions for transforms. reciprocal square root www.bulletphysics.com/ choose p in y-z plane set q = n x p choose p in x-y plane set q = n x p //#define quaternion_derivative #ifdef quaternion_derivative btquaternion predictedorn = curtrans.getrotation(); predictedorn += (angvel predictedorn) (timestep btscalar(0.5)); predictedorn.normalize(); #else exponential map google for "practical parameterization of rotations using the exponential map", f. sebastian grassia limit the angular motion use taylor's expansions of sync function sync(fangle) = sin(cfangle)/t #endif #ifdef use_quaternion_diff btquaternion orn0 = transform0.getrotation(); btquaternion orn1a = transform1.getrotation(); btquaternion orn1 = orn0.farthest(orn1a); btquaternion dorn = orn1 orn0.inverse(); #else #endif floating point inaccuracy can lead to w component > 1..., which breaks todo: probably not needed axis[3] = btscalar(0.); check for axis length"
com.bulletphysics.linearmath.VectorUtil "utility functions for vectors. www.bulletphysics.com/ don't do the unused w component m_co[3] = s v0[3] + rt v1[3];"
com.bulletphysics.package-info "contains global variables and callbacks. www.bulletphysics.com/"
com.bulletphysics.util.ArrayPool "object pool for arrays. creates object pool. returns array of exactly the same length as demanded, or create one if not present in the pool. returns array that has same or greater length, or create one if not present in the pool. the minimum length required releases array into object pool. previously obtained array from this pool returns per-thread array pool for given type, or create one if it doesn't exist. type pool www.bulletphysics.com/ remove references from object arrays: ////////////////////////////////////////////////////////////////////////// //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.util.FloatArrayList "www.bulletphysics.com/"
com.bulletphysics.util.IntArrayList "www.bulletphysics.com/"
com.bulletphysics.util.ObjectArrayList "www.bulletphysics.com/"
com.bulletphysics.util.ObjectPool "object pool. returns instance from pool, or create one if pool is empty. release instance into pool. previously obtained instance from pool returns per-thread object pool for given type, or create one if it doesn't exist. type pool www.bulletphysics.com/ //////////////////////////////////////////////////////////////////////////"
com.bulletphysics.util.ObjectStackList "stack-based object pool for arbitrary objects, returning not supported. www.bulletphysics.com/"
com.bulletphysics.util.package-info "java-specific utility classes. www.bulletphysics.com/"
com.bulletphysics.util.StackList "stack-based object pool, see the example for usage. you must use the {@link #returning} method for returning stack-allocated instance. example code:  stacklist&lt;vector3f&gt; vectors; ... vectors.push(); try { vector3f vec = vectors.get(); ... return vectors.returning(vec); } finally { vectors.pop(); }  pushes the stack. if (stackcount == stack.length-1) { resizestack(); } pops the stack. returns instance from stack pool, or create one if not present. the returned instance will be automatically reused when {@link #pop} is called. copies given instance into one slot static instance and returns it. it's essential that caller of method (that uses this method for returning instances) immediately copies it into own variable before any other usage. stack-allocated instance slot instance for returning purposes creates a new instance of type. copies data from one instance to another. www.bulletphysics.com/ if (true) return create(); if (true) { t ret = create(); copy(ret, obj); return ret; }"
