#CANONICAL_CLASS_NAME "AUTHOR"
edu.uci.ics.jung.algorithms.blockmodel.StructurallyEquivalent "identifies sets of structurally equivalent vertices in a graph. vertices  i and j are structurally equivalent iff the set of i's neighbors is identical to the set of j's neighbors, with the exception of i and j themselves. this algorithm finds all sets of equivalent vertices in o(v^2) time. you can extend this class to have a different definition of equivalence (by overriding isstructurallyequivalent), and may give it hints for accelerating the process by overriding canpossiblycompare. (for example, in a bipartite graph, canpossiblycompare may return false for vertices in different partitions. this function should be fast.) for each vertex pair v, v1 in g, checks whether v and v1 are fully equivalent: meaning that they connect to the exact same vertices. (is this regular equivalence, or whathaveyou?) returns a set of pairs of vertices, where all the vertices in the inner pairs are equivalent. checks whether a pair of vertices are structurally equivalent. specifically, whether v1's predecessors are equal to v2's predecessors, and same for successors. the graph in which the structural equivalence comparison is to take place 1 the vertex to check for structural equivalence to v2 2 the vertex to check for structural equivalence to v1 this is a space for optimizations. for example, for a bipartite graph, vertices from different partitions cannot possibly be compared. 1 2 jung.sourceforge.net/license.txt for a description. we haven't seen this one before pick up the vertices which don't appear in intermediate; they are singletons (equivalence classes of size 1) this neglects self-loops and directed edges from 1 to other if there's a directed edge v1->v2 then there's a directed edge v2->v1 self-loop check"
edu.uci.ics.jung.algorithms.blockmodel.VertexPartition "maintains information about a vertex partition of a graph. this can be built from a map from vertices to vertex sets or from a collection of (disjoint) vertex sets, such as those creates an instance based on the specified graph and mapping from vertices to vertex sets, and generates a set of partitions based on this mapping. the graph over which the vertex partition is defined _map the mapping from vertices to vertex sets (partitions) creates an instance based on the specified graph, vertex-set mapping, and set of disjoint vertex sets. the vertex-set mapping and vertex partitions must be consistent; that is, the mapping must reflect the division of vertices into partitions, and each vertex must appear in exactly one partition. the graph over which the vertex partition is defined _map the mapping from vertices to vertex sets (partitions) _sets the set of disjoint vertex sets creates an instance based on the specified graph and set of disjoint vertex sets, and generates a vertex-to-partition map based on these sets. the graph over which the vertex partition is defined _sets the set of disjoint vertex sets returns the graph on which the partition is defined. graph on which the partition is defined returns a map from each vertex in the input graph to its partition. this map is generated if it does not already exist. map from each vertex in the input graph to a vertex set returns a collection of vertex sets, where each vertex in the input graph is in exactly one set. this collection is generated based on the vertex-to-partition map if it does not already exist. collection of vertex sets such that each vertex in the instance's graph is in exactly one set returns the number of partitions. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.cluster.BicomponentClusterer "finds all biconnected components (bicomponents) of an undirected graph. a graph is a biconnected component if at least 2 vertices must be removed in order to disconnect the graph. (graphs consisting of one vertex, or of two connected vertices, are also biconnected.) biconnected components of three or more vertices have the property that every pair of vertices in the component are connected by two or more vertex-disjoint paths.  running time: o(|v| + |e|) where |v| is the number of vertices and |e| is the number of edges @see "depth first search and linear graph algorithms by r. e. tarjan (1972), siam j. comp." constructs a new bicomponent finder extracts the bicomponents from the graph. the graph whose bicomponents are to be extracted clusterset of bicomponents stores, in bicomponents, all the biconnected components that are reachable from v. the algorithm basically proceeds as follows: do a depth-first traversal starting from v, marking each vertex with a value that indicates the order in which it was encountered (dfs_num), and with a value that indicates the highest point in the dfs tree that is known to be reachable from this vertex using non-dfs edges (high). (since it is measured on non-dfs edges, "high" tells you how far back in the dfs tree you can reach by two distinct paths, hence biconnectivity.) each time a new vertex w is encountered, push the edge just traversed on a stack, and call this method recursively. if w.high is no greater than v.dfs_num, then the contents of the stack down to (v,w) is a biconnected component (and v is an articulation point, that is, a component boundary). in either case, set v.high to max(v.high, w.high), and continue. if w has already been encountered but is not v's parent, set v.high max(v.high, w.dfs_num) and continue. (in case anyone cares, the version of this algorithm on p. 224 of udi manber's "introduction to algorithms: a creative approach" seems to be wrong: the stack should be initialized outside this method, (v,w) should only be put on the stack if w hasn't been seen already, and there's no real benefit to putting v on the stack separately: just check for (v,w) on the stack rather than v. had i known this, i could have saved myself a few days. jrtom) jung.sourceforge.net/license.txt for a description. initialize dfs number for each vertex to 0 if we haven't hit this vertex yet... find the biconnected components for this subgraph, starting from v if we only visited one vertex, this method won't have id'd it as a biconnected component, so mark it as one get(w, dfs_num); w hasn't yet been visited v is w's parent in the dfs tree get(w, high); v disconnects w from the rest of the graph, i.e., v is an articulation point thus, everything between the top of the stack and v is part of a single biconnected component (v,w) is a back or a forward edge"
edu.uci.ics.jung.algorithms.cluster.EdgeBetweennessClusterer "an algorithm for computing clusters (community structure) in graphs based on edge betweenness. the betweenness of an edge is defined as the extent to which that edge lies along shortest paths between all pairs of nodes. this algorithm works by iteratively following the 2 step process:   compute edge betweenness for all edges in current graph  remove edge with highest betweenness   running time is: o(kmn) where k is the number of edges to remove, m is the total number of edges, and n is the total number of vertices. for very sparse graphs the running time is closer to o(kn^2) and for graphs with strong community structure, the complexity is even lower.  this algorithm is a slight modification of the algorithm discussed below in that the number of edges to be removed is parameterized. constructs a new clusterer for the specified graph. the number of edges to be progressively removed from the graph finds the set of clusters which have the strongest "community structure". the more edges removed the smaller and more cohesive the clusters. the graph retrieves the list of all edges that were removed (assuming extract(...) was previously called). the edges returned are stored in order in which they were removed. edges in the original graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.cluster.VoltageClusterer "clusters vertices of a graph based on their ranks as calculated by voltagescorer. this algorithm is based on, but not identical with, the method described in the paper below. the primary difference is that wu and huberman assume a priori that the clusters are of approximately the same size, and therefore use a more complex method than k-means (which is used here) for determining cluster membership based on co-occurrence data. the algorithm proceeds as follows:  first, generate a set of candidate clusters as follows:  pick (widely separated) vertex pair, run voltagescorer group the vertices in two clusters according to their voltages store resulting candidate clusters  second, generate k-1 clusters as follows:  pick a vertex v as a cluster 'seed' (wu/huberman: most frequent vertex in candidate clusters) calculate co-occurrence over all candidate clusters of v with each other vertex separate co-occurrence counts into high/low; high vertices constitute a cluster remove v's vertices from candidate clusters; continue  finally, remaining unassigned vertices are assigned to the kth ("garbage") cluster.  note: depending on how the co-occurrence data splits the data into clusters, the number of clusters returned by this algorithm may be less than the number of clusters requested. the number of clusters will never be more than the number requested, however. creates an instance of a voltagecluster with the specified parameters. these are mostly parameters that are passed directly to voltagescorer and kmeansclusterer. _candidates the number of candidate clusters to create returns a community (cluster) centered around v. the vertex whose community we wish to discover clusters the vertices of g into num_clusters clusters, based on their connectivity. _clusters the number of clusters to identify does the work of getcommunity and cluster. the vertex around which clustering is to be done _clusters the (maximum) number of clusters to find do k-means with three intervals and pick the smaller two clusters (presumed to be on the ends); this is closer to the wu-huberman method. _ranks alternative to addtwocandidateclusters(): cluster vertices by voltages into 2 clusters. we only consider the smaller of the two clusters returned by k-means to be a 'true' cluster candidate; the other is a garbage cluster. _ranks returns an array of cluster seeds, ranked in decreasing order of number of appearances in the specified collection of candidate clusters. jung.sourceforge.net/license.txt for a description. www.hpl.hp.com/research/idl/papers/linear/" generate candidate clusters repeat the following 'samples' times: pick (widely separated) vertex pair, run voltagescorer use k-means to identify 2 communities in ranked graph store resulting candidate communities addonecandidatecluster(candidates, voltage_ranks); repeat the following k-1 times: pick a vertex v as a cluster seed (wu/huberman: most frequent vertex in candidates) calculate co-occurrence (in candidate clusters) of this vertex with all others use k-means to separate co-occurrence counts into high/low; high vertices are a cluster remove v's vertices from candidate clusters now that we have the counts, cluster them... ...get the cluster with the highest-valued centroid... ...remove the elements of new_cluster from each candidate... all remaining vertices are in the same cluster identify remaining vertices (if any) as a 'garbage' cluster no valid candidates, continue no valid candidates, continue"
edu.uci.ics.jung.algorithms.cluster.WeakComponentClusterer "finds all weak components in a graph as sets of vertex sets. a weak component is defined as a maximal subgraph in which all pairs of vertices in the subgraph are reachable from one another in the underlying undirected subgraph. this implementation identifies components as sets of vertex sets. to create the induced graphs from any or all of these vertex sets, see algorithms.filters.filterutils.  running time: o(|v| + |e|) where |v| is the number of vertices and |e| is the number of edges. extracts the weak components from a graph. the graph whose weak components are to be extracted list of weak components jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.filters.EdgePredicateFilter "transforms the input graph into one which contains only those edges that pass the specified predicate. the filtered graph is a copy of the original graph (same type, uses the same vertex and edge objects). all vertices from the original graph are copied into the new graph (even if they are not incident to any edges in the new graph). creates an instance based on the specified edge predicate. _pred the predicate that specifies which edges to add to the filtered graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.filters.Filter "an interface for classes that return a subset of the input graph as a graph. the graph returned may be either a new graph or a view into an existing graph; the documentation for the filter must specify which. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.filters.FilterUtils "utility methods relating to filtering. creates the induced subgraph from graph whose vertex set is equal to vertices. the graph returned has vertices as its vertex set, and includes all edges from graph which are incident only to elements of vertices.  the vertex type  the edge type the subset of graph's vertices around which the subgraph is to be constructed the graph whose subgraph is to be constructed subgraph induced by vertices @throws illegalargumentexception if any vertex in vertices is not in graph creates the induced subgraphs of graph associated with each element of vertex_collections. note that these vertex collections need not be disjoint.  the vertex type  the edge type _collections the collections of vertex collections to be used to induce the subgraphs the graph whose subgraphs are to be jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.filters.KNeighborhoodFilter "a filter used to extract the k-neighborhood around one or more root node(s). the k-neighborhood is defined as the subgraph induced by the set of vertices that are k or fewer hops (unweighted shortest-path distance) away from the root node. the type of edge to follow for defining the neighborhood. constructs a new instance of the filter. the set of root nodes the neighborhood radius around the root set 0 for in/out edges, 1 for in-edges, 2 for out-edges constructs a new instance of the filter. the root node the neighborhood radius around the root set 0 for in/out edges, 1 for in-edges, 2 for out-edges constructs an unassembled graph containing the k-neighborhood around the root node(s). jung.sourceforge.net/license.txt for a description. generate a set of vertices we want add all to the ug copy, mark, and add all the root nodes to the new subgraph use bfs to locate the neighborhood around the root nodes within distance k"
edu.uci.ics.jung.algorithms.filters.VertexPredicateFilter "transforms the input graph into one which contains only those vertices that pass the specified predicate. the filtered graph is a copy of the original graph (same type, uses the same vertex and edge objects). only those edges whose entire incident vertex collection passes the predicate are copied into the new graph. creates an instance based on the specified vertex predicate. _pred the predicate that specifies which vertices to add to the filtered graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.flows.EdmondsKarpMaxFlow "implements the edmonds-karp maximum flow algorithm for solving the maximum flow problem. after the algorithm is executed, the input {@code map} is populated with a {@code number} for each edge that indicates the flow along that edge.  an example of using this algorithm is as follows:  edmondskarpmaxflow ek = new edmondskarpmaxflow(graph, source, sink, edge_capacities, edge_flows, edge_factory); ek.evaluate(); // this instructs the class to compute the max flow  @see "introduction to algorithms by cormen, leiserson, rivest, and stein." @see "network flows by ahuja, magnanti, and orlin." @see "theoretical improvements in algorithmic efficiency for network flow problems by edmonds and karp, 1972." constructs a new instance of the algorithm solver for a given graph, source, and sink. source and sink vertices must be elements of the specified graph, and must be distinct. the flow graph the source vertex the sink vertex the transformer that gets the capacity for each edge. the map where the solver will place the value of the flow for each edge used to create new edge instances for backedges returns the value of the maximum flow from the source to the sink. returns the nodes which share the same partition (as defined by the min-cut edges) as the sink node. returns the nodes which share the same partition (as defined by the min-cut edges) as the source node. returns the edges in the minimum cut. returns the graph for which the maximum flow is calculated. jung.sourceforge.net/license.txt for a description. this instructs the class to compute the max flow return 0;"
edu.uci.ics.jung.algorithms.generators.EvolvingGraphGenerator "an interface for algorithms that generate graphs that evolve iteratively. instructs the algorithm to evolve the graph n steps. number of steps to iterate from the current state retrieves the total number of steps elapsed. of elapsed steps jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.generators.GraphGenerator "an interface for algorithms that generate graphs. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.generators.Lattice2DGenerator "simple generator of an m x n lattice where each vertex is incident with each of its neighbors (to the left, right, up, and down). may be toroidal, in which case the vertices on the edges are connected to their counterparts on the opposite edges as well. if the graph factory supplied has a default edge type of {@code edgetype.directed}, then edges will be constructs a generator of square lattices of size {@code latticesize} with the specified parameters. _factory used to create the {@code graph} for the lattice _factory used to create the lattice vertices _factory used to create the lattice edges the number of rows and columns of the lattice if true, the creates a generator of {@code row_count} x {@code col_count} lattices with the specified parameters. _factory used to create the {@code graph} for the lattice _factory used to create the lattice vertices _factory used to create the lattice edges _count the number of rows in the lattice _count the number of columns in the lattice if true, the @see edu.uci.ics.jung.algorithms.generators.graphgenerator#create() returns the number of edges found in a lattice of this generator's specifications. (this is useful for subclasses that may modify the generated graphs to add more edges.) returns the vertex at position ({@code i mod row_count, j mod col_count}). returns the {@code i}th vertex (counting row-wise). returns the row in which vertex {@code i} is found. returns the column in which vertex {@code i} is found. jung.sourceforge.net/license.txt for a description. fill in edges down right if the graph is directed, fill in the edges going the other direction... up left"
edu.uci.ics.jung.algorithms.generators.random.BarabasiAlbertGenerator "simple evolving scale-free random graph generator. at each time step, a new vertex is constructs a new instance of the generator. _vertices number of unconnected 'seed' vertices that the graph should start with the number of edges that should be attached from the new vertex to pre-existing vertices at each time step specifies whether the graph and edges to be constructs a new instance of the generator, whose output will be an undirected graph, and which will use the current time as a seed for the random number generation. _vertices number of vertices that the graph should start with the number of edges that should be attached from the new vertex to pre-existing vertices at each time step jung.sourceforge.net/license.txt for a description. if parallel edges are not allowed, skip attach_point if  already exists; note that because of the way edges are added, we only need to check the list of candidate edges for duplicates. subtract 1 from numvertices because we don't want to count newvertex (which has already been added to the graph, but not to vertex_index) generate and store the new edges; don't add them to the graph yet because we don't want to bias the degree calculations (all new edges in a timestep should be added in parallel) now that we're done attaching edges to this new vertex, add it to the index"
edu.uci.ics.jung.algorithms.generators.random.EppsteinPowerLawGenerator "graph generator that generates undirected graphs with power-law degree distributions. creates an instance with the specified factories and specifications. the factory to use to generate the graph the factory to use to create vertices the factory to use to create edges the number of vertices for the generated graph the number of edges the generated graph will have, should be theta(numvertices) the number of iterations to use; the larger the value the better the graph's degree distribution will approximate a power-law generates a graph whose degree distribution approximates a power-law. generated graph sets the seed for the random number generator. input to the random number generator. jung.sourceforge.net/license.txt for a description. (maxdegree+1)(maxdegree)/2; fixme: look at email thread on a more efficient rng for arbitrary distributions"
edu.uci.ics.jung.algorithms.generators.random.ErdosRenyiGenerator "generates a random graph using the erdos-renyi binomial model (each pair of vertices is connected with probability p). number of vertices graph should have connection's probability between 2 vertices returns a graph in which each pair of vertices is connected by an undirected edge with the probability specified by the constructor. sets the seed of the internal random number generator to {@code seed}. enables consistent behavior. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.generators.random.KleinbergSmallWorldGenerator "graph generator that produces a random graph with small world properties. the underlying model is an mxn (optionally toroidal) lattice. each node u has four local connections, one to each of its neighbors, and in addition 1+ long range connections to some node v where v is chosen randomly according to probability proportional to d^-alpha where d is the lattice distance between u and v and alpha is the clustering exponent. @see "navigation in a small world j. kleinberg, nature 406(2000), 845." creates _factory _factory _factory _factory _factory _factory _count _count _factory _factory _factory _count _count sets the {@code random} instance used by this instance. useful for unit testing. sets the seed of the internal random number generator. may be used to provide repeatable experiments. sets the number of new 'small-world' connections (outgoing edges) to be added to each vertex. returns the number of new 'small-world' connections to be made to each vertex. generates a random small world network according to the parameters given random small world graph jung.sourceforge.net/license.txt for a description. todo: for toroidal graphs, we can make this more clever by pre-creating the weightedchoice object and using the output as an offset to the current vertex location. add long range connections"
edu.uci.ics.jung.algorithms.generators.random.MixedRandomGraphGenerator "generates a mixed-mode random graph based on the output of barabasialbertgenerator. primarily intended for providing a heterogeneous sample graph for visualization testing, etc. equivalent to generatemixedrandomgraph(edge_weight, num_vertices, true). returns a random mixed-mode graph. starts with a randomly generated barabasi-albert (preferential attachment) generator (4 initial vertices, 3 edges added at each step, and num_vertices - 4 evolution steps). then takes the resultant graph, replaces random undirected edges with directed edges, and assigns random weights to each edge. jung.sourceforge.net/license.txt for a description. false, parallel, create a sparsemultigraph version of g new sparsemultigraph(); randomly replace some of the edges by directed edges to get a mixed-mode graph, add random weights"
edu.uci.ics.jung.algorithms.importance.AbstractRanker "abstract class for algorithms that rank nodes or edges by some "importance" metric. provides a common set of services such as:   storing rank scores  getters and setters for rank scores  computing default edge weights  normalizing default or rankscores rankscores returns true if this ranker ranks nodes, and false otherwise. returns true if this ranker ranks edges, and false otherwise. instructs the ranker whether or not it should remove the rank scores from the nodes (or edges) once the ranks have been computed. true if the rank scores are to be removed, false otherwise the retrieves the list of ranking instances in descending sorted order by rank score if the algorithm is ranking edges, the instances will be of type edgeranking, otherwise if the algorithm is ranking nodes the instances will be of type noderanking the list of rankings return a list of the top k rank scores. the value of k to use of rank scores given an edge or node, returns the corresponding rank score. this is a default implementation of getrankscore which assumes the decorations are of type mutabledouble. this method only returns legal values if setremoverankscoresonfinalize(false) was called prior to evaluate(). the rank score value edgeweights print the rankings to standard out in descending order of rank score if true, include information about the actual rank order as well as the original position of the vertex before it was ranked if true, include the actual value of the rank score allows the jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.BetweennessCentrality "computes betweenness centrality for each vertex and edge in the graph. the result is that each vertex and edge has a constructor which initializes the algorithm the graph whose nodes are to be analyzed the jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.KStepMarkov "algorithm variant of pagerankwithpriors that computes the importance of a node based upon taking fixed-length random walks out from the root set and then computing the stationary probability of being at each node. specifically, it computes the relative probability that the markov chain will spend at any particular node, given that it start in the root set and ends after k steps.  a simple example of usage is:  kstepmarkov ranker = new kstepmarkov(somegraph,rootset,6,null); ranker.evaluate(); ranker.printrankings();   construct the algorihm instance and initializes the algorithm. the graph to be analyzed the set of root nodes positive integer parameter which controls the relative tradeoff between a distribution "biased" towards r and the steady-state distribution which is independent of where the markov-process started. generally values between 4-8 are reasonable the weight for each edge the jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.MarkovCentrality "@see edu.uci.ics.jung.algorithms.importance.abstractranker#getrankscorekey() @see edu.uci.ics.jung.algorithms.importance.abstractranker#getvertexrankscore(object) @see edu.uci.ics.jung.algorithms.util.iterativeprocess#step() loads the stationary distribution into a vector if it was passed in, or calculates it if not. 1d jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.RandomWalkBetweenness "computes betweenness centrality for each vertex in the graph. the betweenness values in this case are based on random walks, measuring the expected number of times a node is traversed by a random walk averaged over all pairs of nodes. the result is that each vertex has a constructor which initializes the algorithm the graph whose nodes are to be analyzed the jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.RandomWalkSTBetweenness "/ computes s-t betweenness centrality for each vertex in the graph. the betweenness values in this case are based on random walks, measuring the expected number of times a node is traversed by a random walk from s to t. the result is that each vertex has a constructor which initializes the algorithm the graph whose nodes are to be analyzed the source vertex the target vertex the jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.Ranking "abstract data container for ranking objects. stores common data relevant to both node and edge rankings, namely, the original position of the instance in the list and the actual ranking score. the original (0-indexed) position of the instance being ranked the actual rank score (normally between 0 and 1) what is being ranked constructor which allows values to be set on construction the original (0-indexed) position of the instance being ranked the actual rank score (normally between 0 and 1) compares two ranking based on the rank score. the other ranking -1 if the other ranking is higher, 0 if they are equal, and 1 if this ranking is higher returns the rank score as a string. stringified rank score ranked the ranked to set jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.RelativeAuthorityRanker "this class provides basic infrastructure for relative the default key used for the cleans up all of the prior rank scores on finalize. retrieves the value of the prior rank score. the root node (prior) prior rank score allows the retrieves the set of priors. set of root nodes (priors) specifies which vertices are root nodes (priors). the root nodes jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.importance.WeightedNIPaths "this algorithm measures the importance of nodes based upon both the number and length of disjoint paths that lead to a given node from each of the nodes in the root set. specifically the formula for measuring the importance of a node is given by: i(t|r) = sum_i=1_|p(r,t)|_{alpha^|p_i|} where alpha is the path decay coefficient, p_i is path i and p(r,t) is a set of maximum-sized node-disjoint paths from r to t.  this algorithm uses heuristic breadth-first search to try and find the maximum-sized set of node-disjoint paths between two nodes. as such, it is not guaranteed to give exact answers.  a simple example of usage is:  weightednipaths ranker = new weightednipaths(somegraph,2.0,6,rootset); ranker.evaluate(); ranker.printrankings();  constructs and initializes the algorithm. the graph whose nodes are being measured for their importance the path decay coefficient (>= 1); 2 is recommended the maximal depth to search out from the root set the root set (starting vertices) given a node, returns the corresponding rank score. this implementation of getrankscore assumes the decoration representing the rank score is of type mutabledouble. the rank score for this node jung.sourceforge.net/license.txt for a description.  iterator sourceedgeit = edges.iterator(); sourceedgeit.hasnext();) { from the currentsourceedge, get its opposite end then iterate over the out edges of that opposite end currentsourceedge.getsource()) { return 0;"
edu.uci.ics.jung.algorithms.layout.AbstractLayout "abstract class for implementations of {@code layout}. it handles some of the basic functions: storing coordinates, maintaining the dimensions, initializing the locations, maintaining locked vertices. a set of vertices that should not move in relation to the other vertices creates an instance which does not initialize the vertex locations. the graph for which the layout algorithm is to be when a visualization is resized, it presumably wants to fix the locations of the vertices and possibly to reinitialize its data. the current method calls initializelocations followed by initialize_local. returns the current size of the visualization space, accoring to the last call to resize(). current size of the screen returns the coordinates object that stores the vertex' x and y location. a vertex that is a part of the graph being visualized. coordinates object with x and y locations. returns the x coordinate of the vertex from the coordinates object. in most cases you will be better off calling transform(v). returns the y coordinate of the vertex from the coordinates object. in most cases you will be better off calling transform(v).  accessor for the graph that represets all vertices. graph that contains all vertices. forcibly moves a vertex to the (x,y) location by setting its x and y locations to the inputted location. does not add the vertex to the "dontmove" list, and (in the default implementation) does not make any adjustments to the rest of the graph. locks {@code v} in place if {@code state} is {@code true}, otherwise unlocks it. locks all vertices in place if {@code lock} is {@code true}, otherwise unlocks all vertices. jung.sourceforge.net/license.txt for a description. now, move each vertex to be at the new screen center"
edu.uci.ics.jung.algorithms.layout.AggregateLayout "a {@code layout} implementation that combines multiple other layouts so that they may be manipulated as one layout. the relaxer thread will step each layout in sequence. creates an instance backed by the specified {@code delegate}. delegate the delegate to set adds the passed layout as a sublayout, also specifying the center of where this sublayout should appear returns the center of the passed layout. center of the passed layout removes {@code layout} from this instance. removes all layouts from this instance. returns the graph for which this layout is defined. graph for which this layout is defined @see edu.uci.ics.jung.algorithms.layout.layout#getgraph() returns the size of the underlying layout. size of the underlying layout @see edu.uci.ics.jung.algorithms.layout.layout#getsize() @see edu.uci.ics.jung.algorithms.layout.layout#initialize() override to test if the passed vertex is locked in any of the layouts. if v is locked in any of the layouts, and false otherwise @see edu.uci.ics.jung.algorithms.layout.layout#islocked(java.lang.object) override to lock or unlock this vertex in any layout with a subgraph containing it @see edu.uci.ics.jung.algorithms.layout.layout#lock(java.lang.object, boolean) @see edu.uci.ics.jung.algorithms.layout.layout#reset() @see edu.uci.ics.jung.algorithms.layout.layout#setgraph(edu.uci.ics.jung.graph.graph) @see edu.uci.ics.jung.algorithms.layout.layout#setinitializer(org.apache.commons.collections15.transformer) @see edu.uci.ics.jung.algorithms.layout.layout#setlocation(java.lang.object, java.awt.geom.point2d) @see edu.uci.ics.jung.algorithms.layout.layout#setsize(java.awt.dimension) returns a map from each {@code layout} instance to its center point. returns the location of the vertex. the location is specified first by the sublayouts, and then by the base layout if no sublayouts operate on this vertex. location of the vertex @see org.apache.commons.collections15.transformer#transform(java.lang.object) check all sublayouts.keyset() and the delegate layout, returning done == true iff all are done. call step on any sublayout that is also an iterativecontext and is not done jung.sourceforge.net/license.txt for a description. transform by the layout itself, but offset to the center of the sublayout transform by the layout itself, but offset to the center of the sublayout"
edu.uci.ics.jung.algorithms.layout.BalloonLayout "a {@code layout} implementation that assigns positions to {@code tree} or {@code forest} vertices using associations with nested circles ("balloons"). a balloon is nested inside another balloon if the first balloon's subtree is a subtree of the second balloon's subtree. creates an instance based on the input forest. returns the coordinates of {@code v}'s parent, or the center of this layout's area if it's a root. radii jung.sourceforge.net/license.txt for a description. its a tree its a forest handle the 1-child case with 0 limit on angle."
edu.uci.ics.jung.algorithms.layout.CircleLayout "a {@code layout} implementation that positions vertices equally spaced on a regular circle. creates an instance for the specified graph. returns the radius of the circle. sets the radius of the circle. must be called before {@code initialize()} is called. sets the order of the vertices in the layout according to the ordering specified by {@code comparator}. sets the order of the vertices in the layout according to the ordering of {@code vertex_list}. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.DAGLayout "an implementation of {@code layout} suitable for tree-like directed acyclic graphs. parts of it will probably not terminate if the graph is cyclic! the layout will result in directed edges pointing generally upwards. any vertices with no successors are considered to be level 0, and tend towards the top of the layout. any vertex has a level one greater than the maximum level of all its successors. each vertex has a minimumlevel. any vertex with no successors has minimumlevel of zero. the minimumlevel of any vertex must be strictly greater than the minimumlevel of its parents. (vertex a is a parent of vertex b iff there is an edge from b to a.) typically, a vertex will have a minimumlevel which is one greater than the minimumlevel of its parent's. however, if the vertex has two parents, its minimumlevel will be one greater than the maximum of the parents'. we need to calculate the minimumlevel for each vertex. when we layout the graph, vertices cannot be drawn any higher than the minimumlevel. the graphheight of a graph is the greatest minimumlevel that is used. we will modify the springlayout calculations so that nodes cannot move above their assigned minimumlevel. a bunch of parameters to help work out when to stop quivering. if the meansquarevel(ocity) ever gets below the msv_threshold, then we will start a final cool-down phase of cool_down_increment increments. if the meansquarevel ever exceeds the threshold, we will exit the cool down phase, and continue looking for another opportunity. creates an instance for the specified graph. setroot calculates the level of each vertex in the graph. level 0 is allocated to any vertex with no successors. level n+1 is allocated to any vertex whose successors' maximum level is n. set vertex v to be level 0. a recursive method for allocating the level for each vertex. ensures that all predecessors of v have a level which is at least one greater than the level of v. sets random locations for a vertex within the dimensions of the space. this overrides the method in abstractlayout had to override this one as well, to ensure that setroot() is called. override the movenodes() method from springlayout. the only change we need to make is to make sure that nodes don't float higher than the miny coordinate, as calculated by their minimumlevel. override incrementsaredone so that we can eventually stop. override forcemove so that if someone moves a node, we can re-layout everything. override forcemove so that if someone moves a node, we can re-layout everything. overridden relaxedges. this one reduces the effect of edges between greatly different levels. jung.sourceforge.net/license.txt for a description. simpler than the "pair" technique. how much space do we allow for additional floating at the bottom. set all the levels. dimension d = currentsize; (jy addition: three lines are new) jy added 2 - double the sideways repulsion. jy addition: attract the vertex towards it's minimumlevel height. twice as much at the top. jy addition: keeps nodes from moving any faster than 5 per time unit (jy addition: these two lines replaced 0 with miny) (jy addition: replace height with maxy) (jy addition: if there's only one root, anchor it in the middle-top of the screen) system.out.println("meansquareaccel="+meansquarevel); jy addition. desiredlen = math.pow( 1.1, (v1.degree() + v2.degree()) ); double desiredlen = getlength(e); round from zero, if needed [zero would be bad.]. force factor: optimal length minus actual length, is made smaller as the current actual length gets larger. why? system.out.println("desired : " + getlength( e )); jy addition. if this is an edge which stretches a long way, don't be so concerned about it. f= math.min( 0, f ); the actual movement distance 'dx' is the force multiplied by the distance to go. springedgedata sed = getspringedgedata(e); sed.f = f;"
edu.uci.ics.jung.algorithms.layout.FRLayout "implements the fruchterman-reingold force-directed algorithm for node layout. behavior is determined by the following settable parameters:  attraction multiplier: how much edges try to keep their vertices together repulsion multiplier: how much vertices try to push each other apart maximum iterations: how many iterations this algorithm will use before stopping  each of the first two defaults to 0.75; the maximum number of iterations defaults to 700. @see "fruchterman and reingold, 'graph drawing by force-directed placement'" @see "http://i11www.ilkd.uni-karlsruhe.de/teaching/ss_04/visualisierung/papers/fruchterman91graph.pdf" creates an instance for the specified graph. creates an instance of size {@code d} for the specified graph. sets the attraction multiplier. sets the repulsion multiplier. moves the iteration forward one notch, calculation attraction and repulsion between vertices and edges and cooling the temperature. calculate repulsion calculate attraction sets the maximum number of iterations. this one is an incremental visualization. returns true once the current iteration has passed the maximum count, max_iterations. jung.sourceforge.net/license.txt for a description. i11www.ilkd.uni-karlsruhe.de/teaching/ss_04/visualisierung/papers/fruchterman91graph.pdf" both locked, do nothing if (islocked(v2)) continue;"
edu.uci.ics.jung.algorithms.layout.FRLayout2 "implements the fruchterman-reingold force-directed algorithm for node layout. this is an experimental attempt at optimizing {@code frlayout}; if it is successful it will be folded back into {@code frlayout} (and this class will disappear). behavior is determined by the following settable parameters:  attraction multiplier: how much edges try to keep their vertices together repulsion multiplier: how much vertices try to push each other apart maximum iterations: how many iterations this algorithm will use before stopping  each of the first two defaults to 0.75; the maximum number of iterations defaults to 700. @see "fruchterman and reingold, 'graph drawing by force-directed placement'" @see http://i11www.ilkd.uni-karlsruhe.de/teaching/ss_04/visualisierung/papers/fruchterman91graph.pdf creates an instance for the specified graph. creates an instance of size {@code d} for the specified graph. sets the attraction multiplier. sets the repulsion multiplier. moves the iteration forward one notch, calculation attraction and repulsion between vertices and edges and cooling the temperature. calculate repulsion calculate attraction sets the maximum number of iterations. this one is an incremental visualization. returns true once the current iteration has passed the maximum count, max_iterations. jung.sourceforge.net/license.txt for a description. i11www.ilkd.uni-karlsruhe.de/teaching/ss_04/visualisierung/papers/fruchterman91graph.pdf both locked, do nothing double the offset for v1, as v2 will not be moving in the opposite direction double the offset for v2, as v1 will not be moving in the opposite direction / deltalength; double the offset for v1, as v2 will not be moving in the opposite direction system.out.println("current iteration: " + currentiteration); system.out.println("temperature: " + temperature);"
edu.uci.ics.jung.algorithms.layout.GraphElementAccessor "interface for coordinate-based selection of graph components. returns a vertex which is associated with the location (x,y). this is typically determined with respect to the vertex's location as specified by a layout. returns the vertices contained within {@code rectangle} relative to {@code layout}. returns an edge which is associated with the location (x,y). this is typically determined with respect to the edge's location as specified by a {@code layout}. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.ISOMLayout "implements a self-organizing map layout algorithm, based on meyer's self-organizing graph methods. returns the current number of epochs and execution status, as a string. creates an isomlayout instance for the specified graph g. advances the current positions of the graph elements. this one is an incremental visualization. true is the layout algorithm is incremental, false otherwise returns true if the vertex positions are no longer being updated. currently isomlayout stops updating vertex positions after a certain number of iterations have taken place. true if the vertex position updates have stopped, false otherwise resets the layout iteration count to 0, which allows the layout algorithm to continue updating vertex positions. jung.sourceforge.net/license.txt for a description. factor = 0; //will be set later on temperature = 0.03; initialjumpradius = 100; jumpradius = initialjumpradius; delay = 100; done = true; generate random position in graph space creates a new xy data location get closest vertex to random position jumpradius = (int) factor jumpradius; temperature = factor temperature;"
edu.uci.ics.jung.algorithms.layout.KKLayout "this source is under the same license with jung. http://jung.sourceforge.net/license.txt for a description. implements the kamada-kawai algorithm for node layout. does not respect filter calls, and sometimes crashes when the view changes to it. @see "tomihisa kamada and satoru kawai: an algorithm for drawing general indirect graphs. information processing letters 31(1):7-15, 1989" @see "tomihisa kamada: on visualization of abstract objects and relations. ph.d. dissertation, dept. of information science, univ. of tokyo, dec. 1988." retrieves graph distances between vertices of the visible graph the diameter of the visible graph. in other words, the maximum over all pairs of vertices of the length of the shortest path between a and bf the visible graph. a multiplicative factor which partly specifies the "preferred" length of an edge (l). a multiplicative factor which specifies the fraction of the graph's diameter to be used as the inter-vertex distance between disconnected vertices. creates an instance for the specified graph. creates an instance for the specified graph and distance metric. sets a multiplicative factor which partly specifies the "preferred" length of an edge (l). sets a multiplicative factor that specifies the fraction of the graph's diameter to be used as the inter-vertex distance between disconnected vertices. returns a string with information about the current status of the algorithm. sets the maximum number of iterations. this one is an incremental visualization. returns true once the current iteration has passed the maximum count. shift all vertices so that the center of gravity is located at the center of the screen. (non-javadoc) @see edu.uci.ics.jung.visualization.layout.abstractlayout#setsize(java.awt.dimension) enable or disable gravity point adjusting. returns true if gravity point adjusting is enabled. enable or disable the local minimum escape technique by exchanging vertices. returns true if the local minimum escape technique by exchanging vertices is enabled. determines a step to new position of the vertex m. calculates the gradient of energy function at the vertex m. calculates the energy function e. calculates the energy function e as if positions of the specified vertices are exchanged. jung.sourceforge.net/license.txt for a description. jung.sourceforge.net/license.txt for a description. the ideal length of an edge arbitrary const number distance matrix assign ids to all visible vertices length_factor used to be hardcoded to 0.9 l = 0.75 math.sqrt(height width / n); the node having max deltam firestatechanged(); d2e_dymdxm equals to d2e_dxmdym. < 0"
edu.uci.ics.jung.algorithms.layout.Layout "a generalized interface is a mechanism for returning (x,y) coordinates from vertices. in general, most of these methods are used to both control and get information from the layout algorithm.  initializes fields in the node that may not have been set during the constructor. must be called before the iterations begin. provides initial locations for all vertices. setter for graph returns the full graph (the one that was passed in at construction time) that this layout refers to.   returns the current size of the visualization's space. sets a flag which fixes this vertex in place. vertex returns true if the position of vertex v is locked. set the location of a vertex jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.LayoutDecorator "a pure decorator for the layout interface. intended to be overridden to provide specific behavior decoration creates an instance backed by the specified delegate layout. returns the backing (delegate) layout. sets the backing (delegate) layout. @see edu.uci.ics.jung.algorithms.util.iterativecontext#done() @see edu.uci.ics.jung.algorithms.layout.layout#initialize() @see edu.uci.ics.jung.algorithms.layout.layout#setinitializer(org.apache.commons.collections15.transformer) @see edu.uci.ics.jung.algorithms.layout.layout#setlocation(java.lang.object, java.awt.geom.point2d) @see edu.uci.ics.jung.algorithms.layout.layout#getsize() @see edu.uci.ics.jung.algorithms.layout.layout#getgraph() @see edu.uci.ics.jung.algorithms.layout.layout#transform(object) @see edu.uci.ics.jung.algorithms.util.iterativecontext#done() @see edu.uci.ics.jung.algorithms.layout.layout#lock(object, boolean) @see edu.uci.ics.jung.algorithms.layout.layout#islocked(object) @see edu.uci.ics.jung.algorithms.layout.layout#setsize(dimension) @see edu.uci.ics.jung.algorithms.layout.layout#reset() jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.PolarPoint "represents a point in polar coordinates: distance and angle from the origin. includes conversions between polar and cartesian coordinates (point2d). creates a new instance with radius and angle each 0. creates a new instance with radius {@code radius} and angle {@code theta}. returns the angle for this point. returns the radius for this point. sets the angle for this point to {@code theta}. sets the radius for this point to {@code theta}. returns the result of converting polar to cartesian coordinates. returns the result of converting (theta, radius) to cartesian coordinates. returns the result of converting point to polar coordinates. returns the result of converting (x, y) to polar coordinates. sets the angle and radius of this point to those of {@code p}. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.RadialTreeLayout "a radial layout for tree or forest graphs. creates an instance for the specified graph with default x and y distances. creates an instance for the specified graph and x distance with default y distance. creates an instance for the specified graph, x distance, and y distance. returns the map from vertices to their locations in polar coordinates. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.RadiusGraphElementAccessor "simple implementation of picksupport that returns the vertex or edge that is closest to the specified location. this implementation provides the same picking options that were available in previous versions of abstractlayout. no element will be returned that is farther away than the specified maximum distance. creates an instance with an effectively infinite default maximum distance. creates an instance with the specified default maximum distance. gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provde a more efficient implementation. gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provde a more efficient implementation. temporarily overrides member maxdistance gets the edge nearest to the location of the (x,y) location selected. calls the longer form of the call. gets the edge nearest to the location of the (x,y) location selected, within a distance of maxdistance, iterates through all visible edges and checks their distance from the click. override this method to provide a more efficient implementation. temporarily overrides member maxdistance closest to the click. jung.sourceforge.net/license.txt for a description. could replace all this set stuff with getfrom_internal() etc. get coords calculate location on line closest to (x,y) first, check that v1 and v2 are not coincident.  square of the distance"
edu.uci.ics.jung.algorithms.layout.SpringLayout "the springlayout package represents a visualization of a set of nodes. the springlayout, which is initialized with a graph, assigns x/y locations to each node. when called relax(), the springlayout moves the visualization forward one step. constructor for a springlayout for a raw graph with associated dimension--the input knows how big the graph is. defaults to the unit length function. constructor for a springlayout for a raw graph with associated component. the {@code graph} to lay out _function provides a length for each edge returns the current value for the stretch parameter. @see #setstretch(double) sets the dimensions of the available space for layout to {@code size}. sets the stretch parameter for this instance. this value specifies how much the degrees of an edge's incident vertices should influence how easily the endpoints of that edge can move (that is, that edge's tendency to change its length). the default value is 0.70. positive values less than 1 cause high-degree vertices to move less than low-degree vertices, and values > 1 cause high-degree vertices to move more than low-degree vertices. negative values will have unpredictable and inconsistent results. returns the current value for the node repulsion range. @see #setrepulsionrange(int) sets the node repulsion range (in drawing area units) for this instance. outside this range, nodes do not repel each other. the default value is 100. negative values are treated as their positive equivalents. returns the current value for the edge length force multiplier. @see #setforcemultiplier(double) sets the force multiplier for this instance. this value is used to specify how strongly an edge "wants" to be its default length (higher values indicate a greater attraction for the default length), which affects how much its endpoints move at each timestep. the default value is 1/3. a value of 0 turns off any attempt by the layout to cause edges to conform to the default length. negative values cause long edges to get longer and short edges to get shorter; use at your own risk. relaxation step. moves all nodes a smidge. movement speed, x movement speed, y used for changing the size of the layout in response to a component's size. this one is an incremental visualization for now, we pretend it never finishes. no effect. jung.sourceforge.net/license.txt for a description. round from zero, if needed [zero would be bad.]. the actual movement distance 'dx' is the force multiplied by the distance to go. keeps nodes from moving any faster than 5 per time unit"
edu.uci.ics.jung.algorithms.layout.SpringLayout2 "the springlayout package represents a visualization of a set of nodes. the springlayout, which is initialized with a graph, assigns x/y locations to each node. when called relax(), the springlayout moves the visualization forward one step. constructor for a springlayout for a raw graph with associated dimension--the input knows how big the graph is. defaults to the unit length function. constructor for a springlayout for a raw graph with associated component. the {@code graph} to lay out _function provides a length for each edge relaxation step. moves all nodes a smidge. jung.sourceforge.net/license.txt for a description. int currentcount = currentiteration % this.loopcountmax; system.err.println(averagecounter+" --- vd.dx="+vd.dx+", vd.dy="+vd.dy); system.err.println("averagedelta was "+averagedelta); system.err.println("averagedelta now "+averagedelta); system.err.println(); keeps nodes from moving any faster than 5 per time unit setx(0); setx(width); sety(0); sety(height);"
edu.uci.ics.jung.algorithms.layout.StaticLayout "staticlayout places the vertices in the locations specified by its transformer initializer. vertex locations can be placed in a map and then supplied to this layout as follows:  transformer vertexlocations = transformerutils.maptransformer(map);  creates an instance for the specified graph, locations, and size. creates an instance for the specified graph and locations, with default size. creates an instance for the specified graph and default size; vertex locations are randomly assigned. creates an instance for the specified graph and size. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.TreeLayout "the default horizontal vertex spacing. initialized to 50. the default vertical vertex spacing. initialized to 50. the horizontal vertex spacing. defaults to {@code default_xdist}. the vertical vertex spacing. defaults to {@code default_ydist}. creates an instance for the specified graph with default x and y distances. creates an instance for the specified graph and x distance with default y distance. creates an instance for the specified graph, x distance, and y distance. this method is not supported by this class. the size of the layout is determined by the topology of the tree, and by the horizontal and vertical spacing (optionally set by the constructor). returns the center of this layout's area. jung.sourceforge.net/license.txt for a description. go one level further down"
edu.uci.ics.jung.algorithms.layout.util.RandomLocationTransformer "transforms the input type into a random location within the bounds of the dimension property. this is used as the backing transformer for the lazymap for many layouts, and provides a random location for unmapped vertices the first time they are accessed. creates an instance with the specified size which uses the current time as the random seed. creates an instance with the specified dimension and random seed. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout.util.Relaxer "interface for operating the relax iterations on a layout. execute a loop of steps in a new thread, firing an event after each step. execute a loop of steps in the calling thread, firing no events. make the relaxer thread wait. make the relaxer thread resume. set flags to stop the relaxer thread. sets the sleep time."
edu.uci.ics.jung.algorithms.layout.util.VisRunner "implementation of a relaxer thread for layouts. extracted from the {@code visualizationmodel} in previous versions of jung. how long the relaxer thread pauses between iteration loops. creates an instance for the specified process. relaxerthreadsleeptime the sleep time to set for this thread used for synchronization. jung.sourceforge.net/license.txt for a description. in case its running interrupt the relaxer, in case it is paused or sleeping this should ensure that visrunnerisrunning gets set to false the applet security manager may have prevented this. just sleep for a second to let the thread stop on its own ignore ignore ignore"
edu.uci.ics.jung.algorithms.layout3d.AbstractLayout "implements some of the dirty work of writing a layout algorithm, allowing the a set of vertices that should not move in relation to the other vertices constructor. initializes the current size to be 100x100, both the graph and the showing graph to the argument, and creates the dontmove set. when a visualization is resized, it presumably wants to fix the locations of the vertices and possibly to reinitialize its data. the current method calls initializelocations followed by initialize_local. todo: a better implementation wouldn't destroy the current information, but would either scale the current visualization, or move the nodes toward the new center. initializer, calls intialize_local and initializelocations to start construction process. returns the current size of the visualization space, accoring to the last call to resize(). current size of the screen returns the coordinates object that stores the vertex' x and y location. a vertex that is a part of the graph being visualized. coordinates object with x and y locations. returns the x coordinate of the vertex from the coordinates object. in most cases you will be better off calling getlocation(vertex v); @see edu.uci.ics.jung.visualization.layout.layout#getx(edu.uci.ics.jung.graph.vertex) returns the y coordinate of the vertex from the coordinates object. in most cases you will be better off calling getlocation(vertex v) @see edu.uci.ics.jung.visualization.layout.layout#getx(edu.uci.ics.jung.graph.vertex) a vertex of interest location point of the supplied vertex  accessor for the graph that represets all vertices. graph that contains all vertices. forcibly moves a vertex to the (x,y) location by setting its x and y locations to the inputted location. does not add the vertex to the "dontmove" list, and (in the default implementation) does not make any adjustments to the rest of the graph. adds the vertex to the dontmove list jung.sourceforge.net/license.txt for a description. now, move each vertex to be at the new screen center public point3f getlocation(v v) { return getcoordinates(v); }"
edu.uci.ics.jung.algorithms.layout3d.FRLayout "implements the fruchterman-reingold algorithm for node layout. (non-javadoc) @see edu.uci.ics.jung.visualization.layout.abstractlayout#setsize(java.awt.dimension) moves the iteration forward one notch, calculation attraction and repulsion between vertices and edges and cooling the temperature. calculate repulsion calculate attraction this one is an incremental visualization. returns true once the current iteration has passed the maximum count, max_iterations. jung.sourceforge.net/license.txt for a description. private map frvertexdata = lazymap.decorate(new hashmap(), new factory() { public frvertexdata create() { return new frvertexdata(); }}); && d != null) { if (islocked(v1)) continue; frvertexdata fvd = getfrdata(v); double deltalength = math.max(epsilon, math.sqrt(fvd.disp .dot(fvd.disp))); double newxdisp = fvd.getxdisp() / deltalength math.min(deltalength, temperature); if (double.isnan(newxdisp)) { throw new illegalargumentexception( "unexpected mathematical result in frlayout:calcpositions [xdisp]"); }  double newydisp = fvd.getydisp() / deltalength math.min(deltalength, temperature);   double newzdisp = fvd.getzdisp() / deltalength math.min(deltalength, temperature); system.err.println("deltalength = "+deltalength); system.err.println(v+" was set to "+xyd); xyd.set((float)(xyd.getx()+newxdisp), (float)(xyd.gety()+newydisp), (float)(xyd.getz()+newzdisp)); system.err.println("newxdisp="+newxdisp+",newydisp="+newydisp+",newzdisp="+newzdisp); system.err.println(v+" set to "+xyd); double newxpos = xyd.getx(); if (newxpos  max) { newxpos = max - math.random() borderwidth 2.0; }  double newypos = xyd.gety(); if (newypos  max) { newypos = max - math.random() borderwidth 2.0; }  double newzpos = xyd.getz(); if (newzpos  max) { newzpos = max - math.random() borderwidth 2.0; }  xyd.set((float)newxpos, (float)newypos, (float)newzpos); v v1 = getgraph().getincidentvertices(e).iterator().next(); v v2 = getgraph().getopposite(v1, e); double xdelta = p1.getx() - p2.getx(); double ydelta = p1.gety() - p2.gety(); double zdelta = p1.getz() - p2.getz(); double deltalength = math.max(epsilon, math.sqrt((xdelta xdelta) + (ydelta ydelta))); frvertexdata fvd1 = getfrdata(v1); frvertexdata fvd2 = getfrdata(v2);  fvd1.decrementdisp( (float)((xdelta / deltalength) force), (float)((ydelta / deltalength) force), (float)((zdelta / deltalength) force)); fvd2.incrementdisp( (float)((xdelta / deltalength) force), (float)((ydelta / deltalength) force), (float)((zdelta / deltalength) force)); frvertexdata fvd1 = getfrdata(v1); fvd1.setdisp(0, 0, 0); if (islocked(v2)) continue; double xdelta = p1.getx() - p2.getx(); double ydelta = p1.gety() - p2.gety(); double zdelta = p1.getz() - p2.getz(); double deltalength = math.max(epsilon, math .sqrt((xdelta xdelta) + (ydelta ydelta) + (zdelta zdelta))); fvd1.incrementdisp( (float)((xdelta / deltalength) force), (float)((ydelta / deltalength) force), (float)((zdelta / deltalength) force)); public frvertexdata getfrdata(v v) { return frvertexdata.get(v); } public static class frvertexdata {  private vector3f disp;  public frvertexdata() { initialize(); }  public void initialize() { disp = new vector3f(); }  public double getxdisp() { return disp.getx(); }  public double getydisp() { return disp.gety(); }  public double getzdisp() { return disp.getz(); }  public void setdisp(float x, float y, float z) { disp.set(x,y,z); }  public void incrementdisp(float x, float y, float z) { disp.add(new vector3f(x,y,z)); }  public void decrementdisp(float x, float y, float z) { disp.sub(new vector3f(x,y,x)); } }"
edu.uci.ics.jung.algorithms.layout3d.GraphElementAccessor "interface for coordinate-based selection of graph components. returns a vertex which is associated with the location (x,y). this is typically determined with respect to the vertex's location as specified by a layout. returns an edge which is associated with the location (x,y). this is typically determined with respect to the edge's location as specified by a layout. jung.sourceforge.net/license.txt for a description. e getedge(layout layout, double x, double y);"
edu.uci.ics.jung.algorithms.layout3d.ISOMLayout "implements a self-organizing map layout algorithm, based on meyer's self-organizing graph methods. returns the current number of epochs and execution status, as a string. advances the current positions of the graph elements. this one is an incremental visualization. true is the layout algorithm is incremental, false otherwise for now, we pretend it never finishes. true is the increments are done, false otherwise jung.sourceforge.net/license.txt for a description. factor = 0; //will be set later on temperature = 0.03; initialjumpradius = 100; jumpradius = initialjumpradius; delay = 100; done = true; generate random position in graph space creates a new xyz data location get closest vertex to random position jumpradius = (int) factor jumpradius; temperature = factor temperature; currxydata.addx(factor dx); currxydata.addy(factor dy); current.getneighbors(); for (iterator iter = s.iterator(); iter.hasnext();) { vertex child = (vertex) iter.next(); disp.set(1, y); disp.set(1, disp.get(1) + y); disp.set(1, disp.get(1) - y);"
edu.uci.ics.jung.algorithms.layout3d.Layout "initializes fields in the node that may not have been set during the constructor. must be called before the iterations begin. provides initial locations for all vertices. setter for graph returns the full graph (the one that was passed in at construction time) that this layout refers to.   returns the current size of the visualization's space. sets a flag which fixes this vertex in place. vertex returns true if the position of vertex v is locked. set the location of a vertex jung.sourceforge.net/license.txt for a description. float getwidth(); float getheight(); float getdepth();"
edu.uci.ics.jung.algorithms.layout3d.RadiusGraphElementAccessor "simple implementation of picksupport that returns the vertex or edge that is closest to the specified location. this implementation provides the same picking options that were available in previous versions of abstractlayout. no element will be returned that is farther away than the specified maximum distance. creates an instance with an effectively infinite default maximum distance. creates an instance with the specified default maximum distance. gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provde a more efficient implementation. gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provde a more efficient implementation. temporarily overrides member maxdistance gets the edge nearest to the location of the (x,y) location selected. calls the longer form of the call. gets the edge nearest to the location of the (x,y) location selected, within a distance of maxdistance, iterates through all visible edges and checks their distance from the click. override this method to provide a more efficient implementation. temporarily overrides member maxdistance closest to the click. jung.sourceforge.net/license.txt for a description. public e getedge(layout layout, double x, double y) { return getedge(layout, x, y, this.maxdistance); } public e getedge(layout layout, point3f p, double maxdistance) { double mindistance = maxdistance maxdistance; e closest = null; while(true) { try { for(e e : layout.getgraph().getedges()) {  // could replace all this set stuff with getfrom_internal() etc. graph graph = layout.getgraph(); collection vertices = graph.getincidentvertices(e); iterator vertexiterator = vertices.iterator(); v v1 = vertexiterator.next(); v v2 = vertexiterator.next(); // get coords point3f p1 = layout.transform(v1); point3f p2 = layout.transform(v2); double x = p.getx(); double y = p.gety(); double z = p.getz(); double x1 = p1.getx(); double y1 = p1.gety(); double z1 = p1.getz(); double x2 = p2.getx(); double y2 = p2.gety(); double z2 = p2.getz();  // calculate location on line closest to (x,y) // first, check that v1 and v2 are not coincident. if (x1 == x2 && y1 == y2 && z1 == z2) continue; double b = ((y - y1) (y2 - y1) + (x - x1) (x2 - x1)) / ((x2 - x1) (x2 - x1) + (y2 - y1) (y2 - y1)); // double distance2; // square of the distance if (b = 1) distance2 = (x - x2) (x - x2) + (y - y2) (y - y2); else { double x3 = x1 + b (x2 - x1); double y3 = y1 + b (y2 - y1); distance2 = (x - x3) (x - x3) + (y - y3) (y - y3); }  if (distance2 < mindistance) { mindistance = distance2; closest = e; } } break; } catch(concurrentmodificationexception cme) {} } return closest; }"
edu.uci.ics.jung.algorithms.layout3d.RandomLocationTransformer "transforms the input type into a random location within the bounds of the dimension property. this is used as the backing transformer for the lazymap for many layouts, and provides a random location for unmapped vertex keys the first time they are accessed. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.layout3d.SpringLayout "the springlayout package represents a visualization of a set of nodes. the springlayout, which is initialized with a graph, assigns x/y locations to each node. when called relax(), the springlayout moves the visualization forward one step. constructor for a springlayout for a raw graph with associated dimension--the input knows how big the graph is. defaults to the unit length function. constructor for a springlayout for a raw graph with associated component. the input graph the length function current value for the stretch parameter @see #setstretch(double) (non-javadoc) @see edu.uci.ics.jung.visualization.layout.abstractlayout#setsize(java.awt.dimension) sets the stretch parameter for this instance. this value specifies how much the degrees of an edge's incident vertices should influence how easily the endpoints of that edge can move (that is, that edge's tendency to change its length). the default value is 0.70. positive values less than 1 cause high-degree vertices to move less than low-degree vertices, and values > 1 cause high-degree vertices to move more than low-degree vertices. negative values will have unpredictable and inconsistent results. current value for the node repulsion range @see #setrepulsionrange(int) sets the node repulsion range (in drawing area units) for this instance. outside this range, nodes do not repel each other. the default value is 100. negative values are treated as their positive equivalents. current value for the edge length force multiplier @see #setforcemultiplier(double) sets the force multiplier for this instance. this value is used to specify how strongly an edge "wants" to be its default length (higher values indicate a greater attraction for the default length), which affects how much its endpoints move at each timestep. the default value is 1/3. a value of 0 turns off any attempt by the layout to cause edges to conform to the default length. negative values cause long edges to get longer and short edges to get shorter; use at your own risk. ------------------------- ------------------------- relaxation step. moves all nodes a smidge. ---------------length function------------------ if the edge is weighted, then override this method to show what the visualized length is. returns all edges as the same length: the input value --------------- movement speed, x movement speed, y ---------------resize handler------------------ this one is an incremental visualization for now, we pretend it never finishes. jung.sourceforge.net/license.txt for a description. system.err.println("svd = "+svd); round from zero, if needed [zero would be bad.]. the actual movement distance 'dx' is the force multiplied by the distance to go. keeps nodes from moving any faster than 5 per time unit setx(0); setx(width); sety(0); sety(height); sety(0); sety(height); system.err.println(v+" xyd = "+xyd); public point3f transform(v v) { if(v.equals("a")) return new point3f(); if(v.equals("b")) return new point3f(50,50,50); return new point3f(); } return true; no counter, do nothing. locations.clear(); initialize();"
edu.uci.ics.jung.algorithms.matrix.GraphMatrixOperations "contains methods for performing the analogues of certain matrix operations on graphs.  these implementations are efficient on sparse graphs, but may not be the best implementations for very dense graphs. returns the graph that corresponds to the square of the (weighted) adjacency matrix that the specified graph g encodes. the implementation of matrixelementoperations that is furnished to the constructor specifies the implementation of the dot product, which is an integral part of matrix multiplication. the graph to be squared result of squaring g creates a graph from a square (weighted) adjacency matrix. if nev is non-null then it will be used to store the edge weights. notes on implementation:  the matrix indices will be mapped onto vertices in the order in which the vertex factory generates the vertices. this means the creates a graph from a square (weighted) adjacency matrix. representation of matrix as a jung graph returns an unweighted (0-1) adjacency matrix based on the specified graph.  the vertex type  the edge type the graph to convert to a matrix returns a sparsedoublematrix2d whose entries represent the edge weights for the edges in g, as specified by nev. the (i,j) entry of the matrix returned will be equal to the sum of the weights of the edges connecting the vertex with index i to j. if nev is null, then a constant edge weight of 1 is used. returns a diagonal matrix whose diagonal entries contain the degree for the corresponding node. note: the vertices will be traversed in the order given by the graph's vertex collection. if you want to be assured of a particular ordering, use a graph implementation that guarantees such an ordering (see the implementations with {@code ordered} or {@code sorted} in their name). 2d the idea here is based on the metaphor of an electric circuit. we assume that an undirected graph represents the structure of an electrical circuit where each edge has unit resistance. one unit of current is injected into any arbitrary vertex s and one unit of current is extracted from any arbitrary vertex t. the voltage at some vertex i for source vertex s and target vertex t can then be measured according to the equation: v_i^(s,t) = t_is - t-it where t is the voltage potential matrix returned by this method. an undirected graph representing an electrical circuit voltage potential matrix @see "p. doyle and j. snell, 'random walks and electric networks,', 1989" @see "m. newman, 'a measure of betweenness centrality based on random walks', pp. 5-7, 2003" converts a map of (vertex, double) pairs to a doublematrix1d. note: the vertices will appear in the output array in the order given by {@code map}'s iterator. if you want a particular ordering, use a {@code map} implementation that provides such an ordering ({@code sortedmap, linkedhashmap}, etc.). computes the all-pairs mean first passage time for the specified graph, given an existing stationary probability distribution.  the mean first passage time from vertex v to vertex w is defined, for a markov network (in which the vertices represent states and the edge weights represent state->state transition probabilities), as the expected number of steps required to travel from v to w if the steps occur according to the transition probabilities.  the stationary distribution is the fraction of time, in the limit as the number of state transitions approaches infinity, that a given state will have been visited. equivalently, it is the probability that a given state will be the current state after an arbitrarily large number of state transitions. the graph on which the mfpt will be calculated the edge weights the asymptotic state probabilities mean first passage time matrix jung.sourceforge.net/license.txt create new graph of same type get the edge connecting src to v in g get edge connecting v to dest in g collect data on path composed of e1 and e2 if no edge from src to dest exists in g2, create one create adjacency matrix from graph create diagonal matrix of vertex degrees compute d - a except for last row and column compute "voltage" matrix"
edu.uci.ics.jung.algorithms.matrix.MatrixElementOperations "an interface for specifying the behavior of graph/matrix operations for a particular element type.  graph/matrix multiplication requires the definition of two operations:    calculating an aggregate property of paths of length 2 between two vertices v1 and v2 (analogous to element multiplication in matrix arithmetic); this is handled by computepathdata().   aggregating the properties of all such paths, and assigning the result to a new edge in the output graph (analogous to element addition in matrix arithmetic); this is handled by mergepaths().    together, computepathdata() and mergepaths() specify how the equivalent of the vector inner (dot) product is to function.  for instance, to implement the equivalent of standard matrix multiplication on two graphs, computepathdata() should return the products of the weights of a two-edge path, and mergepaths() should add the output of computepathdata() to an existing edge (or possibly create such an edge if none exists). if either e or pathdata is null, the effect of mergepaths() is implementation-dependent. (possibly) existing edge in the output graph which represents a path in the input graph(s) data (which represents another path with the same source and destination as e in the input graphs) which is to be merged into e if either e1 or e2 is null, the object reference returned should be null. 1 first edge from 2-edge path in input graph(s) 2 second edge from 2-edge path in input graph(s) of data from the edges of the 2-edge path (from source of e1 to destination of e2) comprised of (e1, e2) returns a map from edges to values. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.matrix.RealMatrixElementOperations "implements the basic matrix operations on double-precision values. assumes that the edges have a mutabledouble value. creates an instance using the specified edge values. @see matrixelementoperations#mergepaths(object, object) @see matrixelementoperations#computepathdata(object, object) edgedata jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.metrics.Metrics "a class consisting of static methods for calculating graph metrics. returns a map of vertices to their clustering coefficients. the clustering coefficient cc(v) of a vertex v is defined as follows:  degree(v) == {0,1}: 0 degree(v) == n, n &gt;= 2: given s, the set of neighbors of v: cc(v) = (the sum over all w in s of the number of other elements of w that are neighbors of w) / ((|s| (|s| - 1) / 2). less formally, the fraction of v's neighbors that are also neighbors of each other. note: this algorithm treats its argument as an undirected graph; edge direction is ignored. the graph whose clustering coefficients are to be calculated @see "the structure and function of complex networks, m.e.j. newman, aps.arxiv.org/abs/cond-mat/0303516" jung.sourceforge.net/license.txt for a description. how many of v's neighbors are connected to each other?"
edu.uci.ics.jung.algorithms.metrics.StructuralHoles "calculates some of the measures from burt's text "structural holes: the social structure of competition". notes:  each of these measures assumes that each edge has an associated non-null weight whose value is accessed through the specified transformer instance. nonexistent edges are treated as edges with weight 0 for purposes of edge weight calculations.  based on code donated by jasper voskuilen and diederik van liere of the department of information and decision sciences at erasmus university. creates a structuralholes instance based on the edge weights specified by nev. burt's measure of the effective size of a vertex's network. essentially, the number of neighbors minus the average degree of those in v's neighbor set, not counting ties to v. formally:  effectivesize(v) = v.degree() - (sum_{u in n(v)} sum_{w in n(u), w !=u,v} p(v,w)m(u,w))  where  n(a) = a.getneighbors() p(v,w) = normalized mutual edge weight of v and w m(u,w) = maximum-scaled mutual edge weight of u and w  @see #normalizedmutualedgeweight(object, object) @see #maxscaledmutualedgeweight(object, object) returns the effective size of v divided by the number of alters in v's network. (in other words, effectivesize(v) / v.degree().) if v.degree() == 0, returns 0. burt's constraint measure (equation 2.4, page 55 of burt, 1992). essentially a measure of the extent to which v is invested in people who are invested in other of v's alters (neighbors). the "constraint" is characterized by a lack of primary holes around each neighbor. formally:  constraint(v) = sum_{w in mp(v), w != v} localconstraint(v,w)  where mp(v) is the subset of v's neighbors that are both predecessors and successors of v. @see #localconstraint(object, object) calculates the hierarchy value for a given vertex. returns nan when v's degree is 0, and 1 when v's degree is 1. formally:  hierarchy(v) = (sum_{v in n(v), w != v} s(v,w) log(s(v,w))}) / (v.degree() math.log(v.degree())  where  n(v) = v.getneighbors() s(v,w) = localconstraint(v,w) / (aggregateconstraint(v) / v.degree())  @see #localconstraint(object, object) @see #aggregateconstraint(object) returns the local constraint on v from a lack of primary holes around its neighbor v2. based on burt's equation 2.4. formally:  localconstraint(v1, v2) = ( p(v1,v2) + ( sum_{w in n(v)} p(v1,w) p(w, v2) ) )^2  where  n(v) = v.getneighbors() p(v,w) = normalized mutual edge weight of v and w  @see #normalizedmutualedgeweight(object, object) the aggregate constraint on v. based on burt's equation 2.7. formally:  aggregateconstraint(v) = sum_{w in n(v)} localconstraint(v,w) o(w)  where  n(v) = v.getneighbors() o(w) = organizationalmeasure(w)  a measure of the organization of individuals within the subgraph centered on v. burt's text suggests that this is in some sense a measure of how "replaceable" v is by some other element of this subgraph. should be a number in the closed interval [0,1]. this implementation returns 1. returns the proportion of v1's network time and energy invested in the relationship with v2. formally:  normalizedmutualedgeweight(a,b) = mutual_weight(a,b) / (sum_c mutual_weight(a,c))  returns 0 if either numerator or denominator = 0, or if v1 == v2. @see #mutualweight(object, object) returns the weight of the edge from v1 to v2 plus the weight of the edge from v2 to v1; if either edge does not exist, it is treated as an edge with weight 0. undirected edges are treated as two antiparallel directed edges (that is, if there is one undirected edge with weight w connecting v1 to v2, the value returned is 2w). ignores parallel edges; if there are any such, one is chosen at random. throws nullpointerexception if either edge is present but not assigned a weight by the constructor-specified numberedgevalue. the marginal strength of v1's relation with contact vertex2. formally:  normalized_mutual_weight = mutual_weight(a,b) / (max_c mutual_weight(a,c))  returns 0 if either numerator or denominator is 0, or if v1 == v2. @see #mutualweight(object, object) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.metrics.TriadicCensus "triadiccensus is a standard social network tool that counts, for each of the different possible configurations of three vertices, the number of times that that configuration occurs in the given graph. this may then be compared to the set of expected counts for this particular graph or to an expected sample. this is often used in p modeling.  to use this class,  long[] triad_counts = triadiccensus(dg);  where dg is a directedgraph. ith element of the array (for i in [1,16]) is the number of occurrences of the corresponding triad type. (the 0th element is not meaningful; this array is effectively 1-based.) to get the name of the ith triad (e.g. "003"), look at the global constant array c.triad_names[i]  triads are named as (number of pairs that are mutually tied) (number of pairs that are one-way tied) (number of non-tied pairs) in the triple. since there are be only three pairs, there is a finite set of these possible triads.  in fact, there are exactly 16, conventionally sorted by the number of realized edges in the triad:  number configuration notes 1003the empty triad 2012 3102 4021d"down": the directed edges point away 5021u"up": the directed edges meet 6021c"circle": one in, one out 7111d"down": 021d but one edge is mutual 8111u"up": 021u but one edge is mutual 9030t"transitive": two point to the same vertex 10030c"circle": a->b->c->a 11201 12120d"down": 021d but the third edge is mutual 13120u"up": 021u but the third edge is mutual 14120c"circle": 021c but the third edge is mutual 15210 16300the complete   this implementation takes o( m ), m is the number of edges in the graph.  it is based on  a subquadratic triad census algorithm for large sparse networks with small maximum degree vladimir batagelj and andrej mrvar, university of ljubljana published in social networks. returns an array whose ith element (for i in [1,16]) is the number of occurrences of the corresponding triad type in g. (the 0th element is not meaningful; this array is effectively 1-based.) this is the core of the technique in the paper. returns an int from 0 to 65 based on: wu -> 32 uw -> 16 wv -> 8 vw -> 4 uv -> 2 vu -> 1 simply returns the tricode. string code associated with the numeric type for debugging purposes, this is copied straight out of the paper which means that they refer to triad types 1-16. make sure we have a canonical ordering: returns true if u  note that this returns standard 1-16 count! and their types apply algorithm to each edge, one at at time"
edu.uci.ics.jung.algorithms.scoring.AbstractIterativeScorer "an abstract class for algorithms that assign scores to vertices based on iterative methods. generally, any (concrete) subclass will function by creating an instance, and then either calling evaluate (if the maximum number of iterations to use before terminating. defaults to 100. minimum change from one step to the next; if all changes are g. note: this constructor does not set the internal edge_weights variable. if this variable is used by the subclass which invoked this constructor, it must be initialized by that subclass. the graph for which the instance is to be initializes the internal state for this instance. steps through this scoring algorithm until a termination condition is reached. returns true if the total number of iterations is greater than or equal to max_iterations or if the maximum value change observed is less than tolerance. performs one step of this algorithm; updates the state (value) for each vertex.  updates the value for v. this is the key the vertex whose value is to be updated @return returns the maximum number of iterations that this instance will use. maximum number of iterations that evaluate will use prior to terminating returns the number of iterations that this instance has used so far. number of iterations that this instance has used so far sets the maximum number of times that evaluate will call step. _iterations the maximum gets the size of the largest change (difference between the current and previous values) for any vertex that can be tolerated. once all changes are less than this value, evaluate will terminate. size of the largest change that evaluate() will permit sets the size of the largest change (difference between the current and previous values) for any vertex that can be tolerated. the size of the largest change that evaluate() will permit returns the transformer that this instance uses to associate edge weights with each edge. transformer that associates an edge weight with each edge sets the transformer that this instance uses to associate edge weights with each edge _weights the transformer to use to associate an edge weight with each edge @see edu.uci.ics.jung.algorithms.scoring.util.uniformdegreeweight gets the edge weight for e in the context of its (incident) vertex v. the vertex incident to e as a context in which the edge weight is to be calculated the edge whose weight is to be returned edge weight for e in the context of its (incident) vertex v collects the 'potential' from v (its current value) if it has no outgoing edges; this can then be redistributed among the other vertices as a means of normalization. specifies whether this instance should accept vertices with no outgoing edges. true if this instance should accept vertices with no outgoing edges, false otherwise returns true if this instance accepts vertices with no outgoing edges, and false otherwise. if this instance accepts vertices with no outgoing edges, otherwise false specifies whether hyperedges are to be treated as self-loops. if they are, then potential will flow along a hyperedge a vertex to itself, just as it does to all other vertices incident to that hyperedge. if {@code true}, hyperedges are treated as self-loops returns the effective number of vertices incident to this edge. if the graph is a binary relation or if hyperedges are treated as self-loops, the value returned is {@code graph.getincidentcount(e)}; otherwise it is {@code graph.getincidentcount(e) - 1}. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.AbstractIterativeScorerWithPriors "an abstract class for iterative random-walk-based vertex scoring algorithms that have a fixed probability, for each vertex, of 'jumping' to that vertex at each step in the algorithm (rather than following a link out of that vertex).  the vertex type  the edge type  the score type the prior probability of each vertex being visited on a given 'jump' (non-link-following) step. the probability of making a 'jump' at each step. creates an instance for the specified graph, edge weights, vertex priors, and jump probability. the graph whose vertices are to be assigned scores _weights the edge weights to use in the score assignment _priors the prior probabilities of each vertex being 'jumped' to the probability of making a 'jump' at each step creates an instance for the specified graph, vertex priors, and jump probability, with edge weights specified by the subclass. the graph whose vertices are to be assigned scores _priors the prior probabilities of each vertex being 'jumped' to the probability of making a 'jump' at each step initializes the state of this instance. returns the prior probability for v. the vertex whose prior probability is being queried prior probability for v returns a transformer which maps each vertex to its prior probability. transformer which maps each vertex to its prior probability returns the probability of making a 'jump' (non-link-following step). probability of making a 'jump' (non-link-following step) jung.sourceforge.net/license.txt for a description. initialize output values to priors (output and current are swapped before each step(), so current will have priors when update()s start happening)"
edu.uci.ics.jung.algorithms.scoring.BarycenterScorer "assigns scores to each vertex according to the sum of its distances to all other vertices. creates an instance with the specified graph and distance metric. the input graph the distance metric to use creates an instance with the specified graph and edge weights. will generate a distance metric internally based on the edge weights. the input graph _weights the edge weights to use to calculate vertex/vertex distances creates an instance with the specified graph. will generate a distance metric internally assuming that the graph is unweighted. the input graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.BetweennessCentrality "computes betweenness centrality for each vertex and edge in the graph. @see "ulrik brandes: a faster algorithm for betweenness centrality. journal of mathematical sociology 25(2):163-177, 2001." calculates betweenness scores based on the all-pairs unweighted shortest paths in the graph. the graph for which the scores are to be calculated calculates betweenness scores based on the all-pairs weighted shortest paths in the graph. note: this version of the algorithm may not work correctly on all graphs; we're still working out the bugs. use at your own risk. the graph for which the scores are to be calculated _weights the edge weights to be used in the path length calculations jung.sourceforge.net/license.txt for a description. reject negative-weight edges up front initialize the betweenness data for this new vertex if (v.equals(new integer(0))) system.out.println("pause"); buffer queue = new unboundedfifobuffer(); queue.add(v); v w = queue.remove(); todo (jrtom): change this to getothervertices(w, e) for(v x : graph.getsuccessors(w)) { if (x.equals(w)) continue; fixme: the other problem is that i need to keep putting the neighbors of things we've just discovered in the queue, if they're undiscovered or at greater distance. fixme: this is the problem, right here, i think: need to update position in queue if distance changes (which can only happen with weighted edges). for each outgoing edge e from w, get other end x if x not already visited (dist x  edge_weights) { for (v v : graph.getvertices()) { // initialize the betweenness data for this new vertex for (v s : graph.getvertices()) this.vertex_data.put(s, new betweennessdata()); vertex_data.get(v).numsps = 1; vertex_data.get(v).distance = 0;  stack stack = new stack(); // buffer queue = new unboundedfifobuffer(); sortedset pqueue = new treeset(new betweennesscomparator()); // queue.add(v); pqueue.add(v);  // while (!queue.isempty()) while (!pqueue.isempty()) { // v w = queue.remove(); v w = pqueue.first(); pqueue.remove(w); stack.push(w);  // for(v x : graph.getsuccessors(w)) for (e e : graph.getoutedges(w)) { // todo (jrtom): change this to getothervertices(w, e) v x = graph.getopposite(w, e); if (x.equals(w)) continue; double e_weight = edge_weights.transform(e).doublevalue();  if (vertex_data.get(x).distance  predecessors; predecessors = new arraylist(); ", p:" + predecessors + ", d:" + dependency + "]\n";"
edu.uci.ics.jung.algorithms.scoring.ClosenessCentrality "assigns scores to each vertex based on the mean distance to each other vertex. creates an instance using the specified vertex/vertex distance metric. the input the vertex/vertex distance metric. creates an instance which measures distance using the specified edge weights. the input graph _weights the edge weights to be used to determine vertex/vertex distances creates an instance which measures distance on the graph without edge weights. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.DegreeScorer "assigns a score to each vertex equal to its degree.  the vertex type the graph for which scores are to be generated. creates an instance for the specified graph. the input graph returns the degree of the vertex. degree of the vertex jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.DistanceCentralityScorer "assigns scores to vertices based on their distances to each other vertex in the graph. this class optionally normalizes its results based on the value of its 'averaging' constructor parameter. if it is true, then the value returned for vertex v is 1 / (_average_ distance from v to all other vertices); this is sometimes called closeness centrality. if it is false, then the value returned is 1 / (_total_ distance from v to all other vertices); this is sometimes referred to as barycenter centrality. (if the average/total distance is 0, the value returned is {@code double.positive_infinity}.) @see barycenterscorer @see closenesscentrality the graph on which the vertex scores are to be calculated. the metric to use for specifying the distance between pairs of vertices. the cache for the output results. null encodes "not yet calculated", v with missing (null) distances, v's score should ignore the missing values or be set to 'null'. defaults to 'true'. specifies whether the values returned should ignore self-distances (distances from v to itself). defaults to 'true'. creates an instance with the specified graph, distance metric, and averaging behavior. the graph on which the vertex scores are to be calculated. the metric to use for specifying the distance between pairs of vertices. specifies whether the values returned is the sum of all v-distances or the mean v-distance. _missing specifies whether scores for missing distances are to ignore missing distances or be set to null. _self_distances specifies whether distances from a vertex to itself should be included in its score. equivalent to this(graph, distance, averaging, true, true). the graph on which the vertex scores are to be calculated. the metric to use for specifying the distance between pairs of vertices. specifies whether the values returned is the sum of all v-distances or the mean v-distance. creates an instance with the specified graph and averaging behavior whose vertex distances are calculated based on the specified edge weights. the graph on which the vertex scores are to be calculated. _weights the edge weights to use for specifying the distance between pairs of vertices. specifies whether the values returned is the sum of all v-distances or the mean v-distance. _missing specifies whether scores for missing distances are to ignore missing distances or be set to null. _self_distances specifies whether distances from a vertex to itself should be included in its score. equivalent to this(graph, edge_weights, averaging, true, true). the graph on which the vertex scores are to be calculated. _weights the edge weights to use for specifying the distance between pairs of vertices. specifies whether the values returned is the sum of all v-distances or the mean v-distance. creates an instance with the specified graph and averaging behavior whose vertex distances are calculated on the unweighted graph. the graph on which the vertex scores are to be calculated. specifies whether the values returned is the sum of all v-distances or the mean v-distance. _missing specifies whether scores for missing distances are to ignore missing distances or be set to null. _self_distances specifies whether distances from a vertex to itself should be included in its score. equivalent to this(graph, averaging, true, true). the graph on which the vertex scores are to be calculated. specifies whether the values returned is the sum of all v-distances or the mean v-distance. calculates the score for the specified vertex. returns {@code null} if there are missing distances and such are not ignored by this instance. jung.sourceforge.net/license.txt for a description. if we don't ignore missing distances and there aren't enough distances, output null (shortcut)"
edu.uci.ics.jung.algorithms.scoring.EdgeScorer "an interface for algorithms that assign scores to edges.  the edge type  the score type returns the algorithm's score for this edge. algorithm's score for this edge jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.EigenvectorCentrality "calculates eigenvector centrality for each vertex in the graph. the 'eigenvector centrality' for a vertex is defined as the fraction of time that a random walk(er) will spend at that vertex over an infinite time horizon. assumes that the graph is strongly connected. creates an instance with the specified graph and edge weights. the outgoing edge weights for each edge must sum to 1. (see uniformdegreeweight for one way to handle this for undirected graphs.) the graph for which the centrality is to be calculated _weights the edge weights creates an instance with the specified graph and default edge weights. (default edge weights: uniformdegreeweight.) the graph for which the centrality is to be calculated. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.HITS "assigns hub and creates an instance for the specified graph, edge weights, and alpha (random jump probability) parameter. the input graph _weights the weights to use for each edge the probability of a hub giving some creates an instance for the specified graph and alpha (random jump probability) parameter. the edge weights are all set to 1. the input graph the probability of a hub giving some creates an instance for the specified graph. the edge weights are all set to 1 and alpha is set to 0. the input graph maintains hub and the hub score for a vertex. the creates an instance with the specified hub and jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.HITSWithPriors "a generalization of hits that permits non-uniformly-distributed random jumps. the 'vertex_priors' (that is, prior probabilities for each vertex) may be thought of as the fraction of the total 'potential' (hub or the sum of the potential, at each step, associated with vertices with no outedges ( creates an instance for the specified graph, edge weights, vertex prior probabilities, and random jump probability (alpha). the input graph _weights the edge weights _priors the prior probability for each vertex the probability of a random jump at each step creates an instance for the specified graph, vertex priors, and random jump probability (alpha). the edge weights default to 1.0. the input graph _priors the prior probability for each vertex the probability of a random jump at each step updates the value for this vertex. code which is executed after each step. in this case, deals with the 'disappearing potential', normalizes the scores, and then calls super.afterstep(). @see #collectdisappearingpotential(object) normalizes scores so that sum of their squares = 1. this method may be overridden so as to yield different normalizations. collects the "disappearing potential" associated with vertices that have either no incoming edges, no outgoing edges, or both. vertices that have no incoming edges do not directly contribute to the hub scores of other vertices; similarly, vertices that have no outgoing edges do not directly contribute to the jung.sourceforge.net/license.txt for a description. v w = graph.getopposite(v, e); auth += (getcurrentvalue(w).hub getedgeweight(w, e).doublevalue()); v x = graph.getopposite(v,e); hub += (getcurrentvalue(x). modify total_input according to alpha"
edu.uci.ics.jung.algorithms.scoring.KStepMarkov "a special case of {@code pagerankwithpriors} in which the final scores represent a probability distribution over position assuming a random (markovian) walk of exactly k steps, based on the initial distribution specified by the priors. note: the version of {@code kstepmarkov} in {@code algorithms.importance} (and in jung 1.x) is believed to be incorrect: rather than returning a score which represents a probability distribution over position assuming a k-step random walk, it returns a score which represents the sum over all steps of the probability for each step. if you want that behavior, set the 'cumulative' flag as follows before calling {@code evaluate()}:  kstepmarkov ksm = new kstepmarkov(...); ksm.setcumulative(true); ksm.evaluate();  by default, the 'cumulative' flag is set to false. note: this class is not yet complete. use at your own risk. (the original behavior is captured by the version still available in {@code algorithms.importance}.) @see "algorithms for estimating relative importance in graphs by scott white and padhraic smyth, 2003" @see pagerank @see pagerankwithpriors creates an instance based on the specified graph, edge weights, vertex priors (initial scores), and number of steps to take. the input graph _weights the edge weights (transition probabilities) _priors the initial probability distribution (score assignment) the number of times that {@code step()} will be called by {@code evaluate} creates an instance based on the specified graph, vertex priors (initial scores), and number of steps to take. the edge weights (transition probabilities) are set to default values (a uniform distribution over all outgoing edges). the input graph _priors the initial probability distribution (score assignment) the number of times that {@code step()} will be called by {@code evaluate} creates an instance based on the specified graph and number of steps to take. the edge weights (transition probabilities) and vertex initial scores (prior probabilities) are set to default values (a uniform distribution over all outgoing edges, and a uniform distribution over all vertices, respectively). the input graph the number of times that {@code step()} will be called by {@code evaluate} specifies whether this instance should assign a score to each vertex based on the updates the value for this vertex. called by step(). jung.sourceforge.net/license.txt for a description. for graphs, the code below is equivalent to v w = graph.getopposite(v, e); total_input += (getcurrentvalue(w) getedgeweight(w,e).doublevalue()); for hypergraphs, this divides the potential coming from w by the number of vertices in the connecting edge e. modify total_input according to alpha fixme: do we need to change how disappearing is counted? normalize?"
edu.uci.ics.jung.algorithms.scoring.PageRank "assigns scores to each vertex according to the pagerank algorithm. pagerank is an eigenvector-based algorithm. the score for a given vertex may be thought of as the fraction of time spent 'visiting' that vertex (measured over all time) in a random walk over the vertices (following outgoing edges from each vertex). pagerank modifies this random walk by adding to the model a probability (specified as 'alpha' in the constructor) of jumping to any vertex. if alpha is 0, this is equivalent to the eigenvector centrality algorithm; if alpha is 1, all vertices will receive the same score (1/|v|). thus, alpha acts as a sort of score smoothing parameter. the original algorithm assumed that, for a given vertex, the probability of following any outgoing edge was the same; this is the default if edge weights are not specified. this implementation generalizes the original by permitting the creates an instance for the specified graph, edge weights, and random jump probability. the input graph _weight the edge weights (transition probabilities) the probability of taking a random jump to an arbitrary vertex creates an instance for the specified graph and random jump probability; the probability of following any outgoing edge from a given vertex is the same. the input graph the probability of taking a random jump to an arbitrary vertex jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.PageRankWithPriors "a generalization of pagerank that permits non-uniformly-distributed random jumps. the 'vertex_priors' (that is, prior probabilities for each vertex) may be thought of as the fraction of the total 'potential' that is assigned to that vertex at each step out of the portion that is assigned according to random jumps (this portion is specified by 'alpha'). @see "algorithms for estimating relative importance in graphs by scott white and padhraic smyth, 2003" @see pagerank maintains the amount of potential associated with vertices with no out-edges. creates an instance with the specified graph, edge weights, vertex priors, and 'random jump' probability (alpha). the input graph _weights the edge weights, denoting transition probabilities from source to destination _priors the prior probabilities for each vertex the probability of executing a 'random jump' at each step creates an instance with the specified graph, vertex priors, and 'random jump' probability (alpha). the outgoing edge weights for each vertex will be equal and sum to 1. the input graph _priors the prior probabilities for each vertex the probability of executing a 'random jump' at each step updates the value for this vertex. called by step(). cleans up after each step. in this case that involves allocating the disappearing potential (thus maintaining normalization of the scores) according to the vertex probability priors, and then calling super.afterstep. collects the "disappearing potential" associated with vertices that have no outgoing edges. vertices that have no outgoing edges do not directly contribute to the scores of other vertices. these values are collected at each step and then distributed across all vertices as a part of the normalization process. jung.sourceforge.net/license.txt for a description. for graphs, the code below is equivalent to v w = graph.getopposite(v, e); total_input += (getcurrentvalue(w) getedgeweight(w,e).doublevalue()); for hypergraphs, this divides the potential coming from w by the number of vertices in the connecting edge e. modify total_input according to alpha distribute disappearing potential according to priors"
edu.uci.ics.jung.algorithms.scoring.util.DelegateToEdgeTransformer "a transformer that delegates its operation to a transformer. mainly useful for technical reasons inside abstractiterativescorer; in essence it allows the edge weight instance variable to be of type vepair,w even if the edge weight transformer only operates on edges. the transformer to which this instance delegates its function. creates an instance with the specified delegate transformer. the transformer to which this instance will delegate @see transformer#transform(object) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.util.ScoringUtils "methods for assigning values (to be interpreted as prior probabilities) to vertices in the context of random-walk-based scoring algorithms. assigns a probability of 1/roots.size() to each of the elements of roots.  the vertex type the vertices to be assigned nonzero prior probabilities @return returns a transformer that hub and jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.util.UniformDegreeWeight "an edge weight function that assigns weights as uniform transition probabilities. for undirected edges, returns 1/degree(v) (where 'v' is the vertex in the vepair. for directed edges, returns 1/outdegree(source(e)) (where 'e' is the edge in the vepair). throws an illegalargumentexception if the input edge is neither edgetype.undirected nor edgetype.directed. creates an instance for the specified graph. @see org.apache.commons.collections15.transformer#transform(java.lang.object) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.util.UniformInOut "assigns weights to directed edges (the edge of the vertex/edge pair) depending on whether the vertex is the edge's source or its destination. if the vertex v is the edge's source, assigns 1/outdegree(v). otherwise, assigns 1/indegree(w). throws illegalargumentexception if the edge is not directed. the graph for which the edge weights are defined. creates an instance for the specified graph. the graph for which the edge weights will be defined @see org.apache.commons.collections15.transformer#transform(object) @throws illegalargumentexception jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.util.VEPair "convenience class for associating a vertex and an edge. used, for example, in contexts in which it is necessary to know the origin for an edge traversal (that is, the direction in which an (undirected) edge is being traversed).  the vertex type  the edge type creates an instance with the specified vertex and edge the vertex to add the edge to add returns the vertex of this pair. returns the edge of this pair. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.util.VertexScoreTransformer "a transformer convenience wrapper around vertexscorer. the vertexscorer instance that provides the values returned by transform. creates an instance based on the specified vertexscorer. returns the score for this vertex. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.VertexScorer "an interface for algorithms that assign scores to vertices.  the vertex type  the score type returns the algorithm's score for this vertex. algorithm's score for this vertex jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.scoring.VoltageScorer "assigns scores to vertices according to their 'voltage' in an approximate solution to the kirchoff equations. this is accomplished by tying "source" vertices to specified positive voltages, "sink" vertices to 0 v, and iteratively updating the voltage of each other vertex to the (weighted) average of the voltages of its neighbors. the resultant voltages will all be in the range [0, max] where max is the largest voltage of any source vertex (in the absence of negative source voltages; see below). a few notes about this algorithm's interpretation of the graph data:  higher edge weights are interpreted as indicative of greater influence/effect than lower edge weights. negative edge weights (and negative "source" voltages) invalidate the interpretation of the resultant values as voltages. however, this algorithm will not reject graphs with negative edge weights or source voltages. parallel edges are equivalent to a single edge whose weight is the sum of the weights on the parallel edges. current flows along undirected edges in both directions, but only flows along directed edges in the direction of the edge.   creates an instance with the specified graph, edge weights, source voltages, and sinks. the input graph _weights the edge weights, representing conductivity _voltages the (fixed) voltage for each source the vertices whose voltages are tied to 0 creates an instance with the specified graph, edge weights, source vertices (each of whose 'voltages' are tied to 1), and sinks. the input graph _weights the edge weights, representing conductivity the vertices whose voltages are tied to 1 the vertices whose voltages are tied to 0 creates an instance with the specified graph, source vertices (each of whose 'voltages' are tied to 1), and sinks. the outgoing edges for each vertex are assigned weights that sum to 1. the input graph the vertices whose voltages are tied to 1 the vertices whose voltages are tied to 0 creates an instance with the specified graph, source voltages, and sinks. the outgoing edges for each vertex are assigned weights that sum to 1. the input graph _voltages the (fixed) voltage for each source the vertices whose voltages are tied to 0 creates an instance with the specified graph, edge weights, source, and sink. the source vertex voltage is tied to 1. the input graph _weights the edge weights, representing conductivity the vertex whose voltage is tied to 1 the vertex whose voltage is tied to 0 creates an instance with the specified graph, edge weights, source, and sink. the source vertex voltage is tied to 1. the outgoing edges for each vertex are assigned weights that sum to 1. the input graph the vertex whose voltage is tied to 1 the vertex whose voltage is tied to 0 initializes the state of this instance. @see edu.uci.ics.jung.algorithms.scoring.abstractiterativescorer#update(object) jung.sourceforge.net/license.txt for a description. sanity check set up initial voltages if it's a voltage source or sink, we're done v w = graph.getopposite(v, e); double weight = getedgeweight(w,e).doublevalue(); voltage_sum += getcurrentvalue(w).doublevalue() weight; weight_sum += weight; if either is 0, new value is 0"
edu.uci.ics.jung.algorithms.shortestpath.BFSDistanceLabeler "labels each node in the graph according to the bfs distance from the start node(s). if nodes are unreachable, then they are assigned a distance of -1. all nodes traversed at step k are marked as predecessors of their successors traversed at step k+1.  running time is: o(m) creates a new bfs labeler for the specified graph and root set the distances are stored in the corresponding vertex objects and are of type mutableinteger returns the list of vertices visited in order of traversal list of vertices returns the set of all vertices that were not visited list of unvisited vertices given a vertex, returns the shortest distance from any node in the root set to v the vertex whose distance is to be retrieved shortest distance from any node in the root set to v returns set of predecessors of the given vertex the vertex whose predecessors are to be retrieved set of predecessors computes the distances of all the node from the starting root nodes. if there is more than one root node the minimum distance from each root node is used as the designated distance to a given node. also keeps track of the predecessors of each node traversed as well as the order of nodes traversed. the graph to label the set of starting vertices to traverse from computes the distances of all the node from the specified root node. also keeps track of the predecessors of each node traversed as well as the order of nodes traversed. the graph to label the single starting vertex to traverse from returns a map from vertices to minimum distances from the original source(s). must be called after {@code labeldistances} in order to contain valid data. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.shortestpath.DijkstraDistance "calculates distances in a specified graph, using dijkstra's single-source-shortest-path algorithm. all edge weights in the graph must be nonnegative; if any edge with negative weight is found in the course of calculating distances, an illegalargumentexception will be thrown. (note: this exception will only be thrown when such an edge would be used to update a given tentative distance; the algorithm does not check for negative-weight edges "up front".) distances and partial results are optionally cached (by this instance) for later reference. thus, if the 10 closest vertices to a specified source vertex are known, calculating the 20 closest vertices does not require starting dijkstra's algorithm over from scratch. distances are stored as double-precision values. if a vertex is not reachable from the specified source vertex, no distance is stored. this is new behavior with version 1.4; the previous behavior was to store a value of double.positive_infinity. this change gives the algorithm an approximate complexity of o(kd log k), where k is either the number of requested targets or the number of reachable vertices (whichever is smaller), and d is the average degree of a vertex.  the elements in the maps returned by getdistancemap are ordered (that is, returned by the iterator) by nondecreasing distance from source.  creates an instance of dijkstrashortestpath for the specified graph and the specified method of extracting weights from edges, which caches results locally if and only if cached is true. the graph on which distances will be calculated the class responsible for returning weights for edges specifies whether the results are to be cached creates an instance of dijkstrashortestpath for the specified graph and the specified method of extracting weights from edges, which caches results locally. the graph on which distances will be calculated the class responsible for returning weights for edges creates an instance of dijkstrashortestpath for the specified unweighted graph (that is, all weights 1) which caches results locally. the graph on which distances will be calculated creates an instance of dijkstrashortestpath for the specified unweighted graph (that is, all weights 1) which caches results locally. the graph on which distances will be calculated specifies whether the results are to be cached implements dijkstra's single-source shortest-path algorithm for weighted graphs. uses a mapbinaryheap as the priority queue, which gives this algorithm a time complexity of o(m lg n) (m = # of edges, n = # of vertices). this algorithm will terminate when any of the following have occurred (in order of priority):   the distance to the specified target (if any) has been found  no more vertices are reachable  the specified # of distances have been found, or the maximum distance desired has been exceeded  all distances have been found  the vertex from which distances are to be measured the number of distances to measure the set of vertices to which distances are to be measured returns the set of edges incident to v that should be tested. by default, this is the set of outgoing edges for instances of graph, the set of incident edges for instances of hypergraph, and is otherwise undefined. returns the length of a shortest path from the source to the target vertex, or null if the target is not reachable from the source. if either vertex is not in the graph for which this instance was returns a {@code map} from each element {@code t} of {@code targets} to the shortest-path distance from {@code source} to {@code t}. returns a linkedhashmap which maps each vertex in the graph (including the source vertex) to its distance from the source vertex. the map's iterator will return the elements in order of increasing distance from source. the size of the map returned will be the number of vertices reachable from source. @see #getdistancemap(object,int) @see #getdistance(object,object) the vertex from which distances are measured returns a linkedhashmap which maps each of the closest numdist vertices to the source vertex in the graph (including the source vertex) to its distance from the source vertex. throws an illegalargumentexception if source is not in this instance's graph, or if numdests is either less than 1 or greater than the number of vertices in the graph. the size of the map returned will be the smaller of numdests and the number of vertices reachable from source. @see #getdistancemap(object) @see #getdistance(object,object) the vertex from which distances are measured the number of vertices for which to measure distances allows the allows the clears all stored distances for this instance. should be called whenever the graph is modified (edge weights changed or edges added/removed). if the specifies whether or not this instance of dijkstrashortestpath should cache its results (final and partial) for future reference. true if the results are to be cached, and false otherwise clears all stored distances for the specified source vertex source. should be called whenever the stored distances from this vertex are invalidated by changes to the graph. @see #reset() compares according to distances, so that the binaryheap knows how to order the tree. for a given source vertex, holds the estimated and final distances, tentative and final assignments of incoming edges on the shortest path from the source vertex, and a priority queue (ordered by estimated distance) of the vertices for which distances are unknown. jung.sourceforge.net/license.txt for a description. a map of source vertices to an instance of sourcedata if we've exceeded the max distance or max # of distances we're willing to calculate, or if we already have all the distances we need, terminate we're done; put this vertex back in so that we're not including a distance beyond what we specified update tentative distance & path for w initialize priority queue distance from source to itself is 0"
edu.uci.ics.jung.algorithms.shortestpath.DijkstraShortestPath "calculates distances and shortest paths using dijkstra's single-source-shortest-path algorithm. this is a lightweight extension of dijkstradistance that also stores path information, so that the shortest paths can be reconstructed.  the elements in the maps returned by getincomingedgemap are ordered (that is, returned by the iterator) by nondecreasing distance from source. creates an instance of dijkstrashortestpath for the specified graph and the specified method of extracting weights from edges, which caches results locally if and only if cached is true. the graph on which distances will be calculated the class responsible for returning weights for edges specifies whether the results are to be cached creates an instance of dijkstrashortestpath for the specified graph and the specified method of extracting weights from edges, which caches results locally. the graph on which distances will be calculated the class responsible for returning weights for edges creates an instance of dijkstrashortestpath for the specified unweighted graph (that is, all weights 1) which caches results locally. the graph on which distances will be calculated creates an instance of dijkstrashortestpath for the specified unweighted graph (that is, all weights 1) which caches results locally. the graph on which distances will be calculated specifies whether the results are to be cached returns the last edge on a shortest path from source to target, or null if target is not reachable from source. if either vertex is not in the graph for which this instance was returns a linkedhashmap which maps each vertex in the graph (including the source vertex) to the last edge on the shortest path from the source vertex. the map's iterator will return the elements in order of increasing distance from source. @see dijkstradistance#getdistancemap(object,int) @see dijkstradistance#getdistance(object,object) the vertex from which distances are measured returns a list of the edges on the shortest path from source to target, in order of their occurrence on this path. if either vertex is not in the graph for which this instance was returns a linkedhashmap which maps each of the closest numdist vertices to the source vertex in the graph (including the source vertex) to the incoming edge along the path from that vertex. throws an illegalargumentexception if source is not in this instance's graph, or if numdests is either less than 1 or greater than the number of vertices in the graph. @see #getincomingedgemap(object) @see #getpath(object,object) the vertex from which distances are measured the number of vertics for which to measure distances for a given source vertex, holds the estimated and final distances, tentative and final assignments of incoming edges on the shortest path from the source vertex, and a priority queue (ordered by estimaed distance) of the vertices for which distances are unknown. jung.sourceforge.net/license.txt for a description. collect path data; must use internal method rather than calling getincomingedge() because getincomingedge() may wipe out results if results are not cached"
edu.uci.ics.jung.algorithms.shortestpath.Distance "an interface for classes which calculate the distance between one vertex and another. returns the distance from the source vertex to the target vertex. if target is not reachable from source, returns null. returns a map which maps each vertex in the graph (including the source vertex) to its distance (represented as a number) from source. if any vertex is not reachable from source, no distance is stored for that vertex. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.shortestpath.DistanceStatistics "statistics relating to vertex-vertex distances in a graph. formerly known as graphstatistics in jung 1.x. for each vertex v in graph, calculates the average shortest path length from v to all other vertices in graph using the metric specified by d, and returns the results in a map from vertices to double values. if there exists an ordered pair &lt;u,v&gt; for which d.getdistance(u,v) returns null, then the average distance value for u will be stored as double.positive_infinity). does not include self-distances (path lengths from v to v). to calculate the average distances, ignoring edge weights if any:  map distances = distancestatistics.averagedistances(g, new unweightedshortestpath(g));  to calculate the average distances respecting edge weights:  dijkstrashortestpath dsp = new dijkstrashortestpath(g, nev); map distances = distancestatistics.averagedistances(g, dsp);  where nev is an instance of transformer that is used to fetch the weight for each edge. @see edu.uci.ics.jung.algorithms.shortestpath.unweightedshortestpath @see edu.uci.ics.jung.algorithms.shortestpath.dijkstradistance for each vertex v in g, calculates the average shortest path length from v to all other vertices in g, ignoring edge weights. @see #diameter(hypergraph) @see edu.uci.ics.jung.algorithms.scoring.closenesscentrality returns the diameter of g using the metric specified by d. the diameter is defined to be the maximum, over all pairs of vertices u,v, of the length of the shortest path from u to v. if the graph is disconnected (that is, not all pairs of vertices are reachable from one another), the value returned will depend on use_max: if use_max == true, the value returned will be the the maximum shortest path length over all pairs of connected vertices; otherwise it will be double.positive_infinity. returns the diameter of g using the metric specified by d. the diameter is defined to be the maximum, over all pairs of vertices u,v, of the length of the shortest path from u to v, or double.positive_infinity if any of these distances do not exist. @see #diameter(hypergraph, distance, boolean) returns the diameter of g, ignoring edge weights. @see #diameter(hypergraph, distance, boolean) jung.sourceforge.net/license.txt for a description. don't include self-distances"
edu.uci.ics.jung.algorithms.shortestpath.MinimumSpanningForest "for the input graph, creates a minimumspanningtree using a variation of prim's algorithm. creates a forest from the supplied graph and supplied factory, which is used to create a new, empty forest. if non-null, the supplied root will be used as the root of the tree/forest. if the supplied root is null, or not present in the graph, then an arbitrary graph vertex will be selected as the root. if the minimum spanning tree does not include all vertices of the graph, then a leftover vertex is selected as a root, and another tree is creates a minimum spanning forest from the supplied graph, populating the supplied forest, which must be empty. if the supplied root is null, or not present in the graph, then an arbitrary graph vertex will be selected as the root. if the minimum spanning tree does not include all vertices of the graph, then a leftover vertex is selected as a root, and another tree is creates a minimum spanning forest from the supplied graph, populating the supplied forest, which must be empty. if the supplied root is null, or not present in the graph, then an arbitrary graph vertex will be selected as the root. if the minimum spanning tree does not include all vertices of the graph, then a leftover vertex is selected as a root, and another tree is returns the generated forest. find the lowest cost edge, get its opposite endpoint, and then update forest from its successors"
edu.uci.ics.jung.algorithms.shortestpath.MinimumSpanningForest2 "for the input graph, creates a minimumspanningtree using a variation of prim's algorithm. create a forest from the supplied graph and supplied factory, which is used to create a new, empty forest. if non-null, the supplied root will be used as the root of the tree/forest. if the supplied root is null, or not present in the graph, then an arbitary graph vertex will be selected as the root. if the minimum spanning tree does not include all vertices of the graph, then a leftover vertex is selected as a root, and another tree is create a forest from the supplied graph, populating the supplied forest, which must be empty. if the supplied root is null, or not present in the graph, then an arbitary graph vertex will be selected as the root. if the minimum spanning tree does not include all vertices of the graph, then a leftover vertex is selected as a root, and another tree is returns the generated forest."
edu.uci.ics.jung.algorithms.shortestpath.PrimMinimumSpanningTree "for the input graph, creates a minimumspanningtree using a variation of prim's algorithm. creates an instance which generates a minimum spanning tree assuming constant edge weights. creates an instance which generates a minimum spanning tree using the input edge weights. the graph to find mst in pick an arbitrary vertex to make root if there is no obvious root, pick any vertex this graph has no vertices find the lowest cost edge, get its opposite endpoint, and then update forest from its successors"
edu.uci.ics.jung.algorithms.shortestpath.ShortestPath "an interface for algorithms that calculate shortest paths. returns a map which maps each vertex in the graph (including the source vertex) to the last edge on the shortest path from the source vertex. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.shortestpath.ShortestPathUtils "utilities relating to the shortest paths in a graph. returns a list of the edges on the shortest path from source to target, in order of their occurrence on this path. jung.sourceforge.net/license.txt for a description. incoming.getopposite(current);"
edu.uci.ics.jung.algorithms.shortestpath.UnweightedShortestPath "computes the shortest path distances for graphs whose edges are not weighted (using bfs). constructs and initializes algorithm the graph @see edu.uci.ics.jung.algorithms.shortestpath.distance#getdistance(object, object) @see edu.uci.ics.jung.algorithms.shortestpath.distance#getdistancemap(object) @see edu.uci.ics.jung.algorithms.shortestpath.shortestpath#getincomingedgemap(object) computes the shortest path distances from a given node to all other nodes. the source node clears all stored distances for this instance. should be called whenever the graph is modified (edge weights changed or edges added/removed). if the clears all stored distances for the specified source vertex source. should be called whenever the stored distances from this vertex are invalidated by changes to the graph. @see #reset() jung.sourceforge.net/license.txt for a description. bfsdistancelabeler uses -1 to indicate unreachable vertices; don't bother to store unreachable vertices v neighbor = mgraph.getopposite(vertex, incomingedge);"
edu.uci.ics.jung.algorithms.transformation.DirectionTransformer "functions for transforming graphs into directed or undirected graphs. transforms graph (which may be of any directionality) into an undirected graph. (this may be useful for visualization tasks). specifically:  vertices are copied from graph. directed edges are 'converted' into a single new undirected edge in the new graph. each undirected edge (if any) in graph is 're transforms graph (which may be of any directionality) into a directed graph. specifically:  vertices are copied from graph. undirected edges are 'converted' into two new antiparallel directed edges in the new graph. each directed edge (if any) in graph is 're jung.sourceforge.net/license.txt for a description. if the edge is directed, just add it"
edu.uci.ics.jung.algorithms.transformation.FoldingTransformer "methods for creating a "folded" graph based on a k-partite graph or a hypergraph. a "folded" graph is derived from a k-partite graph by identifying a partition of vertices which will become the vertices of the new graph, copying these vertices into the new graph, and then connecting those vertices whose original analogues were connected indirectly through elements of other partitions. a "folded" graph is derived from a hypergraph by creating vertices based on either the vertices or the hyperedges of the original graph, and connecting vertices in the new graph if their corresponding vertices/hyperedges share a connection with a common hyperedge/vertex. converts g into a unipartite graph whose vertex set is the vertices of g's partition p. for vertices a and b in this partition, the resultant graph will include the edge (a,b) if the original graph contains edges (a,c) and (c,b) for at least one vertex c. the vertices of the new graph are the same as the vertices of the appropriate partition in the old graph; the edges in the new graph are converts g into a unipartite graph whose vertices are the vertices of g's partition p, and whose edges consist of collections of the intermediate vertices from other partitions. for vertices a and b in this partition, the resultant graph will include the edge (a,b) if the original graph contains edges (a,c) and (c,b) for at least one vertex c. the vertices of the new graph are the same as the vertices of the appropriate partition in the old graph; the edges in the new graph are collections of the intermediate vertices c. this function will not create self-loops.  vertex type  input edge type input k-partite graph predicate specifying vertex partition _factory factory used to create the output graph result of folding g into unipartite graph whose vertices are those of the p partition of g creates a graph which is an edge-folded version of h, where hyperedges are replaced by k-cliques in the output graph. the vertices of the new graph are the same objects as the vertices of h, and a is connected to b in the new graph if the corresponding vertices in h are connected by a hyperedge. thus, each hyperedge with k vertices in h induces a k-clique in the new graph. the edges of the new graph consist of collections of each hyperedge that connected the corresponding vertex pair in the original graph.  vertex type  input edge type hypergraph to be folded _factory factory used to generate the output graph copy of the input graph where hyperedges are replaced by cliques creates a graph which is an edge-folded version of h, where hyperedges are replaced by k-cliques in the output graph. the vertices of the new graph are the same objects as the vertices of h, and a is connected to b in the new graph if the corresponding vertices in h are connected by a hyperedge. thus, each hyperedge with k vertices in h induces a k-clique in the new graph. the edges of the new graph are generated by the specified edge factory.  vertex type  input edge type hypergraph to be folded _factory factory used to generate the output graph _factory factory used to create the new edges copy of the input graph where hyperedges are replaced by cliques creates a graph which is a vertex-folded version of h, whose vertices are the input's hyperedges and whose edges are induced by adjacent hyperedges in the input. the vertices of the new graph are the same objects as the hyperedges of h, and a is connected to b in the new graph if the corresponding edges in h have a vertex in common. thus, each vertex incident to k edges in h induces a k-clique in the new graph. the edges of the new graph are creates a graph which is a vertex-folded version of h, whose vertices are the input's hyperedges and whose edges are induced by adjacent hyperedges in the input. the vertices of the new graph are the same objects as the hyperedges of h, and a is connected to b in the new graph if the corresponding edges in h have a vertex in common. thus, each vertex incident to k edges in h induces a k-clique in the new graph. the edges of the new graph consist of collections of each vertex incident to the corresponding hyperedge pair in the original graph. hypergraph to be folded _factory factory used to generate the output graph transformation of the input graph whose vertices correspond to the input's hyperedges and edges are induced by hyperedges sharing vertices in the input  jung.sourceforge.net/license.txt for a description. get vertices for the specified partition get vertices for the specified partition, copy into new graph"
edu.uci.ics.jung.algorithms.transformation.VertexPartitionCollapser "this class transforms a graph with a known vertex partitioning into a graph whose vertices correspond to the input graph's partitions. two vertices in the output graph are connected if and only if there exists at least one edge between vertices in the corresponding partitions of the input graph. if the output graph permits parallel edges, there will be an edge connecting two vertices in the new graph for each such edge connecting constituent vertices in the input graph. concept based on danyel fisher's graphcollapser in jung 1.x. creates an instance with the specified graph and element factories. _factory used to construct the vertices of the new graph _factory used to construct the edges of the new graph _factory used to construct the new graph creates a new graph whose vertices correspond to the partitions of the supplied graph. new graph whose vertices correspond to the partitions of the supplied graph returns a transformer from vertex sets in the original graph to collapsed vertices in the transformed graph. jung.sourceforge.net/license.txt for a description. create vertices in new graph corresponding to equivalence sets in the original graph create edges in new graph corresponding to edges in original graph collect the collapsed vertices corresponding to the original incident vertices if there's only one collapsed vertex, continue (no edges to create)"
edu.uci.ics.jung.algorithms.util.BasicMapEntry "an simple minimal implementation of map.entry.  the key type  the value type create new entry. this method is invoked whenever the value in an entry is overwritten by an invocation of put(k,v) for a key k that's already in the hashmap. this method is invoked whenever the entry is removed from the table."
edu.uci.ics.jung.algorithms.util.ConstantMap "an implementation of map that returns the constructor-supplied value for any input.  the key type  the value type creates an instance whose {@code get} method always returns {@code value}. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.util.DiscreteDistribution "a utility class for calculating properties of discrete distributions. generally, these distributions are represented as arrays of double values, which are assumed to be normalized such that the entries in a single array sum to 1. returns the kullback-leibler divergence between the two specified distributions, which must have the same number of elements. this is defined as the sum over all i of dist[i] math.log(dist[i] / reference[i]). note that this value is not symmetric; see symmetrickl for a symmetric variant. @see #symmetrickl(double[], double[]) returns kullbackleibler(dist, reference) + kullbackleibler(reference, dist). @see #kullbackleibler(double[], double[]) returns the squared difference between the two specified distributions, which must have the same number of elements. this is defined as the sum over all i of the square of (dist[i] - reference[i]). returns the cosine distance between the two specified distributions, which must have the same number of elements. the distributions are treated as vectors in dist.length-dimensional space. given the following definitions  v = the sum over all i of dist[i] dist[i] w = the sum over all i of reference[i] reference[i] vw = the sum over all i of dist[i] reference[i]  the value returned is defined as vw / (math.sqrt(v) math.sqrt(w)). returns the entropy of this distribution. high entropy indicates that the distribution is close to uniform; low entropy indicates that the distribution is close to a dirac delta (i.e., if the probability mass is concentrated at a single point, this method returns 0). entropy is defined as the sum over all i of -(dist[i] math.log(dist[i])) throws an illegalargumentexception if the two arrays are not of the same length. normalizes, with lagrangian smoothing, the specified double array, so that the values sum to 1 (i.e., can be treated as probabilities). the effect of the lagrangian smoothing is to ensure that all entries are nonzero; effectively, a value of alpha is added to each entry in the original array prior to normalization. returns the mean of the specified collection of distributions, which are assumed to be normalized arrays of double values. @see #mean(double[][]) returns the mean of the specified array of distributions, represented as normalized arrays of double values. will throw an "index out of bounds" exception if the distribution arrays are not all of the same length. jung.sourceforge.net/license.txt for a description. dot product xx dot product yy dot product xy cosine distance between v and w"
edu.uci.ics.jung.algorithms.util.Indexer "a class providing static methods useful for improving the performance of graph algorithms. returns a bidimap mapping each element of the collection to its index as encountered while iterating over the collection. the purpose of the index operation is to supply an o(1) replacement operation for the o(n) indexof(element) method of a list  bidirectional map from collection elements to 0-based indices returns a bidimap mapping each element of the collection to its index as encountered while iterating over the collection. the purpose of the index operation is to supply an o(1) replacement operation for the o(n) indexof(element) method of a list  start index bidirectional map from collection elements to start-based indices jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.util.IterativeContext "an interface for algorithms that proceed iteratively. advances one step. returns true if this iterative process is finished, and false otherwise. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.util.IterativeProcess "provides basic infrastructure for iterative algorithms. services provided include:   storage of current and max iteration count   framework for initialization, iterative evaluation, and finalization   test for convergence   etc.    algorithms that subclass this class are typically used in the following way:   fooalgorithm foo = new fooalgorithm(...) foo.setmaximumiterations(100); //set up conditions ... foo.evaluate(); //key method which initiates iterative process foo.getsomeresult();  number of iterations performed. maximum allowed number of iterations. desired precision. achieved precision. generic constructor. performs the iterative process. note: this method does not return anything because java does not allow mixing double, int, or objects evaluate the result of the current iteration. perform eventual clean-up operations (must be implement by subclass when needed). returns the desired precision. returns the number of iterations performed. returns the maximum allowed number of iterations. returns the attained precision. the precision to set check to see if the result has been attained. initializes internal parameters to start the iterative process.  double double defines the desired precision. defines the maximum allowed number of iterations. jung.sourceforge.net/license.txt for a description. set up conditions key method which initiates iterative process"
edu.uci.ics.jung.algorithms.util.KMeansClusterer "groups items into a specified number of clusters, based on their proximity in d-dimensional space, using the k-means algorithm. calls to cluster will terminate when either of the two following conditions is true:  the number of iterations is &gt; max_iterations none of the centroids has moved as much as convergence_threshold since the previous iteration  creates an instance whose termination conditions are set according to the parameters. creates an instance with max iterations of 100 and convergence threshold of 0.001. returns the maximum number of iterations. sets the maximum number of iterations. returns the convergence threshold. sets the convergence threshold. _threshold returns a collection of clusters, where each cluster is represented as a map of objects to locations in d-dimensional space. _locations a map of the objects to cluster, to double arrays that specify their locations in d-dimensional space. _clusters the number of clusters to create @throws notenoughclustersexception assigns each object to the cluster whose centroid is closest to the object. _locations a map of objects to locations the centroids of the clusters to be formed map of objects to assigned clusters sets the seed used by the internal random number generator. enables consistent outputs. an exception that indicates that the specified data points cannot be clustered into the number of clusters requested by the jung.sourceforge.net/license.txt for a description. create the specified number of clusters put items in their initial clusters keep reconstituting clusters until either (a) membership is stable, or (b) number of iterations passes max_iterations, or (c) max movement of any centroid is <= convergence_threshold calculate new mean for each cluster todo: check membership of clusters: have they changed? regenerate cluster membership based on means find the cluster with the closest centroid"
edu.uci.ics.jung.algorithms.util.MapBinaryHeap "an array-based binary heap implementation of a priority queue, which also provides efficient update() and contains operations. it contains extra infrastructure (a hash table) to keep track of the position of each element in the array; thus, if the key value of an element changes, it may be "resubmitted" to the heap via update so that the heap can reposition it efficiently, as necessary. creates a mapbinaryheap whose heap ordering is based on the ordering of the elements specified by c. creates a mapbinaryheap whose heap ordering will be based on the natural ordering of the elements, which must be comparable. creates a mapbinaryheap based on the specified collection whose heap ordering will be based on the natural ordering of the elements, which must be comparable. creates a mapbinaryheap based on the specified collection whose heap ordering is based on the ordering of the elements specified by c. @see collection#clear() inserts o into this collection. returns true if this collection contains no elements, and false otherwise. returns the element at the top of the heap; does not alter the heap. removes the element at the top of this heap, and returns it. @deprecated use {@link mapbinaryheap#poll()} or {@link mapbinaryheap#remove()} instead. returns the size of this heap. informs the heap that this object's internal key value has been updated, and that its place in the heap may need to be shifted (up or down). @see collection#contains(java.lang.object) moves the element at position cur closer to the bottom of the heap, or returns if no further motion is necessary. calls itself recursively if further motion is possible. moves the element o at position cur as high as it can go in the heap. returns the new position of the element in the heap. returns the index of the left child of the element at index i of the heap. index of the left child of the element at index i of the heap returns the index of the right child of the element at index i of the heap. index of the right child of the element at index i of the heap returns the index of the parent of the element at index i of the heap. index of the parent of the element at index i of the heap swaps the positions of the elements at indices i and j of the heap. comparator used if none is specified in the constructor. @see java.util.comparator#compare(java.lang.object, java.lang.object) returns an iterator that does not support modification of the heap. this data structure does not support the removal of arbitrary elements. this data structure does not support the removal of arbitrary elements. this data structure does not support the removal of arbitrary elements. jung.sourceforge.net/license.txt for a description. holds the heap as an implicit binary tree maps each object in the heap to its index in the heap the index of the top of the heap index 1 past the end of the heap since we don't know whether the key value increased or decreased, we just percolate up followed by percolating down; one of the two will have no effect. current index reset index to i (new location) place object in heap at appropriate place remove the last element"
edu.uci.ics.jung.algorithms.util.MapSettableTransformer "a settabletransformer that operates on an underlying map instance. similar to maptransformer. creates an instance based on m. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.util.SelfLoopEdgePredicate "a predicate that returns true if the input edge's endpoints in the input graph are identical. (thus, an edge which connects its sole incident vertex to itself).  "
edu.uci.ics.jung.algorithms.util.SettableTransformer "an interface for classes that can set the value to be returned (from transform()) when invoked on a given input. sets the value (output) to be returned by a call to transform(input)). jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.algorithms.util.WeightedChoice "selects items according to their probability in an arbitrary probability distribution. the distribution is specified by a {@code map} from items (of type {@code t}) to weights of type {@code number}, supplied to the constructor; these weights are normalized internally to act as probabilities. this implementation selects items in o(1) time, and requires o(n) space. the default minimum value that is treated as a valid probability (as opposed to rounding error from floating-point operations). equivalent to {@code this(item_weights, new random(), default_threshold)}. _weights equivalent to {@code this(item_weights, new random(), threshold)}. equivalent to {@code this(item_weights, random, default_threshold)}. creates an instance with the specified mapping from items to weights, random number generator, and threshold value. the mapping defines the weight for each item to be selected; this will be proportional to the probability of its selection. the random number generator specifies the mechanism which will be used to provide uniform integer and double values. the threshold indicates default minimum value that is treated as a valid probability (as opposed to rounding error from floating-point operations). adds key/value to the appropriate queue. keys with values less than the threshold get added to {@code light_weights}, all others get added to {@code heavy_weights}. sets the seed used by the internal random number generator. retrieves an item with probability proportional to its weight in the {@code map} provided in the input. manages light object/heavy object/light conditional probability tuples. jung.sourceforge.net/license.txt for a description. repeat until both queues empty put the 'left over' weight from the heavy item--what wasn't needed to make up the difference between the light weight and 1/n--back in the appropriate queue"
edu.uci.ics.jung.graph.AbstractGraph "abstract implementation of the graph interface. designed to simplify implementation of new graph classes. adds {@code edge} to this graph with the specified {@code endpoints}, with the default edge type. {@code} true iff the graph was modified as a result of this call adds {@code edge} to this graph with the specified {@code endpoints} and {@code edgetype}. {@code} true iff the graph was modified as a result of this call jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.AbstractTypedGraph "an abstract class for graphs whose edges all have the same {@code edgetype}. intended to simplify the implementation of such graph classes. the edge type for all edges in this graph. creates an instance with the specified edge type. _type the type of edges that this graph accepts returns this graph's edge type. returns this graph's edge type, or {@code null} if {@code e} is not in this graph. returns the edge set for this graph if {@code edgetype} matches the edge type for this graph, and an empty set otherwise. returns the edge count for this graph if {@code edge_type} matches the edge type for this graph, and 0 otherwise. returns {@code true} if {@code edge_type} matches the default edge type for this graph, and {@code false} otherwise. _type the edge type to compare to this instance's default edge type throws an {@code illegalargumentexception} if {@code edge_type} does not match the default edge type for this graph. _type the edge type to compare to this instance's default edge type jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.DelegateForest "an implementation of forest that delegates to a specified directedgraph instance. creates an instance backed by a new {@code directedsparsegraph} instance. creates an instance backed by the input {@code directedgraph} i add an edge to the tree, connecting v1, the parent and v2, the child. v1 must already exist in the tree, and v2 must not already exist the passed edge must be unique in the tree. passing an edgetype other than edgetype.directed may cause an illegal argument exception in the delegate graph. a unique edge to add 1 the parent node 2 the child node should be edgetype.directed if this call mutates the underlying graph @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object, edu.uci.ics.jung.graph.util.edgetype) add vertex as a root of the tree the tree root to add if this call mutates the underlying graph @see edu.uci.ics.jung.graph.graph#addvertex(java.lang.object) removes edge from this tree, and the subtree rooted at the child vertex incident to edge. (the subtree is removed to ensure that the tree in which the edge was found is still a tree rather than a forest. to change this behavior so that the the edge to remove true iff the tree was modified @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) removes edge from this tree. if remove_subtree is true, removes the subtree rooted at the child vertex incident to edge. otherwise, leaves the subtree intact as a new component tree of this forest. the edge to remove _subtree if true, remove the subtree true iff the tree was modified removes vertex from this tree, and the subtree rooted at vertex. the vertex to remove true iff the tree was modified @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) removes vertex from this tree. if remove_subtrees is true, removes the subtrees rooted at the children of vertex. otherwise, leaves these subtrees intact as new component trees of this forest. the vertex to remove _subtrees if true, remove the subtrees rooted at vertex's children true iff the tree was modified returns an ordered list of the nodes beginning at the root and ending at the passed child node, including all intermediate nodes. the last node in the path from the root ordered list of the nodes from root to child getter for the root of the tree returns null, as this tree has >1 roots root adds root as a root of the tree the initial tree root removes a node from the tree, causing all descendants of the removed node also to be removed the node to remove this call mutates the underlying graph computes and returns the depth of the tree from the root to the passed vertex the node who's depth is computed depth to the passed node. computes and returns the height of the tree height computes and returns whether the passed node is neither the root, nor a leaf node. true if v is neither a leaf nor a root returns true if {@code v} has no child nodes. returns the children of {@code v}. returns true if {@code v} has no parent node. returns the root of each tree of this forest as a {@code collection}. adds {@code tree} to this graph as an element of this forest. the tree to add to this forest as a component"
edu.uci.ics.jung.graph.DelegateTree "an implementation of tree that delegates to a specified instance of directedgraph. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates an instance. create an instance with passed values. must create a directedgraph to use as a delegate creates a new delegatetree which delegates to graph. assumes that graph is already a tree; if it's not, future behavior of this instance is undefined. add an edge to the tree, connecting v1, the parent and v2, the child. v1 must already exist in the tree, and v2 must not already exist the passed edge must be unique in the tree. passing an edgetype other than edgetype.directed may cause an illegal argument exception in the delegate graph. a unique edge to add 1 the parent node 2 the child node should be edgetype.directed if this call mutates the underlying graph @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object, edu.uci.ics.jung.graph.util.edgetype) add an edge to the tree, connecting v1, the parent and v2, the child. v1 must already exist in the tree, and v2 must not already exist the passed edge must be unique in the tree. a unique edge to add 1 the parent node 2 the child node if this call mutates the underlying graph @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object) will set the root of the tree, only if the tree is empty and the root is currently unset. the tree root to set if this call mutates the underlying graph @see edu.uci.ics.jung.graph.graph#addvertex(java.lang.object) @throws unsupportedoperationexception if the root was previously set remove the passed node, and all nodes that are descendants of the passed node. true iff the tree was modified @see edu.uci.ics.jung.graph.graph#removevertex(java.lang.object) add the passed child node as a child of parent. parent must exist in the tree, and child must not already exist. the unique edge to connect the parent and child nodes the existing parent to attach the child to the new child to add to the tree as a child of parent must be edgetype.directed or the underlying graph may throw an exception this call mutates the underlying graph add the passed child node as a child of parent. parent must exist in the tree, and child must not already exist the unique edge to connect the parent and child nodes the existing parent to attach the child to the new child to add to the tree as a child of parent this call mutates the underlying graph get the number of children of the passed parent node get the immediate children nodes of the passed parent get the single parent node of the passed child returns an ordered list of the nodes beginning at the root and ending at {@code vertex}, including all intermediate nodes. the last node in the path from the root ordered list of the nodes from root to child getter for the root of the tree root sets the root to the passed value, only if the root is previously unset the initial tree root removes a node from the tree, causing all descendants of the removed node also to be removed the node to remove this call mutates the underlying graph computes and returns the depth of the tree from the root to the passed vertex the node who's depth is computed depth to the passed node. computes and returns the height of the tree. height returns true if v is neither a leaf nor the root of this tree. true if v is neither a leaf nor the root of this tree returns true if the passed node has no children. true if the passed node has no children computes whether the passed node is a root node (has no children) if(graph.getvertexcount() != 0) throw new illegalargumentexception( "passed directedgraph must be empty"); recalculate height reverse list so that it goes from root to child all edges in a tree connect exactly 2 vertices"
edu.uci.ics.jung.graph.DirectedGraph "a tagging interface for implementations of graph that accept only directed edges. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.DirectedOrderedSparseMultigraph "an implementation of directedgraph, suitable for sparse graphs, that orders its vertex and edge collections according to insertion time. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.DirectedSparseGraph "an implementation of directedgraph suitable for sparse graphs. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates an instance. jung.sourceforge.net/license.txt for a description. map of vertices to pair of adjacency maps {incoming, outgoing} of neighboring vertices to incident edges map of edges to incident vertex pairs map source of this edge to  and vice versa copy to avoid concurrent modification in removeedge remove vertices from each others' adjacency maps"
edu.uci.ics.jung.graph.DirectedSparseMultigraph "an implementation of directedgraph, suitable for sparse graphs, that permits parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description. map of vertices to pair of adjacency sets {incoming, outgoing} map of edges to incident vertex pairs copy to avoid concurrent modification in removeedge remove edge from incident vertices' adjacency sets"
edu.uci.ics.jung.graph.event.GraphEvent "creates an instance with the specified {@code source} graph and {@code type} (vertex/edge addition/removal). types of graph events. an event type pertaining to graph vertices. creates a graph event for the specified graph, vertex, and type. retrieves the vertex associated with this event. an event type pertaining to graph edges. creates a graph event for the specified graph, edge, and type. retrieves the edge associated with this event. source type"
edu.uci.ics.jung.graph.event.GraphEventListener "an interface for classes that listen for graph events. method called by the process generating a graph event to which this instance is listening. the implementor of this interface is responsible for deciding what behavior is appropriate."
edu.uci.ics.jung.graph.Forest "an interface for a graph which consists of a collection of rooted directed acyclic graphs. returns a view of this graph as a collection of tree instances. view of this graph as a collection of trees returns the parent of vertex in this tree. (if vertex is the root, returns null.) the parent of a vertex is defined as being its predecessor in the (unique) shortest path from the root to this vertex. this is a convenience method which is equivalent to graph.getpredecessors(vertex).iterator().next(). parent of vertex in this tree @see graph#getpredecessors(object) @see #getparentedge(object) returns the edge connecting vertex to its parent in this tree. (if vertex is the root, returns null.) the parent of a vertex is defined as being its predecessor in the (unique) shortest path from the root to this vertex. this is a convenience method which is equivalent to graph.getinedges(vertex).iterator().next(), and also to graph.findedge(vertex, getparent(vertex)). edge connecting vertex to its parent, or null if vertex is the root @see graph#getinedges(object) @see #getparent(object) returns the children of vertex in this tree. the children of a vertex are defined as being the successors of that vertex on the respective (unique) shortest paths from the root to those vertices. this is syntactic (maple) sugar for getsuccessors(vertex). the vertex whose children are to be returned collection of children of vertex in this tree @see graph#getsuccessors(object) @see #getchildedges(object) returns the edges connecting vertex to its children in this tree. the children of a vertex are defined as being the successors of that vertex on the respective (unique) shortest paths from the root to those vertices. this is syntactic (maple) sugar for getoutedges(vertex). the vertex whose child edges are to be returned collection of edges connecting vertex to its children in this tree @see graph#getoutedges(object) @see #getchildren(object) returns the number of children that vertex has in this tree. the children of a vertex are defined as being the successors of that vertex on the respective (unique) shortest paths from the root to those vertices. this is syntactic (maple) sugar for getsuccessorcount(vertex). the vertex whose child edges are to be returned collection of edges connecting vertex to its children in this tree @see #getchildedges(object) @see #getchildren(object) @see graph#getsuccessorcount(object)"
edu.uci.ics.jung.graph.Graph "a graph consisting of a set of vertices of type v set and a set of edges of type e. edges of this graph type have exactly two endpoints; whether these endpoints must be distinct depends on the implementation.  this interface permits, but does not enforce, any of the following common variations of graphs:   directed and undirected edges  vertices and edges with attributes (for example, weighted edges)  vertices and edges of different types (for example, bipartite or multimodal graphs)  parallel edges (multiple edges which connect a single set of vertices)  representations as matrices or as adjacency lists or adjacency maps  extensions or implementations of this interface may enforce or disallow any or all of these variations. definitions (with respect to a given vertex v):  incoming edge of v: an edge that can be traversed from a neighbor of v to reach v outgoing edge of v: an edge that can be traversed from v to reach some neighbor of v predecessor of v: a vertex at the other end of an incoming edge of v successor of v: a vertex at the other end of an outgoing edge of v   returns a collection view of the incoming edges incident to vertex in this graph. the vertex whose incoming edges are to be returned a collection view of the incoming edges incident to vertex in this graph returns a collection view of the outgoing edges incident to vertex in this graph. the vertex whose outgoing edges are to be returned a collection view of the outgoing edges incident to vertex in this graph returns a collection view of the predecessors of vertex in this graph. a predecessor of vertex is defined as a vertex v which is connected to vertex by an edge e, where e is an outgoing edge of v and an incoming edge of vertex. the vertex whose predecessors are to be returned a collection view of the predecessors of vertex in this graph returns a collection view of the successors of vertex in this graph. a successor of vertex is defined as a vertex v which is connected to vertex by an edge e, where e is an incoming edge of v and an outgoing edge of vertex. the vertex whose predecessors are to be returned a collection view of the successors of vertex in this graph returns the number of incoming edges incident to vertex. equivalent to getinedges(vertex).size(). the vertex whose indegree is to be calculated the number of incoming edges incident to vertex returns the number of outgoing edges incident to vertex. equivalent to getoutedges(vertex).size(). the vertex whose outdegree is to be calculated the number of outgoing edges incident to vertex returns true if v1 is a predecessor of v2 in this graph. equivalent to v1.getpredecessors().contains(v2). 1 the first vertex to be queried 2 the second vertex to be queried true if v1 is a predecessor of v2, and false otherwise. returns true if v1 is a successor of v2 in this graph. equivalent to v1.getsuccessors().contains(v2). 1 the first vertex to be queried 2 the second vertex to be queried true if v1 is a successor of v2, and false otherwise. returns the number of predecessors that vertex has in this graph. equivalent to vertex.getpredecessors().size(). the vertex whose predecessor count is to be returned the number of predecessors that vertex has in this graph returns the number of successors that vertex has in this graph. equivalent to vertex.getsuccessors().size(). the vertex whose successor count is to be returned the number of successors that vertex has in this graph if directed_edge is a directed edge in this graph, returns the source; otherwise returns null. the source of a directed edge d is defined to be the vertex for which d is an outgoing edge. directed_edge is guaranteed to be a directed edge if its edgetype is directed. _edge the source of directed_edge if it is a directed edge in this graph, or null otherwise if directed_edge is a directed edge in this graph, returns the destination; otherwise returns null. the destination of a directed edge d is defined to be the vertex incident to d for which d is an incoming edge. directed_edge is guaranteed to be a directed edge if its edgetype is directed. _edge the destination of directed_edge if it is a directed edge in this graph, or null otherwise returns true if vertex is the source of edge. equivalent to getsource(edge).equals(vertex). the vertex to be queried the edge to be queried true iff vertex is the source of edge returns true if vertex is the destination of edge. equivalent to getdest(edge).equals(vertex). the vertex to be queried the edge to be queried true iff vertex is the destination of edge adds edge e to this graph such that it connects vertex v1 to v2. equivalent to addedge(e, new pair(v1, v2)). if this graph does not contain v1, v2, or both, implementations may choose to either silently add the vertices to the graph or throw an illegalargumentexception. if this graph assigns edge types to its edges, the edge type of e will be the default for this graph. see hypergraph.addedge() for a listing of possible reasons for failure. the edge to be added 1 the first vertex to be connected 2 the second vertex to be connected true if the add is successful, false otherwise @see hypergraph#addedge(object, collection) @see #addedge(object, object, object, edgetype) adds edge e to this graph such that it connects vertex v1 to v2. equivalent to addedge(e, new pair(v1, v2)). if this graph does not contain v1, v2, or both, implementations may choose to either silently add the vertices to the graph or throw an illegalargumentexception. if edgetype is not legal for this graph, this method will throw illegalargumentexception. see hypergraph.addedge() for a listing of possible reasons for failure. the edge to be added 1 the first vertex to be connected 2 the second vertex to be connected the type to be assigned to the edge true if the add is successful, false otherwise @see hypergraph#addedge(object, collection) @see #addedge(object, object, object) returns the endpoints of edge as a pair. the edge whose endpoints are to be returned endpoints (incident vertices) of edge returns the vertex at the other end of edge from vertex. (that is, returns the vertex incident to edge which is not vertex.) the vertex to be queried the edge to be queried vertex at the other end of edge from vertex jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.GraphDecorator "an implementation of graph that delegates its method calls to a constructor-specified graph instance. this is useful for adding additional behavior (such as synchronization or unmodifiability) to an existing instance. creates a new instance based on the provided {@code delegate}. @see edu.uci.ics.jung.graph.hypergraph#addedge(java.lang.object, java.util.collection) @see hypergraph#addedge(object, collection, edgetype) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object, edu.uci.ics.jung.graph.util.edgetype) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#addvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isincident(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isneighbor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#degree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedge(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedgeset(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#getdest(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getedgecount() @see edu.uci.ics.jung.graph.hypergraph#getedgecount(edgetype) @see edu.uci.ics.jung.graph.hypergraph#getedges() @see edu.uci.ics.jung.graph.graph#getedges(edu.uci.ics.jung.graph.util.edgetype) @see edu.uci.ics.jung.graph.graph#getedgetype(java.lang.object) @see edu.uci.ics.jung.graph.graph#getdefaultedgetype() @see edu.uci.ics.jung.graph.graph#getendpoints(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentcount(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentvertices(java.lang.object) @see edu.uci.ics.jung.graph.graph#getinedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighborcount(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighbors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getopposite(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#getoutedges(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsource(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessors(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getvertexcount() @see edu.uci.ics.jung.graph.hypergraph#getvertices() @see edu.uci.ics.jung.graph.graph#indegree(java.lang.object) @see edu.uci.ics.jung.graph.graph#isdest(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#ispredecessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issource(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issuccessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#outdegree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsvertex(java.lang.object)"
edu.uci.ics.jung.graph.Hypergraph "a hypergraph, consisting of a set of vertices of type v and a set of hyperedges of type e which connect the vertices. this is the base interface for all jung graph types.  this interface permits, but does not enforce, any of the following common variations of graphs:  hyperedges (edges which connect a set of vertices of any size) edges (these have have exactly two endpoints, which may or may not be distinct) self-loops (edges which connect exactly one vertex)  directed and undirected edges  vertices and edges with attributes (for example, weighted edges)  vertices and edges with different constraints or properties (for example, bipartite or multimodal graphs)  parallel edges (multiple edges which connect a single set of vertices)  internal representations as matrices or as adjacency lists or adjacency maps  extensions or implementations of this interface may enforce or disallow any or all of these variations. notes:   the collections returned by hypergraph instances should be treated in general as if read-only. while they are not contractually guaranteed (or required) to be immutable, this interface does not define the outcome if they are mutated. mutations should be done via {add,remove}{edge,vertex}, or in the constructor.   returns a view of all edges in this graph. in general, this obeys the collection contract, and therefore makes no guarantees about the ordering of the vertices within the set. collection view of all edges in this graph returns a view of all vertices in this graph. in general, this obeys the collection contract, and therefore makes no guarantees about the ordering of the vertices within the set. collection view of all vertices in this graph returns true if this graph's vertex collection contains vertex. equivalent to getvertices().contains(vertex). the vertex whose presence is being queried iff this graph contains a vertex vertex returns true if this graph's edge collection contains edge. equivalent to getedges().contains(edge). the edge whose presence is being queried iff this graph contains an edge edge returns the number of edges in this graph. number of edges in this graph returns the number of vertices in this graph. number of vertices in this graph returns the collection of vertices which are connected to vertex via any edges in this graph. if vertex is connected to itself with a self-loop, then it will be included in the collection returned. the vertex whose neighbors are to be returned the collection of vertices which are connected to vertex, or null if vertex is not present returns the collection of edges in this graph which are connected to vertex. the vertex whose incident edges are to be returned the collection of edges which are connected to vertex, or null if vertex is not present returns the collection of vertices in this graph which are connected to edge. note that for some graph types there are guarantees about the size of this collection (i.e., some graphs contain edges that have exactly two endpoints, which may or may not be distinct). implementations for those graph types may provide alternate methods that provide more convenient access to the vertices. the edge whose incident vertices are to be returned the collection of vertices which are connected to edge, or null if edge is not present returns an edge that connects this vertex to v. if this edge is not uniquely defined (that is, if the graph contains more than one edge connecting v1 to v2), any of these edges may be returned. findedgeset(v1, v2) may be used to return all such edges. returns null if either of the following is true:  v2 is not connected to v1 either v1 or v2 are not present in this graph  note: for purposes of this method, v1 is only considered to be connected to v2 via a given directed edge e if v1 == e.getsource() && v2 == e.getdest() evaluates to true. (v1 and v2 are connected by an undirected edge u if u is incident to both v1 and v2.) an edge that connects v1 to v2, or null if no such edge exists (or either vertex is not present) @see hypergraph#findedgeset(object, object) returns all edges that connects this vertex to v. if this edge is not uniquely defined (that is, if the graph contains more than one edge connecting v1 to v2), any of these edges may be returned. findedgeset(v1, v2) may be used to return all such edges. returns null if v2 is not connected to v1. returns an empty collection if either v1 or v2 are not present in this graph. note: for purposes of this method, v1 is only considered to be connected to v2 via a given directed edge d if v1 == d.getsource() && v2 == d.getdest() evaluates to true. (v1 and v2 are connected by an undirected edge u if u is incident to both v1 and v2.) a collection containing all edges that connect v1 to v2, or null if either vertex is not present @see hypergraph#findedge(object, object) adds vertex to this graph. fails if vertex is null or already in the graph. the vertex to add true if the add is successful, and false otherwise @throws illegalargumentexception if vertex is null adds edge to this graph. fails under the following circumstances:  edge is already an element of the graph either edge or vertices is null vertices has the wrong number of vertices for the graph type vertices are already connected by another edge in this graph, and this graph does not accept parallel edges  true if the add is successful, and false otherwise @throws illegalargumentexception if edge or vertices is null, or if a different vertex set in this graph is already connected by edge, or if vertices are not a legal vertex set for edge adds edge to this graph with type edge_type. fails under the following circumstances:  edge is already an element of the graph either edge or vertices is null vertices has the wrong number of vertices for the graph type vertices are already connected by another edge in this graph, and this graph does not accept parallel edges edge_type is not legal for this graph  true if the add is successful, and false otherwise @throws illegalargumentexception if edge or vertices is null, or if a different vertex set in this graph is already connected by edge, or if vertices are not a legal vertex set for edge removes vertex from this graph. as a side effect, removes any edges e incident to vertex if the removal of vertex would cause e to be incident to an illegal number of vertices. (thus, for example, incident hyperedges are not removed, but incident edges--which must be connected to a vertex at both endpoints--are removed.) fails under the following circumstances:  vertex is not an element of this graph vertex is null  the vertex to remove true if the removal is successful, false otherwise removes edge from this graph. fails if edge is null, or is otherwise not an element of this graph. the edge to remove true if the removal is successful, false otherwise returns true if v1 and v2 share an incident edge. equivalent to getneighbors(v1).contains(v2). 1 the first vertex to test 2 the second vertex to test true if v1 and v2 share an incident edge returns true if vertex and edge are incident to each other. equivalent to getincidentedges(vertex).contains(edge) and to getincidentvertices(edge).contains(vertex). true if vertex and edge are incident to each other returns the number of edges incident to vertex. special cases of interest:   incident self-loops are counted once.  if there is only one edge that connects this vertex to each of its neighbors (and vice versa), then the value returned will also be equal to the number of neighbors that this vertex has (that is, the output of getneighborcount).  if the graph is directed, then the value returned will be the sum of this vertex's indegree (the number of edges whose destination is this vertex) and its outdegree (the number of edges whose source is this vertex), minus the number of incident self-loops (to avoid double-counting).  equivalent to getincidentedges(vertex).size(). the vertex whose degree is to be returned degree of this node @see hypergraph#getneighborcount(object) returns the number of vertices that are adjacent to vertex (that is, the number of vertices that are incident to edges in vertex's incident edge set). equivalent to getneighbors(vertex).size(). the vertex whose neighbor count is to be returned number of neighboring vertices returns the number of vertices that are incident to edge. for hyperedges, this can be any nonnegative integer; for edges this must be 2 (or 1 if self-loops are permitted). equivalent to getincidentvertices(edge).size(). the edge whose incident vertex count is to be returned number of vertices that are incident to edge. returns the edge type of edge in this graph. edgetype of edge, or null if edge has no defined type returns the default edge type for this graph. default edge type for this graph returns the collection of edges in this graph which are of type edge_type. _type the type of edges to be returned collection of edges which are of type edge_type, or null if the graph does not accept edges of this type @see edgetype returns the number of edges of type edge_type in this graph. _type the type of edge for which the count is to be returned number of edges of type edge_type in this graph returns a collection view of the incoming edges incident to vertex in this graph. the vertex whose incoming edges are to be returned a collection view of the incoming edges incident to vertex in this graph returns a collection view of the outgoing edges incident to vertex in this graph. the vertex whose outgoing edges are to be returned a collection view of the outgoing edges incident to vertex in this graph returns the number of incoming edges incident to vertex. equivalent to getinedges(vertex).size(). the vertex whose indegree is to be calculated the number of incoming edges incident to vertex returns the number of outgoing edges incident to vertex. equivalent to getoutedges(vertex).size(). the vertex whose outdegree is to be calculated the number of outgoing edges incident to vertex if directed_edge is a directed edge in this graph, returns the source; otherwise returns null. the source of a directed edge d is defined to be the vertex for which d is an outgoing edge. directed_edge is guaranteed to be a directed edge if its edgetype is directed. _edge the source of directed_edge if it is a directed edge in this graph, or null otherwise if directed_edge is a directed edge in this graph, returns the destination; otherwise returns null. the destination of a directed edge d is defined to be the vertex incident to d for which d is an incoming edge. directed_edge is guaranteed to be a directed edge if its edgetype is directed. _edge the destination of directed_edge if it is a directed edge in this graph, or null otherwise returns a collection view of the predecessors of vertex in this graph. a predecessor of vertex is defined as a vertex v which is connected to vertex by an edge e, where e is an outgoing edge of v and an incoming edge of vertex. the vertex whose predecessors are to be returned a collection view of the predecessors of vertex in this graph returns a collection view of the successors of vertex in this graph. a successor of vertex is defined as a vertex v which is connected to vertex by an edge e, where e is an incoming edge of v and an outgoing edge of vertex. the vertex whose predecessors are to be returned a collection view of the successors of vertex in this graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.KPartiteGraph "an interface for graphs whose vertices are each members of one of 2 or more disjoint sets (partitions), and whose edges connect only vertices in distinct partitions. returns all vertices which satisfy the specified partition predicate. predicate which defines a partition vertices satisfying partition returns the set of predicate instances which define this graph's partitions. set of predicate instances which define this graph's partitions jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.MultiGraph "a tagging interface which indicates that the implementing graph accepts parallel edges. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.ObservableGraph "a decorator class for graphs which generates events creates a new instance based on the provided {@code delegate}. adds {@code l} as a listener to this graph. removes {@code l} as a listener to this graph. @see edu.uci.ics.jung.graph.hypergraph#addedge(java.lang.object, java.util.collection) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object, edu.uci.ics.jung.graph.util.edgetype) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#addvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) remove all incident edges first, so that the appropriate events will be fired (otherwise they'll be removed inside {@code delegate.removevertex} and the events will not be fired)"
edu.uci.ics.jung.graph.OrderedKAryTree "an implementation of tree in which each vertex has  the vertex type for the graph factory  the edge type for the graph factory creates a new instance with the specified order (maximum number of children). returns the number of children that {@code vertex} has. @see edu.uci.ics.jung.graph.tree#getchildcount(java.lang.object) returns the child edge of the vertex at index index. child edge of the vertex at index index @see edu.uci.ics.jung.graph.tree#getchildedges(java.lang.object) returns an ordered list of {@code vertex}'s child vertices. if there is no child in position i, then the list will contain {@code null} in position i. if {@code vertex} has no children then the empty set will be returned. @see edu.uci.ics.jung.graph.tree#getchildren(java.lang.object) @see edu.uci.ics.jung.graph.tree#getdepth(java.lang.object) depth of the vertex in this tree, or -1 if the vertex is not present in this tree returns the height of the tree, or -1 if the tree is empty. @see edu.uci.ics.jung.graph.tree#getheight() @see edu.uci.ics.jung.graph.tree#getparent(java.lang.object) @see edu.uci.ics.jung.graph.tree#getparentedge(java.lang.object) @see edu.uci.ics.jung.graph.tree#getroot() @see edu.uci.ics.jung.graph.forest#gettrees() adds the specified {@code child} vertex and edge {@code e} to the graph with the specified parent vertex {@code parent}. if {@code index} is greater than or equal to 0, then the child is placed at position {@code index}; if it is less than 0, the child is placed at the lowest available position; if it is greater than or equal to the order of this tree, an exception is thrown. @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#addedge(java.lang.object, java.lang.object, java.lang.object, edu.uci.ics.jung.graph.util.edgetype) @see edu.uci.ics.jung.graph.graph#getdest(java.lang.object) @see edu.uci.ics.jung.graph.graph#getendpoints(java.lang.object) @see edu.uci.ics.jung.graph.graph#getinedges(java.lang.object) @see edu.uci.ics.jung.graph.graph#getopposite(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#getoutedges(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessorcount(java.lang.object) 0 if vertex is the root, -1 if the vertex is not an element of this tree, and 1 otherwise @see edu.uci.ics.jung.graph.graph#getpredecessors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsource(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessors(java.lang.object) @see edu.uci.ics.jung.graph.graph#indegree(java.lang.object) @see edu.uci.ics.jung.graph.graph#isdest(java.lang.object, java.lang.object) returns true if vertex is a leaf of this tree, i.e., if it has no children. the vertex to be queried true if outdegree(vertex)==0 returns true iff v1 is the parent of v2. note that if v2 is the root and v1 is null, this method returns true. @see edu.uci.ics.jung.graph.graph#ispredecessor(java.lang.object, java.lang.object) returns true if vertex is a leaf of this tree, i.e., if it has no children. the vertex to be queried true if outdegree(vertex)==0 @see edu.uci.ics.jung.graph.graph#issource(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issuccessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#outdegree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#addedge(java.lang.object, java.util.collection) @see edu.uci.ics.jung.graph.hypergraph#addvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isincident(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isneighbor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedge(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedgeset(java.lang.object, java.lang.object) returns the child of vertex at position index in this tree, or null if it has no child at that position. the vertex to query child of vertex at position index in this tree, or null if it has no child at that position @throws arrayindexoutofboundsexception if index is not in the range {@code [0, order-1]} @see edu.uci.ics.jung.graph.hypergraph#getedgecount() @see edu.uci.ics.jung.graph.hypergraph#getedges() @see edu.uci.ics.jung.graph.hypergraph#getincidentcount(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentvertices(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighborcount(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighbors(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getvertexcount() @see edu.uci.ics.jung.graph.hypergraph#getvertices() @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) jung.sourceforge.net/license.txt for a description. initialize vertexdata for child; leave child's child_edges null for now all tree edges have 2 incident vertices recursively remove all of vertex's children"
edu.uci.ics.jung.graph.OrderedSparseMultigraph "an implementation of graph that orders its vertex and edge collections according to insertion time, is suitable for sparse graphs, and permits directed, undirected, and parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.SetHypergraph "an implementation of hypergraph that is suitable for sparse graphs and permits parallel edges. returns a factory which creates instances of this class.  vertex type of the hypergraph to be creates a sethypergraph and initializes the internal data structures. adds hyperedge to this graph and connects them to the vertex collection to_attach. any vertices in to_attach that appear more than once will only appear once in the incident vertex collection for hyperedge, that is, duplicates will be ignored. @see hypergraph#addedge(object, collection) @see hypergraph#addedge(object, collection, edgetype) @see hypergraph#getedgetype(object) jung.sourceforge.net/license.txt for a description. map of vertices to incident hyperedge sets map of hyperedges to incident vertex sets add v if it's not already in the graph associate v with hyperedge"
edu.uci.ics.jung.graph.SortedSparseMultigraph "an implementation of graph that is suitable for sparse graphs, orders its vertex and edge collections according to either specified comparator instances or the natural ordering of their elements, and permits directed, undirected, and parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory comparator used in ordering vertices. defaults to util.comparablecomparator if no comparators are specified in the constructor. comparator used in ordering edges. defaults to util.comparablecomparator if no comparators are specified in the constructor. creates a new instance which sorts its vertices and edges according to the specified {@code comparator}s. creates a new instance which sorts its vertices and edges according to their natural ordering. provides a new {@code comparator} to be used in sorting the vertices. _comparator the comparator that defines the new ordering jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.SparseGraph "an implementation of graph that is suitable for sparse graphs and permits both directed and undirected edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates an instance. jung.sourceforge.net/license.txt for a description. map of vertices to adjacency maps of vertices to {incoming, outgoing, incident} edges map of directed edges to incident vertex sets map of undirected edges to incident vertex sets undirected edges and directed edges are not considered to be parallel to each other, so as long as anything that's returned by findedge is not of the same type as edge, we're fine map v1 to  and vice versa combine directed inedges and undirected combine directed outedges and undirected consider directed inedges and undirected consider directed outedges and undirected consider directed edges and undirected edges copy to avoid concurrent modification in removeedge remove edge from incident vertices' adjacency maps"
edu.uci.ics.jung.graph.SparseMultigraph "an implementation of graph that is suitable for sparse graphs and permits directed, undirected, and parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description. todo: refactor internal representation: right now directed edges each have two references (in vertices and directededges) and undirected also have two (incoming and outgoing). map of vertices to pair of adjacency sets {incoming, outgoing} map of edges to incident vertex pairs copy to avoid concurrent modification in removeedge remove edge from incident vertices' adjacency sets its an undirected edge, remove the other ends todo: this will need to get changed if we modify the internal representation todo: this will need to get changed if we modify the internal representation"
edu.uci.ics.jung.graph.Tree "a subtype of graph which is a (directed, rooted) tree. what we refer to as a "tree" here is actually (in the terminology of graph theory) a rooted tree. (that is, there is a designated single vertex--the root--from which we measure the shortest path to each vertex, which we call its depth; the maximum over all such depths is the tree's height. note that for a tree, there is exactly one unique path from the root to any vertex.) returns the (unweighted) distance of vertex from the root of this tree. the vertex whose depth is to be returned. length of the shortest unweighted path from vertex to the root of this tree @see #getheight() returns the maximum depth in this tree. maximum depth in this tree @see #getdepth(object) returns the root of this tree. the root is defined to be the vertex (designated either at the tree's creation time, or as the first vertex to be added) with respect to which vertex depth is measured. root of this tree jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.UndirectedGraph "a tagging interface for extensions of graph that accept only undirected edges. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.UndirectedOrderedSparseMultigraph "an implementation of undirectedgraph that is suitable for sparse graphs, orders its vertex and edge collections according to insertion time, and permits parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.UndirectedSparseGraph "an implementation of undirectedgraph that is suitable for sparse graphs. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates an instance. jung.sourceforge.net/license.txt for a description. map of vertices to adjacency maps of vertices to incident edges map of edges to incident vertex sets map v1 to  and vice versa if (!containsvertex(v1) || !containsvertex(v2)) return edge_collection; iterate over copy of incident edge collection remove incident vertices from each others' adjacency maps"
edu.uci.ics.jung.graph.UndirectedSparseMultigraph "an implementation of undirectedgraph that is suitable for sparse graphs and permits parallel edges. returns a {@code factory} that creates an instance of this graph type.  the vertex type for the graph factory  the edge type for the graph factory creates a new instance. jung.sourceforge.net/license.txt for a description. jung.sourceforge.net/license.txt for a description. map of vertices to adjacency sets map of edges to incident vertex sets remove edge from incident vertices' adjacency sets"
edu.uci.ics.jung.graph.util.Context "a class that is used to link together a graph element and a specific graph. provides appropriate implementations of hashcode and equals. the graph element which defines this context. the edge element which defines this context. returns an instance of this type for the specified graph and element.  the graph type  the element type"
edu.uci.ics.jung.graph.util.DefaultParallelEdgeIndexFunction "a class which creates and maintains indices for parallel edges. parallel edges are defined here to be the collection of edges that are returned by v.findedgeset(w) for some v and w. at this time, returns an instance of this class.  the vertex type  the edge type returns the index for e in graph. calculates the indices for e and for all edges parallel to e, if they are not already assigned. resets the indices for this edge and its parallel edges. should be invoked when an edge parallel to e has been added or removed. clears all edge indices for all edges in all graphs. does not recalculate the indices. jung.sourceforge.net/license.txt for a description. edge_index.get(e); remove loops remove edges in opposite direction"
edu.uci.ics.jung.graph.util.EdgeIndexFunction "an interface for a service to access the index of a given edge (in a given graph) into the set formed by the given edge and all the other edges it is parallel to. note that in current use, this index is assumed to be an integer value in the interval [0,n-1], where n-1 is the number of edges parallel to e. returns e's index in graph. the index of e is defined as its position in some consistent ordering of e and all edges parallel to e. the graph in which the edge is to be queried the edge whose index is to be queried e's index in graph resets the indices for edge and its parallel edges in graph. should be invoked when an edge parallel to edge has been added or removed. the graph in which edge's index is to be reset the edge whose index is to be reset clears all edge indices for all edges in all graphs. does not recalculate the indices. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.util.EdgeType "defines the possible edge types for graphs which assign types to edges. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.util.Graphs "provides specialized implementations of graphdecorator. currently these wrapper types include "synchronized" and "unmodifiable". the methods of this class may each throw a nullpointerexception if the graphs or class objects provided to them are null. returns a synchronized graph backed by the passed argument graph.  the vertex type  the edge type the graph for which a synchronized wrapper is to be returns a synchronized directedgraph backed by the passed directedgraph.  the vertex type  the edge type the graph for which a synchronized wrapper is to be returns a synchronized undirectedgraph backed by the passed undirectedgraph.  the vertex type  the edge type the graph for which a synchronized wrapper is to be returns a synchronized forest backed by the passed forest.  the vertex type  the edge type the forest for which a synchronized wrapper is to be returns a synchronized tree backed by the passed tree.  the vertex type  the edge type the tree for which a synchronized wrapper is to be returns an unmodifiable graph backed by the passed graph.  the vertex type  the edge type the graph for which the unmodifiable wrapper is to be returned unmodifiable graph backed by the passed graph returns an unmodifiable directedgraph backed by the passed graph.  the vertex type  the edge type the graph for which the unmodifiable wrapper is to be returned unmodifiable directedgraph backed by the passed graph returns an unmodifiable undirectedgraph backed by the passed graph.  the vertex type  the edge type the graph for which the unmodifiable wrapper is to be returned unmodifiable undirectedgraph backed by the passed graph returns an unmodifiable tree backed by the passed tree.  the vertex type  the edge type the tree for which the unmodifiable wrapper is to be returned unmodifiable tree backed by the passed tree returns an unmodifiable forest backed by the passed forest.  the vertex type  the edge type the forest for which the unmodifiable wrapper is to be returned unmodifiable forest backed by the passed forest @see edu.uci.ics.jung.graph.graph#getdefaultedgetype() @see edu.uci.ics.jung.graph.graph#addedge(object, object, object, edgetype) @see edu.uci.ics.jung.graph.hypergraph#addedge(object, collection, edgetype) @see edu.uci.ics.jung.graph.graph#addedge(object, object, object) @see edu.uci.ics.jung.graph.hypergraph#addvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isincident(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isneighbor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#degree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedge(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedgeset(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getedges() @see edu.uci.ics.jung.graph.graph#getedges(edgetype) @see edu.uci.ics.jung.graph.graph#getendpoints(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentvertices(java.lang.object) @see edu.uci.ics.jung.graph.graph#getinedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighbors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getopposite(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#getoutedges(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessors(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getvertices() @see edu.uci.ics.jung.graph.hypergraph#getedgecount() @see edu.uci.ics.jung.graph.hypergraph#getedgecount(edgetype) @see edu.uci.ics.jung.graph.hypergraph#getvertexcount() @see edu.uci.ics.jung.graph.graph#indegree(java.lang.object) @see edu.uci.ics.jung.graph.graph#getedgetype(java.lang.object) @see edu.uci.ics.jung.graph.graph#ispredecessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issuccessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighborcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#outdegree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) @see edu.uci.ics.jung.graph.graph#getdest(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsource(java.lang.object) @see edu.uci.ics.jung.graph.graph#isdest(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issource(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentcount(object) @see edu.uci.ics.jung.graph.hypergraph#addedge(java.lang.object, java.util.collection) @see edu.uci.ics.jung.graph.hypergraph#containsedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsvertex(java.lang.object) creates a new instance based on the provided {@code delegate}. creates a new instance based on the provided {@code delegate}. @see edu.uci.ics.jung.graph.graph#getdefaultedgetype() @see edu.uci.ics.jung.graph.graph#addedge(object, object, object, edgetype) @see edu.uci.ics.jung.graph.graph#addedge(object, collection, edgetype) @see edu.uci.ics.jung.graph.graph#addedge(object, object, object) @see edu.uci.ics.jung.graph.hypergraph#addvertex(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isincident(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#isneighbor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#degree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedge(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#findedgeset(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getedges() @see edu.uci.ics.jung.graph.hypergraph#getedgecount() @see edu.uci.ics.jung.graph.hypergraph#getedgecount(edgetype) @see edu.uci.ics.jung.graph.hypergraph#getvertexcount() @see edu.uci.ics.jung.graph.graph#getedges(edu.uci.ics.jung.graph.util.edgetype) @see edu.uci.ics.jung.graph.graph#getendpoints(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentvertices(java.lang.object) @see edu.uci.ics.jung.graph.graph#getinedges(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighbors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getopposite(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#getoutedges(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessors(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessors(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getvertices() @see edu.uci.ics.jung.graph.graph#indegree(java.lang.object) @see edu.uci.ics.jung.graph.graph#getedgetype(java.lang.object) @see edu.uci.ics.jung.graph.graph#ispredecessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issuccessor(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getneighborcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getpredecessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsuccessorcount(java.lang.object) @see edu.uci.ics.jung.graph.graph#outdegree(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removeedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#removevertex(java.lang.object) @see edu.uci.ics.jung.graph.graph#getdest(java.lang.object) @see edu.uci.ics.jung.graph.graph#getsource(java.lang.object) @see edu.uci.ics.jung.graph.graph#isdest(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.graph#issource(java.lang.object, java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#getincidentcount(object) @see edu.uci.ics.jung.graph.hypergraph#addedge(java.lang.object, java.util.collection) @see edu.uci.ics.jung.graph.hypergraph#containsedge(java.lang.object) @see edu.uci.ics.jung.graph.hypergraph#containsvertex(java.lang.object)"
edu.uci.ics.jung.graph.util.IncidentEdgeIndexFunction "a class which creates and maintains indices for incident edges. returns an instance of this type.  the vertex type  the edge type returns the index for the specified edge. calculates the indices for e and for all edges parallel to e. resets the indices for this edge and its parallel edges. should be invoked when an edge parallel to e has been added or removed. clears all edge indices for all edges in all graphs. does not recalculate the indices. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.util.Pair "an implementation of collection that stores exactly 2 non-null objects and is not mutable. they respect equals and may be used as indices or map keys. note that they do not protect from malevolent behavior: if one or another object in the tuple is mutable, then it can be changed with the usual bad effects. creates a pair from the specified elements. 1 the first value in the new pair 2 the second value in the new pair @throws illegalargumentexception if either argument is null creates a pair from the passed collection. the size of the collection must be 2. the elements of the new pair @throws illegalargumentexception if the input collection is null, contains null values, or has != 2 elements. creates a pair from the passed array. the size of the array must be 2. @throws illegalargumentexception if the input array is null, contains null values, or has != 2 elements. returns the first element. returns the second element. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.graph.util.TestGraphs "provides generators for several different test graphs. a series of pairs that may be useful for generating graphs. the miniature graph consists of 8 edges, 10 nodes, and is formed of two connected components, one of 8 nodes, the other of 2. creates a small sample graph that can be used for testing purposes. the graph is as described in the section on {@link #pairs pairs}. if isdirected, the graph is a {@link directedsparsemultigraph directedsparsemultigraph}, otherwise, it is an {@link undirectedsparsemultigraph undirectedsparsemultigraph}. graph consisting of eight edges and ten nodes. returns a graph consisting of a chain of vertex_count - 1 vertices plus one isolated vertex. creates a sample directed acyclic graph by generating several "layers", and connecting nodes (randomly) to nodes in earlier (but never later) layers. each layer has some random number of nodes in it 1 less than n less than maxnodesperlayer. returns a bigger, undirected test graph with a just one component. this graph consists of a clique of ten edges, a partial clique (randomly generated, with edges of 0.6 probability), and one series of edges running from the first node to the last. testgraph returns a bigger test graph with a clique, several components, and other parts. demonstration graph of type undirectedsparsemultigraph with 28 vertices. returns a small graph with directed and undirected edges, and parallel edges. jung.sourceforge.net/license.txt for a description. for each previous node... let's throw in a clique, too and, last, a partial clique and one edge to connect them all let's throw in a clique, too and, last, a partial clique"
edu.uci.ics.jung.graph.util.TreeUtils "contains static methods for operating on instances of tree. returns the roots of this forest.  the vertex type  the edge type returns the subtree of tree which is rooted at root as a forest. the tree returned is an independent entity, although it uses the same vertex and edge objects.  the vertex type  the edge type the tree whose subtree is to be extracted the root of the subtree to be extracted subtree of tree which is rooted at root @throws instantiationexception if a new tree of the same type cannot be populates subtree with the subtree of tree which is rooted at root.  the vertex type  the edge type the tree whose subtree is to be extracted the tree instance which is to be populated with the subtree of tree the root of the subtree to be extracted connects subtree to tree by attaching it as a child of node with edge connectingedge.  the vertex type  the edge type the tree to which subtree is to be added the tree which is to be grafted on to tree the parent of subtree in its new position in tree the edge used to connect subtree's root as a child of node adds the trees in source to destination. source is left unchanged. the vertex and edge objects in source will also be used in destination, in the same (structural) roles.  the vertex type  the edge type the forest to which the trees in source will be added the forest whose trees will be added to destination fixme also note that this is redundant with delegateforest.addtree() jung.sourceforge.net/license.txt for a description. public static  void mergeforests(forest destination, forest source) { for (tree tree : source.gettrees()) { v root = tree.getroot(); // fixme this is not done: addchildrentoforest is not yet complete // also still need to integrate into mst2, etc. (see email thread) // addchildrentoforest(destination, tree, root); for (e e: tree.getoutedges(root)) { v child = tree.getopposite(root, e); addfromsubtree(destination, source, e, root, child); } } } add edge connecting parent and root to tree fixme: not done or integrated yet private static  void addchildrentoforest(forest forest, tree tree, v subtree_root) { v parent = tree.getpredecessors(subtree_root).iterator().next(); for (e e : tree.getoutedges(subtree_root)) { v child = tree.getopposite(subtree_root, e); addchildrentoforest(forest, tree, child); } }"
edu.uci.ics.jung.io.GraphFile "general interface for loading and saving a graph from/to disk. loads a graph from a file per the appropriate format the location and name of the file graph save a graph to disk per the appropriate format the location and name of the file the graph jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.GraphIOException "exception thrown when io errors occur when reading/writing graphs. creates a new instance with no specified message or cause. creates a new instance with the specified message and cause. creates a new instance with the specified message and no specified cause. creats a new instance with the specified cause and no specified message. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.AbstractMetadata "abstract base class for metadata - implements the property functionality jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.DataMetadata "metadata structure for the 'data' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.graphml.EdgeMetadata "metadata structure for the 'edge' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.graphml.EndpointMetadata "metadata structure for the 'endpoint' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.graphml.ExceptionConverter "converts an exception to the a graphioexception. runtime exceptions are checked for the cause. if the cause is an xmlstreamexception, it is converted to a graphioexception. otherwise, the runtimeexception is rethrown. converts an exception to the a graphioexception. runtime exceptions are checked for the cause. if the cause is an xmlstreamexception, it is converted to a graphreaderexception. otherwise, the runtimeexception is rethrown. the exception to be converted @throws graphioexception the converted exception jung.sourceforge.net/license.txt for a description. if the cause was an xmlstreamexception, throw a graphreaderexception"
edu.uci.ics.jung.io.graphml.GraphMetadata "metadata structure for the 'graph' graphml element. gets the property for the given vertex object. the subject vertex the property key property value @throws illegalargumentexception thrown if there is no metadata associated with the provided vertex object. gets the property for the given edge object. the subject edge. the property key property value @throws illegalargumentexception thrown if there is no metadata associated with the provided edge object. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html" first, try standard edges. next, try hyperedges. couldn't find the edge."
edu.uci.ics.jung.io.graphml.GraphMLConstants "provides some constants for element/attribute names in graphml jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.GraphMLDocument "maintains all the metadata read in from a single graphml xml document. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.GraphMLReader2 "reads in data from a graphml-formatted file and generates graphs based on that data. does not currently support nested graphs.   note that the constructs a graphml reader around the given reader. this constructor requires the gets the current transformer that is being used for graph objects. current transformer. gets the current transformer that is being used for vertex objects. current transformer. gets the current transformer that is being used for edge objects. current transformer. gets the current transformer that is being used for hyperedge objects. current transformer. verifies the object state and initializes this reader. all transformer properties must be set and be non-null or a graphreaderexception  will be thrown. this method may be called more than once. successive calls will have no effect. @throws edu.uci.ics.jung.io.graphioexception thrown if an error occurred. closes the graphml reader and disposes of any resources. @throws edu.uci.ics.jung.io.graphioexception thrown if an error occurs. returns the object that contains the metadata read in from the graphml document graphml document reads a single graph object from the graphml document. automatically calls init to initialize the state of the reader. graph that was read if one was found, otherwise null. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html" create the parser registry. create the event reader. clear the contents of the document. initialize if not already. the element should be one of: key, graph, graphml parse the key object. add the key to the key map. parse the graph. add it to the graph metadata list. return the graph object. ignore the graphml object. encounted an unknown element - just skip by it. we didn't read anything from the document."
edu.uci.ics.jung.io.graphml.HyperEdgeMetadata "metadata structure for the 'hyperedge' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.graphml.Key "graphml key object that was parsed from the input stream. enumeration for the 'for' type of this key. the for property indicates which elements (e.g. graph, node, edge) this key applies to. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.KeyMap "a keymap is a storage mechanism for the keys read from the graphml file. it stores the keys indexed by the type of graphml metadata (node, edge, etc) that the key applies to. the applykeys method will obtain the list of keys that apply to the given metadata type and apply the keys one-by-one to the metadata. adds the given key to the map. the key to be added. applies all keys that are applicable to the given metadata. the target metadata. clears this map. retrieves the set of entries contained in this map. of the entries in this map. gets the list for the given metadata type. if doesn't exist, the list is jung.sourceforge.net/license.txt for a description. default = all"
edu.uci.ics.jung.io.graphml.Metadata "interface for any graphml metadata. metadata type enumeration gets the metadata type of this object. metadata type gets any properties that were associated with this metadata in the graphml properties jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.NodeMetadata "metadata structure for the 'node' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.graphml.parser.AbstractElementParser "base class for element parsers - provides some minimal functionality. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.parser.DataElementParser "parses the data element. jung.sourceforge.net/license.txt for a description. create the new port. parse the attributes. make sure the key has been set. treat any child elements as unknown"
edu.uci.ics.jung.io.graphml.parser.EdgeElementParser "parses an edge element. jung.sourceforge.net/license.txt for a description. create the new edge. parse the attributes. make sure the source and target have been been set. treat anything else as unknown apply the keys to this object."
edu.uci.ics.jung.io.graphml.parser.ElementParser "interface for all element parsers. all parsers will be registered with the registry. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.parser.ElementParserRegistry "registry for all element parsers. jung.sourceforge.net/license.txt for a description. create the parser context."
edu.uci.ics.jung.io.graphml.parser.EndpointElementParser "parses endpoint elements. jung.sourceforge.net/license.txt for a description. create the new endpoint. parse the attributes. make sure the node has been set. treat anything else as unknown apply the keys to this object."
edu.uci.ics.jung.io.graphml.parser.GraphElementParser "parses graph elements. jung.sourceforge.net/license.txt for a description. create the new graph. parse the attributes. make sure the graphdefault has been set. parse the description and set it in the graph. parse the data element and store the property in the graph. parse the node metadata create the vertex object and store it in the metadata add it to the graph parse the edge metadata set the directed property if not overridden. create the edge object and store it in the metadata add it to the graph. parse the edge metadata create the edge object and store it in the metadata add it to the graph treat anything else as unknown apply the keys to this object. create the graph object and store it in the metadata add all of the vertices to the graph object. add the edges to the graph object. get the edge out of the metadata get the verticies. add it to the graph. get the edge out of the metadata add the verticies to a list. add it to the graph."
edu.uci.ics.jung.io.graphml.parser.GraphMLEventFilter "filter to ignore unsupported xml events. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.parser.HyperEdgeElementParser "parses hyper edge elements. jung.sourceforge.net/license.txt for a description. create the new edge. parse the attributes. treat anything else as unknown apply the keys to this object."
edu.uci.ics.jung.io.graphml.parser.KeyElementParser "parses key elements. jung.sourceforge.net/license.txt for a description. create the new key. fortype defaults to all. parse the attributes. make sure the id has been set. treat anything else as unknown"
edu.uci.ics.jung.io.graphml.parser.NodeElementParser "parses node elements. jung.sourceforge.net/license.txt for a description. create the new node. parse the attributes. make sure the name has been set. treat anything else as unknown apply the keys to this object."
edu.uci.ics.jung.io.graphml.parser.ParserContext "provides resources related to the current parsing context. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.graphml.parser.PortElementParser "parses port elements. jung.sourceforge.net/license.txt for a description. create the new port. parse the attributes. make sure the name has been set. treat anything else as unknown apply the keys to this port."
edu.uci.ics.jung.io.graphml.parser.StringElementParser "parses an element that just contains text. jung.sourceforge.net/license.txt for a description. parse the unknown element."
edu.uci.ics.jung.io.graphml.parser.UnknownElementParser "skips an entire unknown subtree of the xml skips an entire subtree starting with the provided unknown element. the event reader the unknown element to be skipped. jung.sourceforge.net/license.txt for a description. push the name of the unknown element. pop the stack."
edu.uci.ics.jung.io.graphml.PortMetadata "metadata structure for the 'port' graphml element. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html""
edu.uci.ics.jung.io.GraphMLMetadata "maintains information relating to data for the specified type. this includes a transformer from objects to their values, a default value, and a description. the description of this data type. the default value for objects of this type. a transformer from objects to string representations of their values. creates a new instance with the specified description, default value, and transformer. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.GraphMLReader "reads in data from a graphml-formatted file and generates graphs based on that data. currently supports the following parts of the graphml specification:  graphs and hypergraphs directed and undirected edges graph, vertex, edge data graph, vertex, edge descriptions and data descriptions vertex and edge ids  each of these is exposed via appropriate get methods. does not currently support nested graphs or ports. note that the creates a graphmlreader instance with the specified vertex and edge factories. _factory the vertex factory to use to create vertex objects _factory the edge factory to use to create edge objects @throws parserconfigurationexception @throws saxexception creates a graphmlreader instance that assigns the vertex and edge id strings to be the vertex and edge objects, as well as their ids. note that this requires that (a) each edge have a valid id, which is not normally a requirement for edges in graphml, and (b) that the vertex and edge types be assignment-compatible with string. @throws parserconfigurationexception @throws saxexception returns a list of the graphs parsed from the specified reader, as returns a list of the graphs parsed from the specified file, as populates the specified graph with the data parsed from the reader. @throws ioexception populates the specified graph with the data parsed from the specified file. @throws ioexception this is separate from initialize() because these data structures are shared among all graphs loaded (i.e., they're defined inside graphml rather than graph.  _map _elt returns a bidirectional map relating vertices and ids. returns a bidirectional map relating edges and ids. this is not guaranteed to always be populated (edge ids are not required in graphml files. returns a map from graph type name to type metadata. returns a map from vertex type name to type metadata. returns a map from edge type name to type metadata. returns a map from graphs to graph descriptions. returns a map from vertices to vertex descriptions. returns a map from edges to edge descriptions. jung.sourceforge.net/license.txt for a description. graphml.graphdrawing.org/specification.html" graph factory is null if there's only one graph reset all non-key data structures (to avoid collisions between different graphs) set up default direction of edges put remaining attribute/value pairs in graph_data load in the default values; these override anything that might be in the attribute map (because that's not really a proper way to associate data) place remaining items in data if there's a default value, don't override it go back one put remaining attribute/value pairs in vertex_data , id); put remaining attribute/value pairs in edge_data , string id)"
edu.uci.ics.jung.io.GraphMLWriter "writes graphs out in graphml format. current known issues:  only supports one graph per output file. does not indent lines for text-format readability.   @throws ioexception provides an id that will be used to identify a vertex in the output file. if the vertex ids are not set, the id for each vertex will default to the output of tostring (and thus not guaranteed to be unique). _ids provides an id that will be used to identify an edge in the output file. if any edge id is missing, no id will be written out for the corresponding edge. _ids provides a map from data type name to graph data. provides a map from data type name to vertex data. provides a map from data type name to edge data. adds a new graph data specification. adds a new vertex data specification. adds a new edge data specification. provides vertex descriptions. provides edge descriptions. provides graph descriptions. jung.sourceforge.net/license.txt for a description. write out boilerplate header graphml.graphdrawing.org/xmlns/graphml\"\n" + www.w3.org/2001/xmlschema-instance\" \n"); graphml.graphdrawing.org/xmlns/graphml\">\n"); write out data specifiers, including defaults write out graph-level information set edge default direction write graph description, if any write graph data out if any write vertex information write edge information close graph public boolean save(collection> graphs, writer w) { return true; } write description out if any write data out if any no contents; close the node with "/>" add id if present add id if present add edge type if doesn't match default write description out if any write data out if any if this is a hyperedge, write endpoints out if any no contents; close the edge with "/>" write out description if any write out default if any"
edu.uci.ics.jung.io.GraphReader "interface for a reader of graph objects reads a single graph object, if one is available. next graph object, or null if none exists. @throws graphioexception thrown if an error occurred. closes this resource and frees any resources. @throws graphioexception thrown if an error occurred. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.MatrixFile "basic i/o handler for ascii matrix files. an ascii matrix is simply a square matrix where 0 values for cell (i,j) indicates no edge exists between vertex i and vertex j and non-zero values indicates there is an edge. if a non-null weight key is specified then it will be used to treat the non-zero values as a weight stored in the edges' constructs matrixfile instance. if weightkey is not null then, it will attempt to use that key to store and retreive weights from the edges' loads a graph from an input reader the input reader graph @throws ioexception loads a graph from a file. @see edu.uci.ics.jung.io.graphfile#load(java.lang.string) saves a graph to a file @see edu.uci.ics.jung.io.graphfile#save(edu.uci.ics.jung.graph.graph, java.lang.string) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.io.PajekNetReader "reads a graph from a pajek net formatted source. if the edge constraints specify that the graph is strictly undirected, and an "arcs" section is encountered, or if the edge constraints specify that the graph is strictly directed, and an "edges" section is encountered, an illegalargumentexception is thrown. if the edge constraints do not permit parallel edges, only the first encountered of a set of parallel edges will be read; subsequent edges in that set will be ignored. more restrictive edge constraints will cause vertices to be generated that are more time- and space-efficient. at the moment, only supports the part of the specification that defines:   vertex ids (each must have a value from 1 to n, where n is the number of vertices)  vertex labels (must be in quotes if interrupted by whitespace)  directed edge connections (single or list)  undirected edge connections (single or list)  edge weights (not compatible with edges specified in list form) note: this version of pajeknetreader does not support multiple edge weights, as pajeknetfile does; this behavior is consistent with the net format.  vertex locations (x and y; z coordinate is ignored)   here is an example format for a directed graph without edge weights and edges specified in list form:   vertices  1 "a" 2 "b" 3 "c" arcslist 1 2 3 2 3  here is an example format for an undirected graph with edge weights and edges specified in non-list form:   vertices  1 "a" 2 "b" 3 "c" edges 1 2 0.1 1 3 0.9 2 3 1.0  the map for vertex labels (if any) the map for vertex locations (if any) defined by this class. used to specify whether the most recently read line is a pajek-specific tag. creates a pajeknetreader instance with the specified vertex and edge factories. _factory the factory to use to create vertex objects _factory the factory to use to create edge objects creates a pajeknetreader instance with the specified edge factory, and whose vertex objects correspond to the integer ids assigned in the file. note that this requires v to be assignment-compatible with an integer value. _factory the factory to use to create edge objects returns the graph returns the graph returns the graph populates the graph g with the graph represented by the pajek-format data supplied by reader. stores edge weights, if any, according to nev (if non-null). any existing vertices/edges of g, if any, are unaffected. the edge data are filtered according to g's constraints, if any; thus, if g only accepts directed edges, any undirected edges in the input are ignored. @throws ioexception parses curline as a reference to a vertex, and optionally assigns label and location information. returns the first line read from br for which p returns true, or null if there is no such line. @throws ioexception a predicate which evaluates to true if the argument starts with the constructor-specified string. a predicate which evaluates to true if the argument ends with the string "list". vertexlocationtransformer provides a transformer which will be used to write out the vertex locations. returns a transformer from vertices to their labels. provides a transformer which will be used to write out the vertex labels. returns a transformer from edges to their weights. provides a transformer which will be used to write out edge weights. jung.sourceforge.net/license.txt for a description. vlado.fmf.uni-lj.si/pub/networks/pajek/doc/pajekman.pdf" ignore everything until we see 'vertices' no vertices in the graph; return empty graph create appropriate number of vertices skip past "vertices"; read vertices until we see any pajek format tag ('...') skip blank lines skip over the intermediate stuff (if any) and read the next arcs/edges section that we find ditto index of first coordinate in parts; -1 indicates no coordinates found if there are quote marks on this line, split on them; label is surrounded by them if there are any quote marks, there should be exactly 2 no quote marks, but are there coordinates? just the id; nothing to do, continue just the id and a label id, no label, coordinates id, label, (x,y) coordinates, maybe some other stuff go from 1-based to 0-based index only attach the label if there's one to attach parse the rest of the line in case we're not there yet (i.e., format tag isn't arcs or edges) skip blank lines one source, multiple destinations one source, one destination, at most one weight get the edge weight if we care don't error-check this: let the graph implementation do whatever it's going to do (add the edge, replace the existing edge, throw an exception--depends on the graph implementation)"
edu.uci.ics.jung.io.PajekNetWriter "writes graphs in the pajek net format. labels for vertices may optionally be specified by implementations of vertexstringer. edge weights are optionally specified by implementations of transformer. vertex locations are optionally specified by implementations of transformer. note that vertex location coordinates must be normalized to the interval [0, 1] on each axis in order to conform to the pajek specification. creates a new instance. saves g to filename. labels for vertices may be supplied by vs. edge weights are specified by nev. @throws ioexception saves g to filename. labels are specified by vs, and edge weights by nev; vertex coordinates are not written out. the graph to write out @throws ioexception saves g to filename; no vertex labels are written out, and the edge weights are written as 1.0. @throws ioexception saves g to w; no vertex labels are written out, and the edge weights are written as 1.0. @throws ioexception saves g to w; vertex labels are given by vs and edge weights by nev. @throws ioexception writes graph to w. labels for vertices may be supplied by vs (defaults to no labels if null), edge weights may be specified by nev (defaults to weights of 1.0 if null), and vertex locations may be specified by vld (defaults to no locations if null). todo: changes we might want to make: - optionally writing out in list form jung.sourceforge.net/license.txt for a description. indexer.getindexer(graph); convert from 0-based to 1-based index if it's strictly one or the other, no need to create extra sets mixed-mode graph write out directed edges write out undirected edges"
edu.uci.ics.jung.visualization.annotations.AnnotatingGraphMousePlugin "annotatinggraphmouseplugin can create shape and text annotations in a layer of the graph visualization. additional modifiers for the action of adding to an existing selection used to draw a shape annotation the paintable for the shape annotation a paintable to store all annotations color for annotations layer for annotations holds rendering transforms holds rendering settings set to true when the annotationpaintable has been added to the view component create an instance with default settings create an instance with overides for primary selection for additional selection the lenscolor. the lenscolor to set. the paintable that draws a shape annotation only while it is being sets the location for an annotation. will either pop up a dialog to prompt for text input for a text annotation, or begin the process of drawing a shape annotation the event completes the process of adding a shape annotation and removed the transient paintable draws the transient paintable that will become a shape annotation when the mouse button is released rect the rect to set layer the layer to set fill the fill to set jung.sourceforge.net/license.txt for a description. this.annotationpaintable = new annotationpaintable(rc);"
edu.uci.ics.jung.visualization.annotations.AnnotatingModalGraphMouse "a graph mouse that supplies an annotations mode create an instance with default values create an instance with passed values override value for scale in override value for scale out create the plugins, and load the plugins for transforming mode setter for the mode. (non-javadoc) @see edu.uci.ics.jung.visualization.control.modalgraphmouse#setpickingmode() (non-javadoc) @see edu.uci.ics.jung.visualization.control.modalgraphmouse#settransformingmode() the modebox. create (if necessary) and return a menu that will change the mode menu jung.sourceforge.net/license.txt for a description. {"
edu.uci.ics.jung.visualization.annotations.Annotation "stores an annotation, either a shape or a string annotation the annotation to set location layer the layer to set the location to set paint the paint to set fill the fill to set jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.annotations.AnnotationControls "a collection of controls for annotations. allows selection of colors, shapes, etc jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.annotations.AnnotationManager "handles the selection of annotations, and the support for the tools to draw them at specific layers. jung.sourceforge.net/license.txt for a description. unrotate the annotation"
edu.uci.ics.jung.visualization.annotations.AnnotationPaintable "handles the actual drawing of annotations annotations jung.sourceforge.net/license.txt for a description. unrotate the annotation"
edu.uci.ics.jung.visualization.annotations.AnnotationRenderer "annotationrenderer is similar to the cell renderers used by the jtable and jtree jfc classes. creates a default table cell renderer. overrides jcomponent.setforeground to assign the unselected-foreground color to the specified color. set the foreground color to this value overrides jcomponent.setbackground to assign the unselected-background color to the specified color. set the background color to this value notification from the uimanager that the look and feel [l&f] has changed. replaces the current ui object with the latest version from the uimanager. @see jcomponent#updateui returns the default label renderer for an edge the visualizationviewer to render on the value to assign to the label for edge the edge default label renderer the following methods are overridden as a performance measure to to prune code-paths are often called in the case of renders but which we know are unnecessary. great care should be taken when writing your own renderer to weigh the benefits and drawbacks of overriding methods like these. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. sets the string object for the cell being rendered to value. the string value for this cell; if value is null it sets the text value to an empty string @see jlabel#settext jung.sourceforge.net/license.txt for a description. if(font != null) { setfont(font); } else { } strings get interned..."
edu.uci.ics.jung.visualization.BasicTransformer "a basic implementation of the multilayertransformer interface that provides two layers: view and layout. it also provides changeeventsupport creates an instance and notifies the view and layout transformers to listen to changes published by this instance. @see edu.uci.ics.jung.visualization.multilayertransformer#setviewtransformer(edu.uci.ics.jung.visualization.transform.mutabletransformer) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#setlayouttransformer(edu.uci.ics.jung.visualization.transform.mutabletransformer) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#getlayouttransformer() (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#getviewtransformer() (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inversetransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inverseviewtransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inverselayouttransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#transform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#viewtransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#layouttransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inversetransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inverseviewtransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#inverselayouttransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#transform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#viewtransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#layouttransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.multilayertransformer#settoidentity() (non-javadoc) (non-javadoc) (non-javadoc) (non-javadoc) (non-javadoc)"
edu.uci.ics.jung.visualization.BasicVisualizationServer "a class that maintains many of the details necessary for creating visualizations of graphs. this is the old visualizationviewer without tooltips and mouse behaviors. its purpose is to be a base class that can also be used on the server side of a multi-tiered application. holds the state of this view handles the actual drawing of graph elements rendering hints used in drawing. anti-aliasing is on by default holds the state of which vertices of the graph are currently 'picked' holds the state of which edges of the graph are currently 'picked' a listener used to cause pick events to result in repaints, even if they come from another view an offscreen image to render the graph used if doublebuffered is set to true graphics context for the offscreen image used if doublebuffered is set to true  a collection of a collection of create an instance with passed parameters. the layout to apply, with its associated graph the renderer to draw it with create an instance with passed parameters. the layout to apply, with its associated graph the renderer to draw it with the preferred size of this view create an instance with passed parameters. create an instance with passed parameters. initial preferred size of the view always sanity-check getsize so that we don't use a value that is improbable @see java.awt.component#getsize() ensure that, if doublebuffering is enabled, the offscreen image buffer exists and is the correct size. (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#getmodel() (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setmodel(edu.uci.ics.jung.visualization.visualizationmodel) (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#statechanged(javax.swing.event.changeevent) (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setrenderer(edu.uci.ics.jung.visualization.renderer) (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#getrenderer() (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setgraphlayout(edu.uci.ics.jung.visualization.layout.layout) visualizationlistener reacts to changes in the size of the visualizationviewer. when the size changes, it ensures that the offscreen image is sized properly. if the layout is locked to this view size, then the layout is also resized to be the same as the view size. create a new offscreen image for the graph whenever the window is resied (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setpickededgestate(edu.uci.ics.jung.visualization.picking.pickedstate) (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#getpicksupport() (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setpicksupport(edu.uci.ics.jung.visualization.graphelementaccessor) (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#getcenter() (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#getrendercontext() (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setrendercontext(edu.uci.ics.jung.visualization.rendercontext) jung.sourceforge.net/license.txt for a description. rendercontext.setscreendevice(this); the size of the visualizationviewer clear the offscreen image viewtransformer.gettransform()); if there are prerenderers set, paint them if there are postrenderers set, do it"
edu.uci.ics.jung.visualization.control.AbsoluteCrossoverScalingControl "scales to the absolute value passed as an argument. it first resets the scaling transformers, then uses the relative crossoverscalingcontrol to achieve the absolute value. scale to the absolute value passed as 'amount'. jung.sourceforge.net/license.txt for a description. return the transformers to 1.0"
edu.uci.ics.jung.visualization.control.AbstractGraphMousePlugin "a base class for graphmouseplugin instances. holds some members common to all graphmouseplugins modifiers to compare against mouse event modifiers the location in the view where the mouse was pressed the special cursor that plugins may display create an instance with passed values getter for mouse modifiers setter for mouse modifiers check the mouse event modifiers against the instance member modifiers. default implementation checks equality. can be overridden to test with a mask the cursor. the cursor to set. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.AbstractModalGraphMouse "abstractmodalgraphmouse is a pluggablegraphmouse class that manages a collection of plugins for picking and transforming the graph. additionally, it carries the notion of a mode: picking or translating. switching between modes allows for a more natural choice of mouse modifiers to be used for the various plugins. the default modifiers are intended to mimick those of mainstream software applications in order to be intuitive to used by the scaling plugins for zoom in used by the scaling plugins for zoom out a listener for mode changes a jcombobox control available to set the mode a menu available to set the mode the current mode listeners for mode changes create the plugins, and load the plugins for transforming mode setter for the mode. (non-javadoc) @see edu.uci.ics.jung.visualization.control.modalgraphmouse#setpickingmode() (non-javadoc) @see edu.uci.ics.jung.visualization.control.modalgraphmouse#settransformingmode() the zoomatmouse to set. listener to set the mode from an external event source (non-javadoc) @see edu.uci.ics.jung.visualization.control.modalgraphmouse#getmodelistener() modekeylistener the modekeylistener to set the modebox. create (if necessary) and return a menu that will change the mode menu add a listener for mode changes remove a listener for mode changes returns an array of all the itemlisteners added to this jcombobox with additemlistener(). of the itemlisteners added or an empty array if no listeners have been added notifies all listeners that have registered interest for notification on this event type. the event of interest @see eventlistenerlist jung.sourceforge.net/license.txt for a description. { guaranteed to return a non-null array process the listeners last to first, notifying those that are interested in this event"
edu.uci.ics.jung.visualization.control.AbstractPopupGraphMousePlugin "if this is the popup trigger, process here, otherwise defer to the superclass  jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.AnimatedPickingGraphMousePlugin "animatedpickinggraphmouseplugin supports the picking of one graph vertex. when the mouse is released, the graph is translated so that the picked vertex is moved to the center of the view. this translateion is conducted in an animation thread so that the graph slides to its new position the picked vertex create an instance with default modifiers create an instance, overriding the default modifiers if the event occurs on a vertex, pick that single vertex the event if a vertex was picked in the mousepressed event, start a thread to animate the translation of the graph so that the picked vertex moves to the center of the view the event show a special cursor while the mouse is inside the window revert to the default cursor when the mouse leaves this window jung.sourceforge.net/license.txt for a description. p is the screen point for the mouse event"
edu.uci.ics.jung.visualization.control.CrossoverScalingControl "a scaling control that has a crossover point. when the overall scale of the view and model is less than the crossover point, the scaling is applied to the view's transform and the graph nodes, labels, etc grow smaller. this preserves the overall shape of the graph. when the scale is larger than the crossover, the scaling is applied to the graph layout. the graph spreads out, but the vertices and labels grow no larger than their original size. point where scale crosses over from view to layout. sets the crossover point to the specified value. returns the current crossover value. @see edu.uci.ics.jung.visualization.control.scalingcontrol#scale(visualizationviewer, float, point2d) jung.sourceforge.net/license.txt for a description. close to the control point, return both transformers to a scale of sqrt crossover value scale the viewtransformer, return the layouttransformer to sqrt crossover value scale the layouttransformer, return the viewtransformer to crossover value"
edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse "defaultmodalgraphmouse is a pluggablegraphmouse class that pre-installs a large collection of plugins for picking and transforming the graph. additionally, it carries the notion of a mode: picking or translating. switching between modes allows for a more natural choice of mouse modifiers to be used for the various plugins. the default modifiers are intended to mimick those of mainstream software applications in order to be intuitive to create an instance with default values create an instance with passed values override value for scale in override value for scale out create the plugins, and load the plugins for transforming mode jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.EditingGraphMousePlugin "a plugin that can create vertices, undirected edges, and directed edges using mouse gestures. create instance and prepare shapes for visual effects overridden to be more flexible, and pass events with key combinations. the default responds to both buttonone and buttonone+shift if the mouse is pressed in an empty area, create a new vertex there. if the mouse is pressed on an existing vertex, prepare to create an edge from that vertex to another if startvertex is non-null, and the mouse is released over an existing vertex, create an undirected edge from startvertex to the vertex under the mouse pointer. if shift was also pressed, create a directed edge instead. if startvertex is non-null, stretch an edge shape between startvertex and the mouse pointer to simulate edge creation code lifted from pluggablerenderer to move an edge shape into an arbitrary position used for the edge creation visual effect during mouse drag used for the directed edge creation visual effect during mouse drag set default edge type get ready to make an edge make a new vertex"
edu.uci.ics.jung.visualization.control.EditingModalGraphMouse "create an instance with default values create an instance with passed values override value for scale in override value for scale out create the plugins, and load the plugins for transforming mode setter for the mode. modebox. create (if necessary) and return a menu that will change the mode menu annotatingplugin editingplugin labeleditingplugin popupeditingplugin {"
edu.uci.ics.jung.visualization.control.EditingPopupGraphMousePlugin "a plugin that uses popup menus to create vertices, undirected edges, and directed edges."
edu.uci.ics.jung.visualization.control.GraphMouseAdapter "simple extension of mouseadapter that supplies modifier checking jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.GraphMouseListener "this interface allows jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.GraphMousePlugin "the interface for all plugins to the pluggablegraphmouse return the mouse event modifiers that will activate this plugin set the mouse event modifiers that will activate this plugin compare the set modifiers against those of the supplied event an event to compare to the member modifers match the event modifiers jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.LabelEditingGraphMousePlugin "the picked vertex, if any the picked edge, if any create an instance with default settings create an instance with overides for primary selection for additional selection for primary modifiers (default, mousebutton1): pick a single vertex or edge that is under the mouse pointer. if no vertex or edge is under the pointer, unselect all picked vertices and edges, and set up to draw a rectangle for multiple selection of contained vertices. for additional selection (default shift+mousebutton1): add to the selection, a single vertex or edge that is under the mouse pointer. if a previously picked vertex or edge is under the pointer, it is un-picked. if no vertex or edge is under the pointer, set up to draw a multiple selection rectangle (as above) but do not unpick previously picked elements. the event if the mouse is dragging a rectangle, pick the vertices contained in that rectangle clean up settings from mousepressed if the mouse is over a picked vertex, drag all picked vertices with the mouse. if the mouse is not over a vertex, draw the rectangle to select multiple vertices jung.sourceforge.net/license.txt for a description. p is the screen point for the mouse event p is the screen point for the mouse event take away the view transform todo auto-generated method stub todo auto-generated method stub"
edu.uci.ics.jung.visualization.control.LayoutScalingControl "layoutscalingcontrol applies a scaling transformation to the graph layout. the vertices get closer or farther apart, but do not themselves change size. scalinggraphmouse uses mousewheelevents to apply the scaling. zoom the display in or out, depending on the direction of the mouse wheel motion. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.LensMagnificationGraphMousePlugin "hyperbolicmagnificationgraphmouseplugin changes the magnification within the hyperbolic projection of the hyperbolictransformer. create an instance with default zoom in/out values create an instance with passed modifiers override to check equality with a mask zoom the display in or out, depending on the direction of the mouse wheel motion. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.LensTranslatingGraphMousePlugin "extends translatinggraphmouseplugin and adds the capability to drag and resize the viewing lens in the graph view. mouse1 in the center moves the lens, mouse1 on the edge resizes the lens. the default mouse button and modifiers can be overridden in the constructor. create an instance with default modifiers create an instance with passed modifer value the mouse event modifier to activate this function check the event modifiers. set the 'down' point for later use. if this event satisfies the modifiers, change the cursor to the system 'move cursor' the event called to change the location of the lens called to change the radius of the lens called to set up translating the lens center or changing the size unset the 'down' point and change the cursoe back to the system default cursor check the modifiers. if accepted, move or resize the lens according to the dragging of the mouse pointer the event jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ModalGraphMouse "interface for a graphmouse that supports modality. the modelistener.  jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ModalLensGraphMouse "an implementation of the abstractmodalgraphmouse that includes plugins for manipulating a view that is using a lenstransformer. not included in the base class jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ModalSatelliteGraphMouse "jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.MouseListenerTranslator "this class translates mouse clicks into vertex clicks  transform the point to the coordinate system in the visualizationviewer, then use either picksuuport (if available) or layout to find a vertex @return @see java.awt.event.mouselistener#mouseclicked(java.awt.event.mouseevent) @see java.awt.event.mouselistener#mousepressed(java.awt.event.mouseevent) @see java.awt.event.mouselistener#mo jung.sourceforge.net/license.txt for a description. adjust for scale and offset in the visualizationviewer vv.getrendercontext().getbasictransformer().inverseviewtransform(point);"
edu.uci.ics.jung.visualization.control.PickingGraphMousePlugin "pickinggraphmouseplugin supports the picking of graph elements with the mouse. mousebuttonone picks a single vertex or edge, and mousebuttontwo adds to the set of selected vertices or edgetype. if a vertex is selected and the mouse is dragged while on the selected vertex, then that vertex will be repositioned to follow the mouse until the button is released. the picked vertex, if any the picked edge, if any the x distance from the picked vertex center to the mouse point the y distance from the picked vertex center to the mouse point controls whether the vertices may be moved with the mouse additional modifiers for the action of adding to an existing selection used to draw a rectangle to contain picked vertices the paintable for the lens picking rectangle color for the picking rectangle create an instance with default settings create an instance with overides for primary selection for additional selection the lenscolor. the lenscolor to set. a paintable to draw the rectangle used to pick multiple vertices for primary modifiers (default, mousebutton1): pick a single vertex or edge that is under the mouse pointer. if no vertex or edge is under the pointer, unselect all picked vertices and edges, and set up to draw a rectangle for multiple selection of contained vertices. for additional selection (default shift+mousebutton1): add to the selection, a single vertex or edge that is under the mouse pointer. if a previously picked vertex or edge is under the pointer, it is un-picked. if no vertex or edge is under the pointer, set up to draw a multiple selection rectangle (as above) but do not unpick previously picked elements. the event if the mouse is dragging a rectangle, pick the vertices contained in that rectangle clean up settings from mousepressed if the mouse is over a picked vertex, drag all picked vertices with the mouse. if the mouse is not over a vertex, draw the rectangle to select multiple vertices rejects picking if the rectangle is too small, like if the pick the vertices inside the rectangle the locked. the locked to set. jung.sourceforge.net/license.txt for a description. p is the screen point for the mouse event layout.getlocation applies the layout transformer so q is transformed by the layout transformer only transform the mouse point to graph coordinate system layout.getlocation applies the layout transformer so q is transformed by the layout transformer only translate mouse point to graph coord system"
edu.uci.ics.jung.visualization.control.PluggableGraphMouse "a graphmouse that accepts plugins for various mouse events. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.RotatingGraphMousePlugin "rotatinggraphmouse provides the abiity to rotate the graph using the mouse. by default, it is activated by mouse button one drag with the shift key pressed. the modifiers can be overridden so that a different mouse/key combination activates the rotation create an instance with default modifier values create an instance with passed zoom in/out values the event modifiers to trigger rotation save the 'down' point and check the modifiers. if the modifiers are accepted, set the cursor to the 'hand' cursor the event unset the down point and change the cursor back to the default check the modifiers. if accepted, use the mouse drag motion to rotate the graph returns the angle between two vectors from the origin to points v1 and v2. 1 2 @return jung.sourceforge.net/license.txt for a description. top bent line bottom bent line top arrow bottom arrow top bent line bottom bent line top arrow bottom arrow rotate cross product for direction dot product for angle"
edu.uci.ics.jung.visualization.control.SatelliteAnimatedPickingGraphMousePlugin "a version of the animatedpickinggraphmouseplugin that is for the satellitevisualizationviewer. the difference it that when you pick a vertex in the satellite view, the 'master view' is translated to move that vertex to the center. @see animatedpickinggraphmouseplugin create an instance override subclass method to translate the master view instead of this satellite view jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.SatelliteRotatingGraphMousePlugin "mouse events in the satelliteview that match the modifiers will cause the main view to rotate @see rotatinggraphmouseplugin check the modifiers. if accepted, use the mouse drag motion to rotate the graph in the master view jung.sourceforge.net/license.txt for a description. rotate i want to compute rotation based on the view coordinates of the lens center in the satellite view. translate the master view center to layout coords, then translate that point to the satellite view's view coordinate system...."
edu.uci.ics.jung.visualization.control.SatelliteScalingGraphMousePlugin "overrides scalinggraphmouseplugin so that mouse events in the satellite view will cause scaling in the main view @see scalinggraphmouseplugin zoom the master view display in or out, depending on the direction of the mouse wheel motion. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.SatelliteShearingGraphMousePlugin "overrides shearinggraphmouseplugin so that mouse events in the satellite view cause shearing of the main view @see shearinggraphmouseplugin overridden to shear the main view jung.sourceforge.net/license.txt for a description. i want to compute shear based on the view coordinates of the lens center in the satellite view. translate the master view center to layout coords, then translate that point to the satellite view's view coordinate system...."
edu.uci.ics.jung.visualization.control.SatelliteTranslatingGraphMousePlugin "overrides translatinggraphmouseplugin so that mouse events in the satellite view cause translating of the main view @see translatinggraphmouseplugin chack the modifiers. if accepted, translate the main view according to the dragging of the mouse pointer in the satellite view the event jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.SatelliteVisualizationViewer "a visualizationviewer that can act as a satellite view for another (master) visualizationviewer. in this view, the full graph is always visible and all mouse actions affect the graph in the master view. a rectangular shape in the satellite view shows the visible bounds of the master view. the master visualizationviewer that this is a satellite view for   used internally, as the sattellite should always share the model of the master used internally, as the satellite should always share the model of the master the master view the master. a four-sided shape that represents the visible part of the master view and is drawn in the satellite view jung.sourceforge.net/license.txt for a description. create a graph mouse with custom plugins to affect the master view this adds the lens to the satellite view get a copy of the current layout transform it may have been scaled to fit the graph i want no layout transformations in the satellite view this resets the auto-scaling that occurs in the super constructor make sure the satellite listens for changes in the master share the picked state of the master"
edu.uci.ics.jung.visualization.control.ScalingControl "zoom the display in or out the visualizationviewer how much to adjust scale by where to adjust scale from jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ScalingGraphMousePlugin "scalinggraphmouse applies a scaling transformation to the graph layout. the vertices get closer or farther apart, but do not themselves change size. scalinggraphmouse uses mousewheelevents to apply the scaling. the amount to zoom in by the amount to zoom out by whether to center the zoom at the current mouse position controls scaling operations the zoomatmouse to set. zoom the display in or out, depending on the direction of the mouse wheel motion. the zoom in value. the zoom in value to set. the zoom out value. the zoom out value to set. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ShearingGraphMousePlugin "shearinggraphmouseplugin allows the create an instance with default modifier values create an instance with passed modifier values the mouse modifiers to use the event   jung.sourceforge.net/license.txt for a description. todo auto-generated method stub todo auto-generated method stub todo auto-generated method stub todo auto-generated method stub"
edu.uci.ics.jung.visualization.control.TranslatingGraphMousePlugin "translatinggraphmouseplugin uses a mousebuttonone press and drag gesture to translate the graph display in the x and y direction. the default mousebuttonone modifier can be overridden to cause a different mouse gesture to translate the display.  create an instance with passed modifer value the mouse event modifier to activate this function check the event modifiers. set the 'down' point for later use. if this event satisfies the modifiers, change the cursor to the system 'move cursor' the event unset the 'down' point and change the cursoe back to the system default cursor chack the modifiers. if accepted, translate the graph according to the dragging of the mouse pointer the event jung.sourceforge.net/license.txt for a description. todo auto-generated method stub todo auto-generated method stub todo auto-generated method stub todo auto-generated method stub"
edu.uci.ics.jung.visualization.control.ViewScalingControl "viewscalinggraphmouse applies a scaling transform to the view of the graph. this causes all elements of the graph to grow larger or smaller. viewscalinggraphmouse, by default, is activated by the mousewheel when the control key is pressed. the control key modifier can be overridden in the contstructor. zoom the display in or out, depending on the direction of the mouse wheel motion. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.control.ViewTranslatingGraphMousePlugin "viewtranslatinggraphmouseplugin uses a mousebuttonone press and drag gesture to translate the graph display in the x and y direction by changing the affinetransform applied to the graphics2d. the default mousebuttonone modifier can be overridden to cause a different mouse gesture to translate the display.  create an instance with passed modifer value the mouse event modifier to activate this function check the event modifiers. set the 'down' point for later use. if this event satisfies the modifiers, change the cursor to the system 'move cursor' the event unset the 'down' point and change the cursoe back to the system default cursor chack the modifiers. if accepted, translate the graph according to the dragging of the mouse pointer the event jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.AbstractEdgeShapeTransformer "an interface for decorators that return a shape for a specified edge. specifies how far apart to place the control points for edges being drawn in parallel. sets the value of control_offset_increment. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.AbstractVertexShapeTransformer "jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.ConstantDirectionalEdgeValueTransformer "returns the constructor-specified value for each edge type.  @see transformer#transform(object) sets the value returned for undirected edges to value. the new value to return for undirected edges sets the value returned for directed edges to value. the new value to return for directed edges jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.DefaultVertexIconTransformer "a simple, stateful vertexiconfunction. stores icons in a map keyed on the vertex icon storage returns the icon storage as a map. sets the icon storage to the specified map. returns the icon associated with v. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.DirectionalEdgeArrowTransformer "returns wedge arrows for undirected edges and notched arrows for directed edges, of the specified dimensions.  jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.EdgeShape "an interface for decorators that return a shape for a specified edge. all edge shapes must be defined so that their endpoints are at (0,0) and (1,0). they will be scaled, rotated and translated into position by the pluggablerenderer. a convenience instance for other edge shapes to use for self-loop edges where parallel instances will not overlay each other. a convenience instance for other edge shapes to use for self-loop edges where parallel instances overlay each other an edge shape that renders as a straight line between the vertex endpoints. singleton instance of the line2d edge shape get the shape for this edge, returning either the shared instance or, in the case of self-loop edges, the simpleloop shared instance. an edge shape that renders as a bent-line between the vertex endpoints. singleton instance of the bentline shape paralleledgeindexfunction get the shape for this edge, returning either the shared instance or, in the case of self-loop edges, the loop shared instance. an edge shape that renders as a quadcurve between vertex endpoints. singleton instance of the quadcurve shape paralleledgeindexfunction get the shape for this edge, returning either the shared instance or, in the case of self-loop edges, the loop shared instance. an edge shape that renders as a cubiccurve between vertex endpoints. the two control points are at (1/3length, 2controly) and (2/3length, controly) giving a 'spiral' effect. singleton instance of the cubiccurve edge shape paralleledgeindexfunction get the shape for this edge, returning either the shared instance or, in the case of self-loop edges, the loop shared instance. an edge shape that renders as a loop with its nadir at the center of the vertex. parallel instances will overlap. singleton instance of the simpleloop shape getter for the shape shared instance an edge shape that renders as a loop with its nadir at the center of the vertex. parallel instances will not overlap. singleton instance of the loop shape paralleledgeindexfunction get the shape for this edge, modifying the diameter in the case of parallel edges, so they do not overlap an edge shape that renders as an isosceles triangle whose apex is at the destination vertex for directed edges, and as a "bowtie" shape for undirected edges. an edge shape that renders as a loop with its nadir at the center of the vertex. parallel instances will not overlap. singleton instance of the loop shape paralleledgeindexfunction get the shape for this edge, modifying the diameter in the case of parallel edges, so they do not overlap an edge shape that renders as a bent-line between the vertex endpoints. singleton instance of the bentline shape paralleledgeindexfunction get the shape for this edge, returning either the shared instance or, in the case of self-loop edges, the loop shared instance. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.EllipseVertexShapeTransformer "jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.GradientEdgePaintTransformer "creates gradientpaint instances which can be used to paint an edge. for directededges, the color will blend from c1 (source) to c2 (destination); for undirectededges, the color will be c1 at each end and c2 in the middle. returns c1. subclasses may override this method to enable more complex behavior (e.g., for picked edges). returns c2. subclasses may override this method to enable more complex behavior (e.g., for picked edges). jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.InterpolatingVertexSizeTransformer "provides vertex sizes that are spaced proportionally between min_size and max_size depending on jung.sourceforge.net/license.txt for a description. interpolate between min and max sizes based on how big value is with respect to min and max values"
edu.uci.ics.jung.visualization.decorators.NumberFormattingTransformer "transforms inputs to string representations by chaining an input {@code number}-generating {@code transformer} with an internal {@code numberformat} instance. returns a formatted string for the input. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.PickableEdgePaintTransformer "paints each edge according to the paint parameters given in the constructor, so that picked and non-picked edges can be made to look different. specifies which vertices report as "picked" _paint paint used to draw edge shapes _paint paint used to draw picked edge shapes  jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.PickableVertexIconTransformer "supplies an icon for each vertex according to the icon parameters given in the constructor, so that picked and non-picked vertices can be made to look different. specifies which vertices report as "picked" icon used to represent vertices _icon icon used to represent picked vertices returns the appropriate icon, depending on picked state. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.PickableVertexPaintTransformer "paints each vertex according to the paint parameters given in the constructor, so that picked and non-picked vertices can be made to look different. specifies which vertices report as "picked" _paint paint used to draw vertex shapes _paint paint used to fill vertex shapes _paint paint used to fill picked vertex shapes jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.SettableVertexShapeTransformer "jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.ToStringLabeller "labels vertices by their tostring. this class functions as a drop-in replacement for the default stringlabeller method. this class does not guarantee unique labels; or even consistent ones; as a result, getvertexbylabel will always return null. retunrs v.tostring() jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.decorators.VertexIconShapeTransformer "a default implementation that stores images in a map keyed on the vertex. also applies a shaping function to images to extract the shape of the opaque part of a transparent image.  the delegate. the delegate to set. get the shape from the image. if not available, get the shape from the delegate vertexshapefunction iconmap the iconmap to set shapemap the shapemap to set jung.sourceforge.net/license.txt for a description. don't cache a zero-sized shape, wait for the image to be ready"
edu.uci.ics.jung.visualization.DefaultVisualizationModel "the model containing state values for visualizations of graphs. refactored and extracted from the 1.6.0 version of visualizationviewer manages the thread that applies the current layout algorithm the layout algorithm currently in use listens for changes in the layout, forwards to the viewer the layout to apply, with its associated graph the preferred size of the view that will display this graph removes the current graph layout, and adds a new one. the new layout to use the size of the view that will display this layout set the graph layout and if it is not already initialized, initialize it to the default visualizationviewer preferred size of 600x600 returns the current graph layout. relaxer the relaxer to set adds a changelistener. the listener to be added removes a changelistener. the listener to be removed returns an array of all the changelisteners added with addchangelistener(). of the changelisteners added or an empty array if no listeners have been added notifies all listeners that have registered interest for notification on this event type. the event instance is lazily jung.sourceforge.net/license.txt for a description. remove listener from old layout set to new layout if the layout has not been initialized yet, initialize its size now to the size of the visualizationviewer window"
edu.uci.ics.jung.visualization.FourPassImageShaper "provides factory methods that, given a bufferedimage, an image, or the filename of an image, will return a java.awt.shape that is the contiguous traced outline of the opaque part of the image. this could be used to define an image for use in a vertex, where the shape used for picking and edge-arrow placement follows the opaque part of an image that has a transparent background. the methods try to detect lines in order to minimize points in the path given the filename of an image, possibly with a transparent background, return the shape of the opaque part of the image name of the image, loaded from the classpath shape given an image, possibly with a transparent background, return the shape of the opaque part of the image shape given an image, possibly with a transparent background, return the shape of the opaque part of the image if the image is larger than max in either direction, scale the image down to max-by-max, do the trace (on fewer points) then scale the resulting shape back up to the size of the original image. the image to trace used to restrict number of points in the resulting shape shape checks to see if point p is on a line that passes thru points p1 and p2. if p is on the line, extend the line segment so that it is from p1 to the location of p. if the point p is not on the line, update my shape with a line extending to the old p2 location, make the old p2 the new p1, and make p2 the old p 1 2 @return trace the left side of the image @return trace the bottom of the image @return trace the right side of the image @return trace the top of the image @return jung.sourceforge.net/license.txt for a description. check for line its on the line make it p2 its not on the current line go until we reach an opaque point, then stop this is a point i want this is a point i want this is a point i want this is a point i want"
edu.uci.ics.jung.visualization.GraphZoomScrollPane "graphzoomscrollpane is a container for the graph's visualizationviewer and includes custom horizontal and vertical scrollbars. graphzoomscrollpane listens for changes in the scale and translation of the visualizationviewer, and will update the scrollbar positions and sizes accordingly. changes in the scrollbar positions will cause the corresponding change in the translation component (offset) of the visualizationviewer. the scrollbars are modified so that they will allow panning of the graph when the scale has been changed (e.g. zoomed-in or zoomed-out). the lower-right corner of this component is available to use as a small button or menu. samples.graph.graphzoomscrollpanedemo shows the use of this component. create an instance of the graphzoomscrollpane to contain the visualizationviewer listener for adjustment of the horizontal scroll bar. sets the translation of the visualizationviewer listener for adjustment of the vertical scroll bar. sets the translation of the visualizationviewer use the supplied vv characteristics to set the position and dimensions of the scroll bars. called in response to a changeevent from the visualizationviewer the transform of the visualizationviewer listener to adjust the scroll bar parameters when the window is resized the corner component. the cornerbutton to set. jung.sourceforge.net/license.txt for a description. respond to changes in the visualizationviewer's transform and set the scroll bar parameters appropriately get the uniform scale of all transforms get the uniform scale of all transforms a rectangle representing the layout -d.width/2, -d.height/2, 2d.width, 2d.height); horizontal scrollbar: correct direction of intersect points swap them vertical scroll bar arrange for direction swap them"
edu.uci.ics.jung.visualization.jai.AbstractPerspectiveTransformSupport "a class to make it easy to add a perspective projection examining lens to a jung graph application. see perspectivetransformerdemo for an example of how to use it. create the base class, setting common members and creating a custom graphmouse the visualizationviewer to work on the background for the perspective projection the hyperbolictransformer. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.HyperbolicImageLensSupport "a class to make it easy to add a hyperbolic projection examining lens to a jung graph application. see hyperbolictransforerdemo for an example of how to use it. create the base class, setting common members and creating a custom graphmouse the visualizationviewer to work on jung.sourceforge.net/license.txt for a description. if(d.width == 0 || d.height == 0) { d = vv.getpreferredsize(); }"
edu.uci.ics.jung.visualization.jai.PerspectiveImageLensSupport "a class to make it easy to add a perspective projection to a jung graph application. see perspectivetransformerdemo for an example of how to use it. the visualizationviewer to work on jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.PerspectiveLayoutTransformSupport "a class to make it easy to add a perspective projection to a jung graph application. see perspectivetransformerdemo for an example of how to use it. the visualizationviewer to work on jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.PerspectiveShapeTransformer "perspectiveshapetransformer extends perspectivetransformer and adds implementations for methods in shapetransformer. it modifies the shapes (vertex, edge, and arrowheads) so that they are distorted by the perspective transformation create an instance, setting values from the passed component and registering to listen for size changes on the component. create an instance transform the supplied shape with the overridden transform method so that the shape is distorted by the perspective transform. a shape to transform generalpath for the transformed shape jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.PerspectiveTransformer "perspectivetransformer wraps a mutableaffinetransformer and modifies the transform and inversetransform methods so that they create a perspective projection of the graph points. create an instance, setting values from the passed component and registering to listen for size changes on the component create an instance with a possibly shared transform override base class transform to project the perspective effect override base class to un-project the perspective effect override base class to un-project the perspective effect jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.PerspectiveTransformSupport "basic api for implementing perspective transform support jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.PerspectiveViewTransformSupport "creates a perspectiveshapetransformer to use in the view transform. this one will distort vertex shapes. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.jai.TransformingImageVertexIconRenderer "a subclass to apply a transforminggraphics to certain operations create an instance jung.sourceforge.net/license.txt for a description. get the shape to be rendered create a transform that translates to the location of the vertex to be rendered transform the vertex shape with xtransform see if the transformer will affect the imagerectangle,"
edu.uci.ics.jung.visualization.Layer ""
edu.uci.ics.jung.visualization.LayeredIcon "an icon that is made up of a collection of icons. they are rendered in layers starting with the first icon added (from the constructor)."
edu.uci.ics.jung.visualization.layout.BoundingRectangleCollector "rectangles graphics2d g2d = (graphics2d)g; g.setcolor(color.cyan); edgeshape = rc.getmultilayertransformer().transform(layer.layout, edgeshape); p = rc.getmultilayertransformer().transform(layer.layout, p);"
edu.uci.ics.jung.visualization.layout.BoundingRectanglePaintable ""
edu.uci.ics.jung.visualization.layout.CachingLayout "a layoutdecorator that caches locations in a clearable map. this can be used to ensure that edge endpoints are always the same as vertex locations when they are drawn in the render loop during the time that the layout's relaxer thread is changing the locations. @see layoutdecorator (non-javadoc) @see edu.uci.ics.jung.visualization.layout.layoutdecorator#transform(java.lang.object) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.layout.LayoutTransition ""
edu.uci.ics.jung.visualization.layout.ObservableCachingLayout "a layoutdecorator that fires changeevents when certain methods are called. used to wrap a layout so that the visualization components can be notified of changes. @see layoutdecorator @see edu.uci.ics.jung.algorithms.layout.layout#step() @see edu.uci.ics.jung.algorithms.layout.layout#initialize() @see edu.uci.ics.jung.algorithms.util.iterativecontext#done() @see edu.uci.ics.jung.algorithms.layout.layout#setlocation(java.lang.object, java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.layout.layoutdecorator#transform(java.lang.object) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.layout.PersistentLayout "interface for persistentlayout also holds a nested class point to serialize the vertex locations a serializable class to save locations jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.layout.PersistentLayoutImpl "implementation of persistentlayout. defers to another layout until 'restore' is called, then it uses the saved vertex locations a container for vertices a collection of vertices that should not move whether the graph is locked (stops the visualizationviewer rendering thread) create an instance with a passed layout create containers for graph components this method calls initialize_local_vertex for each vertex, and also adds initial coordinate information for each vertex. (the vertex's initial location is set by calling initializelocation. sets persisted location for a vertex within the dimensions of the space. if the vertex has not been persisted, sets a random location. if you want to initialize in some different way, override this method. save the vertex locations to a file the file to save to @throws an ioexception if the file cannot be used restore the graph vertex locations from a file the file to use @throws ioexception for file problems @throws classnotfoundexception for classpath problems (non-javadoc) @see edu.uci.ics.jung.visualization.layout#incrementsaredone() (non-javadoc) @see edu.uci.ics.jung.visualization.layout#lockvertex(edu.uci.ics.jung.graph.vertex) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.MultiLayerTransformer "@see edu.uci.ics.jung.visualization.visualizationserver#setviewtransformer(edu.uci.ics.jung.visualization.transform.mutabletransformer) layouttransformer"
edu.uci.ics.jung.visualization.picking.AbstractPickedState "an abstract class to support itemevents for pickedstate jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.ClassicPickSupport "picksupport implementation that emulates the picking behavior of versions of visualizationviewer prior to version 1.6. (visualizationviewer still has this behavior by default, but the picking behavior can now be changed.) @see shapepicksupport classicpicksupport does not do edges jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.ClosestShapePickSupport "a graphelementaccessor that finds the closest element to the pick point, and returns it if it is within the element's shape. this is best suited to elements with convex shapes that do not overlap. it differs from shapepicksupport in that it only checks the closest element to see whether it contains the pick point. possible unexpected odd behaviors:  if the elements overlap, this mechanism may pick another element than the one that's "on top" (rendered last) if the pick point is closer to the center of an obscured vertex. if element shapes are not convex, then this mechanism may return null even if the pick point is inside some element's shape, if the pick point is closer to the center of another element.  creates a shapepicksupport for the vv visualizationserver, with the specified pick footprint. the visualizationserver is used to fetch the current layout. source of the current layout. the size of the pick footprint for line edges create a shapepicksupport with the vv visualizationserver and default pick footprint. the footprint defaults to 2. @see edu.uci.ics.jung.algorithms.layout.graphelementaccessor#getedge(edu.uci.ics.jung.algorithms.layout.layout, double, double) @see edu.uci.ics.jung.algorithms.layout.graphelementaccessor#getvertex(edu.uci.ics.jung.algorithms.layout.layout, double, double) @see edu.uci.ics.jung.algorithms.layout.graphelementaccessor#getvertices(edu.uci.ics.jung.algorithms.layout.layout, java.awt.shape) jung.sourceforge.net/license.txt for a description. first, find the closest vertex to (x,y) now check to see whether (x,y) is in the shape for this vertex. get the vertex shape get the vertex location transform the vertex location to screen coords fixme: radiuspicksupport and shapepicksupport are not using the same mechanism! talk to tom and make sure i understand which should be used. in particular, there are some transformations that the latter uses; the latter is also doing a couple of kinds of filtering. (well, only one--just predicate-based.) looks to me like the vv could (should) be doing this filtering. (maybe.)"
edu.uci.ics.jung.visualization.picking.LayoutLensShapePickSupport "shapepicksupport provides access to vertices and edgetype based on their actual shapes. create an instance. the hasgraphlayout is used as the source of the current graph layout. the hasshapes is used to access the vertexshapes and the edgeshapes source of the current layout. source of vertex and edge shapes. how large to make the pick footprint for line edges create an instance. the picksize footprint defaults to 2. iterates over vertices, checking to see if x,y is contained in the vertex's shape. if (x,y) is contained in more than one vertex, use the vertex whose center is closest to the pick point. @see edu.uci.ics.jung.visualization.picking.picksupport#getvertex(double, double) returns the vertices that are contained in the passed shape. the shape is in screen coordinates, and the graph vertices are transformed to screen coordinates before they are tested for inclusion return an edge whose shape intersects the 'pickarea' footprint of the passed x,y, coordinates. jung.sourceforge.net/license.txt for a description. get the vertex location transform the vertex location to screen coords see if this vertex center is closest to the pick point among any other containing vertices return the first match will return the last match as a line has no area, we can't always use edgeshape.contains(point) so we make a small rectangular pickarea around the point and check if the edgeshape.intersects(pickarea) translate the edge to the starting vertex make the loops proportional to the size of the vertex move the loop so that the nadir is centered in the vertex rotate the edge to the angle between the vertices stretch the edge to span the distance between the vertices transform the edge to its location and dimensions because of the transform, the edgeshape is now a generalpath see if this edge is the closest of any that intersect"
edu.uci.ics.jung.visualization.picking.MultiPickedState "maintains the state of what has been 'picked' in the graph. the sets are constructed so that their iterators will traverse them in the order in which they are picked. the 'picked' vertices @see pickedstate#pick(archetypevertex, boolean) @see edu.uci.ics.jung.visualization.picking.pickedstate#clearpickedvertices() @see edu.uci.ics.jung.visualization.picking.pickedstate#getpickededges() @see edu.uci.ics.jung.visualization.picking.pickedstate#ispicked(archetypeedge) for the itemselectable interface contract jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.PickedInfo "an interface for classes that return information regarding whether a given graph element (vertex or edge) has been selected. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.PickedState "an interface for classes that keep track of the "picked" state of edges or vertices. marks v as "picked" if b == true, and unmarks v as picked if b == false. "picked" state of v prior to this call clears the "picked" state from all elements. returns all "picked" elements. returns true if v is currently "picked". jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.RadiusPickSupport "simple implementation of picksupport that returns the vertex or edge that is closest to the specified location. this implementation provides the same picking options that were available in previous versions of abstractlayout. the layout will always be provided by the visualizationviewer this is supporting picking for gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provide a more efficient implementation. gets the vertex nearest to the location of the (x,y) location selected, within a distance of maxdistance. iterates through all visible vertices and checks their distance from the click. override this method to provide a more efficient implementation. temporarily overrides member maxdistance gets the edge nearest to the location of the (x,y) location selected. calls the longer form of the call. gets the edge nearest to the location of the (x,y) location selected, within a distance of maxdistance, iterates through all visible edges and checks their distance from the click. override this method to provide a more efficient implementation. temporarily overrides member maxdistance closest to the click. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.picking.ShapePickSupport "a graphelementaccessor that returns elements whose shape contains the specified pick point or region. the available picking heuristics:  style.centered: returns the element whose center is closest to the pick point. style.lowest: returns the first such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the bottom", that is, the one which is rendered first.) style.highest: returns the last such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the top", that is, the one which is rendered last.)   the visualizationserver in which the this instance is being used for picking. used to retrieve properties such as the layout, renderer, vertex and edge shapes, and coordinate transformations. the current picking heuristic for this instance. defaults to centered. creates a shapepicksupport for the vv visualizationserver, with the specified pick footprint and the default pick style. the visualizationserver is used to access properties of the current visualization (layout, renderer, coordinate transformations, vertex/edge shapes, etc.). source of the current layout. the size of the pick footprint for line edges create a shapepicksupport for the specified visualizationserver with a default pick footprint. of size 2. returns the style of picking used by this instance. this specifies which of the elements, among those whose shapes contain the pick point, is returned. the available styles are:  style.centered: returns the element whose center is closest to the pick point. style.lowest: returns the first such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the bottom", that is, the one which is rendered first.) style.highest: returns the last such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the top", that is, the one which is rendered last.)  style of picking used by this instance specifies the style of picking to be used by this instance. this specifies which of the elements, among those whose shapes contain the pick point, will be returned. the available styles are:  style.centered: returns the element whose center is closest to the pick point. style.lowest: returns the first such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the bottom", that is, the one which is rendered first.) style.highest: returns the last such element encountered. (if the element collection has a consistent ordering, this will also be the element "on the top", that is, the one which is rendered last.)  the style to set iterates over vertices, checking to see if x,y is contained in the vertex's shape. if (x,y) is contained in more than one vertex, use the vertex whose center is closest to the pick point. @see edu.uci.ics.jung.visualization.picking.picksupport#getvertex(double, double) returns the vertices whose layout coordinates are contained in shape. the shape is in screen coordinates, and the graph vertices are transformed to screen coordinates before they are tested for inclusion. collection of vertices whose layout coordinates are contained in shape. returns an edge whose shape intersects the 'pickarea' footprint of the passed x,y, coordinates. retrieves the shape template for e and transforms it according to the positions of its endpoints in layout. the layout which specifies e's endpoints' positions the edge whose shape is to be returned @return @return @return quick test to allow optimization of getfilteredvertices(). true if there is an active vertex filtering mechanism for this visualization, false otherwise quick test to allow optimization of getfilterededges(). true if there is an active edge filtering mechanism for this visualization, false otherwise returns true if this vertex in this graph is included in the collections of elements to be rendered, and false otherwise. the vertex and graph to be queried true if this vertex is included in the collections of elements to be rendered, false otherwise. returns true if this edge and its endpoints in this graph are all included in the collections of elements to be rendered, and false otherwise. the edge and graph to be queried true if this edge and its endpoints are all included in the collections of elements to be rendered, false otherwise. returns the size of the edge picking area. the picking area is square; the size is specified as the length of one side, in view coordinates. size of the edge picking area sets the size of the edge picking area. length of one side of the (square) picking area, in view coordinates jung.sourceforge.net/license.txt for a description. get the vertex location transform the vertex location to screen coords return the first match will return the last match return the vertex closest to the center of a vertex shape remove the view transform from the rectangle as a line has no area, we can't always use edgeshape.contains(point) so we make a small rectangular pickarea around the point and check if the edgeshape.intersects(pickarea) because of the transform, the edgeshape is now a generalpath see if this edge is the closest of any that intersect translate the edge to the starting vertex make the loops proportional to the size of the vertex move the loop so that the nadir is centered in the vertex rotate the edge to the angle between the vertices stretch the edge to span the distance between the vertices transform the edge to its location and dimensions"
edu.uci.ics.jung.visualization.picking.ViewLensShapePickSupport "shapepicksupport provides access to vertices and edgetype based on their actual shapes. create an instance. the hasgraphlayout is used as the source of the current graph layout. the hasshapes is used to access the vertexshapes and the edgeshapes source of the current layout. source of vertex and edge shapes. how large to make the pick footprint for line edges create an instance. the picksize footprint defaults to 2. iterates over vertices, checking to see if x,y is contained in the vertex's shape. if (x,y) is contained in more than one vertex, use the vertex whose center is closest to the pick point. @see edu.uci.ics.jung.visualization.picking.picksupport#getvertex(double, double) returns the vertices that are contained in the passed shape. the shape is in screen coordinates, and the graph vertices are transformed to screen coordinates before they are tested for inclusion return an edge whose shape intersects the 'pickarea' footprint of the passed x,y, coordinates. jung.sourceforge.net/license.txt for a description. get the shape transform the vertex location to screen coords use the layout transform to move the shape center without modifying the actual shape now use the view transform to modify the actual shape vv.getrendercontext().getmultilayertransformer().transform(shape); see if this vertex center is closest to the pick point among any other containing vertices return the first match will return the last match remove the view transform from the rectangle get the shape as a line has no area, we can't always use edgeshape.contains(point) so we make a small rectangular pickarea around the point and check if the edgeshape.intersects(pickarea) vv.getrendercontext().getbasictransformer().transform(layout.transform(v1)); vv.getrendercontext().getbasictransformer().transform(layout.transform(v2)); translate the edge to the starting vertex make the loops proportional to the size of the vertex move the loop so that the nadir is centered in the vertex rotate the edge to the angle between the vertices stretch the edge to span the distance between the vertices transform the edge to its location and dimensions because of the transform, the edgeshape is now a generalpath see if this edge is the closest of any that intersect"
edu.uci.ics.jung.visualization.PivotingImageShaper "provides factory methods that, given a bufferedimage, an image, or the filename of an image, will return a java.awt.shape that is the contiguous traced outline of the opaque part of the image. this could be used to define an image for use in a vertex, where the shape used for picking and edge-arrow placement follows the opaque part of an image that has a transparent background. the methods try to detect lines in order to minimize points in the path the number of pixels to skip while sampling the images edges the first x coordinate of the shape. used to discern when we are done given an image, possibly with a transparent background, return the shape of the opaque part of the image shape given an image, possibly with a transparent background, return the shape of the opaque part of the image shape given an image, possibly with a transparent background, return the shape of the opaque part of the image shape trace the left side of the image @return trace the bottom of the image @return trace the right side of the image @return trace the top of the image @return jung.sourceforge.net/license.txt for a description. check for line its on the line make it p2 its not on the current line go until we reach an opaque point, then stop this is a point i want this is a continuation of a path this is the first point in the path this is a point i want this is a point i want this is a point i want"
edu.uci.ics.jung.visualization.PluggableRenderContext "pluggable support for picking graph elements by finding them based on their coordinates. the jcomponent that this renderer will display the graph on the cellrendererpane is used here just as it is in jtree and jtable, to allow a pluggable jlabel-based renderer for vertex and edge label strings and icons. a default graphlabelrenderer - picked vertex labels are blue, picked edge labels are cyan vertexshapetransformer the vertexshapetransformer to set vertexstroketransformer the vertexstroketransformer to set @see edu.uci.ics.jung.visualization.rendercontext#getarrow_placement_tolerance() @see edu.uci.ics.jung.visualization.rendercontext#setarrow_placement_tolerance(float) @see edu.uci.ics.jung.visualization.rendercontext#getedgearrowtransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgearrowtransformer(edu.uci.ics.jung.visualization.decorators.edgearrowtransformer) @see rendercontext#getedgearrowpredicate() @see rendercontext#setedgearrowpredicate(predicate) @see edu.uci.ics.jung.visualization.rendercontext#getedgefonttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgefonttransformer(edu.uci.ics.jung.visualization.decorators.edgefonttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgeincludepredicate() @see edu.uci.ics.jung.visualization.rendercontext#setedgeincludepredicate(org.apache.commons.collections15.predicate) @see edu.uci.ics.jung.visualization.rendercontext#getedgelabelclosenesstransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgelabelclosenesstransformer(edu.uci.ics.jung.visualization.decorators.numberdirectionaledgevalue) @see edu.uci.ics.jung.visualization.rendercontext#getedgelabelrenderer() @see edu.uci.ics.jung.visualization.rendercontext#setedgelabelrenderer(edu.uci.ics.jung.visualization.edgelabelrenderer) @see edu.uci.ics.jung.visualization.rendercontext#getedgepainttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgepainttransformer(edu.uci.ics.jung.visualization.decorators.edgepainttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgepainttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgepainttransformer(edu.uci.ics.jung.visualization.decorators.edgepainttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgeshapetransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgeshapetransformer(edu.uci.ics.jung.visualization.decorators.edgeshapetransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgelabeltransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgelabeltransformer(edu.uci.ics.jung.visualization.decorators.edgelabeltransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgestroketransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgestroketransformer(edu.uci.ics.jung.visualization.decorators.edgestroketransformer) @see edu.uci.ics.jung.visualization.rendercontext#getedgestroketransformer() @see edu.uci.ics.jung.visualization.rendercontext#setedgestroketransformer(edu.uci.ics.jung.visualization.decorators.edgestroketransformer) @see rendercontext#getgraphicscontext() @see rendercontext#setgraphicscontext(graphicsdecorator) @see rendercontext#getlabeloffset() @see rendercontext#setlabeloffset(int) @see edu.uci.ics.jung.visualization.rendercontext#getparalleledgeindextransformer() @see edu.uci.ics.jung.visualization.rendercontext#setparalleledgeindexfunction(edu.uci.ics.graph.util.paralleledgeindexfunction) @see edu.uci.ics.jung.visualization.rendercontext#getpickededgestate() @see edu.uci.ics.jung.visualization.rendercontext#setpickededgestate(edu.uci.ics.jung.visualization.picking.pickedstate) @see edu.uci.ics.jung.visualization.rendercontext#getpickedvertexstate() @see edu.uci.ics.jung.visualization.rendercontext#setpickedvertexstate(edu.uci.ics.jung.visualization.picking.pickedstate) @see edu.uci.ics.jung.visualization.rendercontext#getrendererpane() @see edu.uci.ics.jung.visualization.rendercontext#setrendererpane(javax.swing.cellrendererpane) @see edu.uci.ics.jung.visualization.rendercontext#getscreendevice() @see edu.uci.ics.jung.visualization.rendercontext#setscreendevice(edu.uci.ics.jung.visualization.visualizationviewer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexfonttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexfonttransformer(edu.uci.ics.jung.visualization.decorators.vertexfonttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexicontransformer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexicontransformer(edu.uci.ics.jung.visualization.decorators.vertexicontransformer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexincludepredicate() @see edu.uci.ics.jung.visualization.rendercontext#setvertexincludepredicate(org.apache.commons.collections15.predicate) @see edu.uci.ics.jung.visualization.rendercontext#getvertexlabelrenderer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexlabelrenderer(edu.uci.ics.jung.visualization.vertexlabelrenderer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexpainttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexpainttransformer(edu.uci.ics.jung.visualization.decorators.vertexpainttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexpainttransformer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexpainttransformer(edu.uci.ics.jung.visualization.decorators.vertexpainttransformer) @see edu.uci.ics.jung.visualization.rendercontext#getvertexlabeltransformer() @see edu.uci.ics.jung.visualization.rendercontext#setvertexlabeltransformer(edu.uci.ics.jung.visualization.decorators.vertexlabeltransformer) picksupport the picksupport to set basictransformer the basictransformer to set @see rendercontext#getarrowdrawpainttransformer() @see rendercontext#getarrowfillpainttransformer() @see rendercontext#setarrowdrawpainttransformer(transformer) @see rendercontext#setarrowfillpainttransformer(transformer) jung.sourceforge.net/license.txt for a description. reset the edge shape transformer, as the parallel edge index function is used by it"
edu.uci.ics.jung.visualization.RenderContext "a stroke for a dotted line: 1 pixel width, round caps, round joins, and an array of {1.0f, 3.0f}. a stroke for a dashed line: 1 pixel width, square caps, beveled joins, and an array of {5.0f}. specifies the offset for the edge labels. picksupport the picksupport to set mutabletransformer getviewtransformer(); void setviewtransformer(mutabletransformer viewtransformer); extends abstractgraphpredicate {"
edu.uci.ics.jung.visualization.renderers.BasicEdgeArrowRenderingSupport "(non-javadoc) @see edu.uci.ics.jung.visualization.renderers.edgearrowrenderingsupport#getarrowtransform(edu.uci.ics.jung.visualization.rendercontext, java.awt.geom.generalpath, java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.renderers.edgearrowrenderingsupport#getreversearrowtransform(edu.uci.ics.jung.visualization.rendercontext, java.awt.geom.generalpath, java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.renderers.edgearrowrenderingsupport#getreversearrowtransform(edu.uci.ics.jung.visualization.rendercontext, java.awt.geom.generalpath, java.awt.shape, boolean) (non-javadoc) @see edu.uci.ics.jung.visualization.renderers.edgearrowrenderingsupport#getarrowtransform(edu.uci.ics.jung.visualization.rendercontext, java.awt.geom.line2d, java.awt.shape) this is used for the reverse-arrow of a non-directed edge get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return passed line's point2 must be inside the passed shape or an illegalargumentexception is thrown line to subdivide shape to compare with line line that intersects the shape boundary @throws illegalargumentexception if the passed line's point1 is not inside the shape passed line's point1 must be inside the passed shape or an illegalargumentexception is thrown line to subdivide shape to compare with line line that intersects the shape boundary @throws illegalargumentexception if the passed line's point1 is not inside the shape divide a line2d into 2 new line2ds that are returned in the passed left and right instances, if non-null the line to divide the left side, or null the right side, or null jung.sourceforge.net/license.txt for a description. when the pathiterator is done, switch to the line-subdivide method to get the arrowhead closer. iterate over the line until the edge shape will place the arrowhead closer than 'arrowgap' to the vertex shape boundary iterate over the line until the edge shape will place the arrowhead closer than 'arrowgap' to the vertex shape boundary calculate the angle for the arrowhead return null; subdivide the line until its left segment intersects the shape boundary now that right is completely inside shape, return left, which must be partially outside subdivide the line until its right side intersects the shape boundary now that left is completely inside shape, return right, which must be partially outside"
edu.uci.ics.jung.visualization.renderers.BasicEdgeLabelRenderer "jung.sourceforge.net/license.txt for a description. don't draw edge if either incident vertex is not drawn"
edu.uci.ics.jung.visualization.renderers.BasicEdgeRenderer "draws the edge e, whose endpoints are at (x1,y1) and (x2,y2), on the graphics context g. the shape provided by the edgeshapefunction instance is scaled in the x-direction so that its width is equal to the distance between (x1,y1) and (x2,y2). jung.sourceforge.net/license.txt for a description. don't draw edge if either incident vertex is not drawn restore paint and stroke this is a self-loop. scale it is larger than the vertex it decorates and translate it so that its nadir is at the center of the vertex. the xform will do the translation to x1,y1 this is a normal edge. rotate it to the angle between vertex endpoints, then scale it to the distance between the vertices get paints for filling and drawing (filling is done first so that drawing and label use same paint) see if arrows are too small to bother drawing restore paint and stroke restore old paint"
edu.uci.ics.jung.visualization.renderers.BasicRenderer "the default implementation of the renderer used by the visualizationviewer. default vertex and edge renderers are supplied, or the edgelabelrenderer the edgelabelrenderer to set vertexlabelrenderer the vertexlabelrenderer to set edgerenderer vertexrenderer jung.sourceforge.net/license.txt for a description. paint all the edges paint all the vertices"
edu.uci.ics.jung.visualization.renderers.BasicVertexLabelRenderer "position the position to set labels the specified vertex with the specified label. uses the font specified by this instance's vertexfontfunction. (if the font is unspecified, the existing font for the graphics context is used.) if vertex label centering is active, the label is centered on the position of the vertex; otherwise the label is offset slightly. positioner the positioner to set jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.renderers.BasicVertexRenderer "paint v's icon on g at (x,y). jung.sourceforge.net/license.txt for a description. get the shape to be rendered create a transform that translates to the location of the vertex to be rendered transform the vertex shape with xtransform rc.getviewtransformer().transform(shape).intersects(devicerectangle);"
edu.uci.ics.jung.visualization.renderers.CenterEdgeArrowRenderingSupport "returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. the loop edge is a special case because its staring point is not inside the vertex. the passedgo flag handles this case. - used only for loop edges this is used for the arrow of a directed and for one of the arrows for non-directed edges get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return this is used for the reverse-arrow of a non-directed edge get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return divide a line2d into 2 new line2ds that are returned in the passed left and right instances, if non-null the line to divide the left side, or null the right side, or null jung.sourceforge.net/license.txt for a description. count the segments. find the middle segment done count the segments. find the middle segment done find the midpoint of the edgeshape line, and use it to make the transform find the midpoint of the edgeshape line, and use it to make the transform calculate the angle for the arrowhead"
edu.uci.ics.jung.visualization.renderers.Checkmark "a simple icon that draws a checkmark in the lower-right quadrant of its area. used to draw a checkmark on picked vertices."
edu.uci.ics.jung.visualization.renderers.DefaultEdgeLabelRenderer "defaultedgelabelrenderer is similar to the cell renderers used by the jtable and jtree jfc classes. creates a default table cell renderer. the rotateedgelabels. the rotateedgelabels to set. overrides jcomponent.setforeground to assign the unselected-foreground color to the specified color. set the foreground color to this value overrides jcomponent.setbackground to assign the unselected-background color to the specified color. set the background color to this value notification from the uimanager that the look and feel [l&f] has changed. replaces the current ui object with the latest version from the uimanager. @see jcomponent#updateui returns the default label renderer for an edge the visualizationviewer to render on the value to assign to the label for edge the edge default label renderer the following methods are overridden as a performance measure to to prune code-paths are often called in the case of renders but which we know are unnecessary. great care should be taken when writing your own renderer to weigh the benefits and drawbacks of overriding methods like these. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. sets the string object for the cell being rendered to value. the string value for this cell; if value is null it sets the text value to an empty string @see jlabel#settext jung.sourceforge.net/license.txt for a description. strings get interned..."
edu.uci.ics.jung.visualization.renderers.DefaultVertexLabelRenderer "defaultvertexlabelrenderer is similar to the cell renderers used by the jtable and jtree jfc classes. creates a default table cell renderer. overrides jcomponent.setforeground to assign the unselected-foreground color to the specified color. set the foreground color to this value overrides jcomponent.setbackground to assign the unselected-background color to the specified color. set the background color to this value notification from the uimanager that the look and feel [l&f] has changed. replaces the current ui object with the latest version from the uimanager. @see jcomponent#updateui returns the default label renderer for a vertex the visualizationviewer to render on the value to assign to the label for vertex the vertex default label renderer the following methods are overridden as a performance measure to to prune code-paths are often called in the case of renders but which we know are unnecessary. great care should be taken when writing your own renderer to weigh the benefits and drawbacks of overriding methods like these. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. overridden for performance reasons. see the implementation note for more information. sets the string object for the cell being rendered to value. the string value for this cell; if value is null it sets the text value to an empty string @see jlabel#settext jung.sourceforge.net/license.txt for a description. strings get interned..."
edu.uci.ics.jung.visualization.renderers.EdgeArrowRenderingSupport "returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. the loop edge is a special case because its staring point is not inside the vertex. the passedgo flag handles this case. - used only for loop edges this is used for the arrow of a directed and for one of the arrows for non-directed edges get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return"
edu.uci.ics.jung.visualization.renderers.EdgeLabelRenderer "returns the component used for drawing the label. this method is used to configure the renderer appropriately before drawing. @param vv the jcomponent that is asking the renderer to draw; can be null @param value the value of the cell to be rendered. it is up to the specific renderer to interpret and draw the value. for example, if value is the string "true", it could be rendered as a string or it could be rendered as a check box that is checked. null is a valid value @param vertex the vertex for the label being drawn. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.renderers.GradientVertexRenderer "a renderer that will fill vertex shapes with a gradientpaint jung.sourceforge.net/license.txt for a description. get the shape to be rendered create a transform that translates to the location of the vertex to be rendered transform the vertex shape with xtransform rc.getviewtransformer().transform(shape).intersects(devicerectangle);"
edu.uci.ics.jung.visualization.renderers.Renderer "the interface for drawing vertices, edges, and their labels. implementations of this class can set specific renderers for each element, allowing custom control of each. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.renderers.ReshapingEdgeRenderer "uses a flatness argument to break edges into smaller segments. this produces a more detailed transformation of the edge shape draws the edge e, whose endpoints are at (x1,y1) and (x2,y2), on the graphics context g. the shape provided by the edgeshapefunction instance is scaled in the x-direction so that its width is equal to the distance between (x1,y1) and (x2,y2). returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. returns a transform to position the arrowhead on this edge shape at the point where it intersects the passed vertex shape. the loop edge is a special case because its staring point is not inside the vertex. the passedgo flag handles this case. - used only for loop edges this is used for the arrow of a directed and for one of the arrows for non-directed edges get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return this is used for the reverse-arrow of a non-directed edge get a transform to place the arrow shape on the passed edge at the point where it intersects the passed shape @return passed line's point2 must be inside the passed shape or an illegalargumentexception is thrown line to subdivide shape to compare with line line that intersects the shape boundary @throws illegalargumentexception if the passed line's point1 is not inside the shape passed line's point1 must be inside the passed shape or an illegalargumentexception is thrown line to subdivide shape to compare with line line that intersects the shape boundary @throws illegalargumentexception if the passed line's point1 is not inside the shape divide a line2d into 2 new line2ds that are returned in the passed left and right instances, if non-null the line to divide the left side, or null the right side, or null jung.sourceforge.net/license.txt for a description. this is a self-loop. scale it is larger than the vertex it decorates and translate it so that its nadir is at the center of the vertex. this is a normal edge. rotate it to the angle between vertex endpoints, then scale it to the distance between the vertices get paints for filling and drawing (filling is done first so that drawing and label use same paint) see if arrows are too small to bother drawing use existing paint for text if no draw paint specified string label = edgestringer.getlabel(e); if (label != null) { labeledge(g, graph, e, label, x1, x2, y1, y2); } restore old paint public affinetransform getarrowtransform(rendercontext rc, generalpath edgeshape, shape vertexshape) { float[] seg = new float[6]; point2d p1=null; point2d p2=null; affinetransform at = new affinetransform(); // when the pathiterator is done, switch to the line-subdivide // method to get the arrowhead closer. for(pathiterator i=edgeshape.getpathiterator(null,1); !i.isdone(); i.next()) { int ret = i.currentsegment(seg); if(ret == pathiterator.seg_moveto) { p2 = new point2d.float(seg[0],seg[1]); } else if(ret == pathiterator.seg_lineto) { p1 = p2; p2 = new point2d.float(seg[0],seg[1]); if(vertexshape.contains(p2)) { at = getarrowtransform(rc, new line2d.float(p1,p2),vertexshape); break; } } } return at; } public affinetransform getreversearrowtransform(rendercontext rc, generalpath edgeshape, shape vertexshape) { return getreversearrowtransform(rc, edgeshape, vertexshape, true); } public affinetransform getreversearrowtransform(rendercontext rc, generalpath edgeshape, shape vertexshape, boolean passedgo) { float[] seg = new float[6]; point2d p1=null; point2d p2=null;  affinetransform at = new affinetransform(); for(pathiterator i=edgeshape.getpathiterator(null,1); !i.isdone(); i.next()) { int ret = i.currentsegment(seg); if(ret == pathiterator.seg_moveto) { p2 = new point2d.float(seg[0],seg[1]); } else if(ret == pathiterator.seg_lineto) { p1 = p2; p2 = new point2d.float(seg[0],seg[1]); if(passedgo == false && vertexshape.contains(p2)) { passedgo = true; } else if(passedgo==true && vertexshape.contains(p2)==false) { at = getreversearrowtransform(rc, new line2d.float(p1,p2),vertexshape); break; } } } return at; } public affinetransform getarrowtransform(rendercontext rc, line2d edgeshape, shape vertexshape) { float dx = (float) (edgeshape.getx1()-edgeshape.getx2()); float dy = (float) (edgeshape.gety1()-edgeshape.gety2()); // iterate over the line until the edge shape will place the // arrowhead closer than 'arrowgap' to the vertex shape boundary while((dxdx+dydy) > rc.getarrowplacementtolerance()) { try { edgeshape = getlastoutsidesegment(edgeshape, vertexshape); } catch(illegalargumentexception e) { system.err.println(e.tostring()); return null; } dx = (float) (edgeshape.getx1()-edgeshape.getx2()); dy = (float) (edgeshape.gety1()-edgeshape.gety2()); } double atheta = math.atan2(dx,dy)+math.pi/2; affinetransform at = affinetransform.gettranslateinstance(edgeshape.getx1(), edgeshape.gety1()); at.rotate(-atheta); return at; } protected affinetransform getreversearrowtransform(rendercontext rc, line2d edgeshape, shape vertexshape) { float dx = (float) (edgeshape.getx1()-edgeshape.getx2()); float dy = (float) (edgeshape.gety1()-edgeshape.gety2()); // iterate over the line until the edge shape will place the // arrowhead closer than 'arrowgap' to the vertex shape boundary while((dxdx+dydy) > rc.getarrowplacementtolerance()) { try { edgeshape = getfirstoutsidesegment(edgeshape, vertexshape); } catch(illegalargumentexception e) { system.err.println(e.tostring()); return null; } dx = (float) (edgeshape.getx1()-edgeshape.getx2()); dy = (float) (edgeshape.gety1()-edgeshape.gety2()); } // calculate the angle for the arrowhead double atheta = math.atan2(dx,dy)-math.pi/2; affinetransform at = affinetransform.gettranslateinstance(edgeshape.getx1(),edgeshape.gety1()); at.rotate(-atheta); return at; } protected line2d getlastoutsidesegment(line2d line, shape shape) { if(shape.contains(line.getp2())==false) { string errorstring = "line end point: "+line.getp2()+" is not contained in shape: "+shape.getbounds2d(); throw new illegalargumentexception(errorstring); //return null; } line2d left = new line2d.double(); line2d right = new line2d.double(); // subdivide the line until its left segment intersects // the shape boundary do { subdivide(line, left, right); line = right; } while(shape.contains(line.getp1())==false); // now that right is completely inside shape, // return left, which must be partially outside return left; } protected line2d getfirstoutsidesegment(line2d line, shape shape) {  if(shape.contains(line.getp1())==false) { string errorstring = "line start point: "+line.getp1()+" is not contained in shape: "+shape.getbounds2d(); throw new illegalargumentexception(errorstring); } line2d left = new line2d.float(); line2d right = new line2d.float(); // subdivide the line until its right side intersects the // shape boundary do { subdivide(line, left, right); line = left; } while(shape.contains(line.getp2())==false); // now that left is completely inside shape, // return right, which must be partially outside return right; } protected void subdivide(line2d src, line2d left, line2d right) { double x1 = src.getx1(); double y1 = src.gety1(); double x2 = src.getx2(); double y2 = src.gety2();  double mx = x1 + (x2-x1)/2.0; double my = y1 + (y2-y1)/2.0; if (left != null) { left.setline(x1, y1, mx, my); } if (right != null) { right.setline(mx, my, x2, y2); } }"
edu.uci.ics.jung.visualization.renderers.VertexLabelAsShapeRenderer "renders vertex labels, but can also supply shapes for vertices. this has the effect of making the vertex label the actual vertex shape. the labels the specified vertex with the specified label. uses the font specified by this instance's vertexfontfunction. (if the font is unspecified, the existing font for the graphics context is used.) if vertex label centering is active, the label is centered on the position of the vertex; otherwise the label is offset slightly. jung.sourceforge.net/license.txt for a description. shape shape = shapes.get(v); if(shape == null) { return new rectangle(-20,-20,40,40); } else return shape; noop noop"
edu.uci.ics.jung.visualization.renderers.VertexLabelRenderer "returns the component used for drawing the label. this method is used to configure the renderer appropriately before drawing. @param vv the jcomponent that is asking the renderer to draw; can be null @param value the value of the cell to be rendered. it is up to the specific renderer to interpret and draw the value. for example, if value is the string "true", it could be rendered as a string or it could be rendered as a check box that is checked. null is a valid value @param vertex the vertex for the label being drawn. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.subLayout.GraphCollapser "jung.sourceforge.net/license.txt for a description. add all vertices in the delegate, unless the vertex is in the cluster. add the clustergraph as a vertex add all edges from the ingraph, unless both endpoints of the edge are in the cluster don't add edges whose endpoints are both in the cluster put all clustergraph vertices and edges into the new graph add all the vertices from the current graph except for the cluster we are expanding now that all vertices have been added, add the edges, ensuring that no edge contains a vertex that has not already been added i need a new v1 i need a new v2 todo auto-generated catch block todo auto-generated catch block"
edu.uci.ics.jung.visualization.subLayout.TreeCollapser "jung.sourceforge.net/license.txt for a description. get a sub tree from subroot object edge = tree.getinedges(subtree).iterator().next(); object parent = tree.getpredecessors(subtree).iterator().next();"
edu.uci.ics.jung.visualization.transform.AbstractLensSupport "a class to make it easy to add an examining lens to a jung graph application. see hyperbolictransformerdemo, viewlenssupport and layoutlenssupport for examples of how to use it. create the base class, setting common members and creating a custom graphmouse the visualizationviewer to work on the hyperbolicgraphmouse. the background for the hyperbolic projection paint the paint to set the hyperbolictransformer. the background for the hyperbolic projection paint the paint to set the hyperbolictransformer. lens the lens to set lenscontrols the lenscontrols to set jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.AffineTransformer "provides methods to map points from one coordinate system to another, by delegating to a wrapped affinetransform (uniform) and its inverse. the affinetransform to use. initialize to identity create an instance that does not transform points create an instance with the supplied transform the transform. the transform to set. applies the inverse transform to the supplied point @return getter for scalex getter for scaley getter for shear in x axis getter for shear in y axis get the translate x value get the translate y value applies the transform to the supplied point transform the supplied shape from graph coordinates to screen coordinates generalpath of the transformed shape transform the supplied shape from graph coordinates to screen coordinates generalpath of the transformed shape jung.sourceforge.net/license.txt for a description. nothing left to do"
edu.uci.ics.jung.visualization.transform.BidirectionalTransformer "provides methods to map points from one coordinate system to another: graph to screen and screen to graph. convert the supplied graph coordinate to the screen coordinate graph point to convert point convert the supplied screen coordinate to the graph coordinate. screen point to convert graph point @return @return jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.HyperbolicTransformer "hyperbolictransformer wraps a mutableaffinetransformer and modifies the transform and inversetransform methods so that they create a fisheye projection of the graph points, with points near the center spread out and points near the edges collapsed onto the circumference of an ellipse. hyperbolictransformer is not an affine transform, but it uses an affine transform to cause translation, scaling, rotation, and shearing while applying a non-affine hyperbolic filter in its transform and inversetransform methods. create an instance, setting values from the passed component and registering to listen for size changes on the component create an instance with a possibly shared transform override base class transform to project the fisheye effect override base class to un-project the fisheye effect jung.sourceforge.net/license.txt for a description. transform the point from the graph to the view calculate point from center factor out ellipse factor out ellipse"
edu.uci.ics.jung.visualization.transform.LayoutLensSupport "a class to make it easy to add an examining lens to a jung graph application. see hyperbolictransformerdemo for an example of how to use it. create the base class, setting common members and creating a custom graphmouse the visualizationviewer to work on jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.LensSupport "basic api for implementing lens projection support jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.LensTransformer "lenstransformer wraps a mutableaffinetransformer and modifies the transform and inversetransform methods so that they create a projection of the graph points within an elliptical lens. lenstransformer uses an affine transform to cause translation, scaling, rotation, and shearing while applying a possibly non-affine filter in its transform and inversetransform methods. the area affected by the transform create an instance with a possibly shared transform set values from the passed component. declared private so it can't be overridden the magnification. the magnification to set. the viewcenter. the viewcenter to set. the viewradius. the viewradius to set. the ratio. react to size changes on a component override base class transform to project the fisheye effect override base class to un-project the fisheye effect return the supplied shape, translated to the coordinates that result from calling transform on its center return the supplied shape, translated to the coordinates that result from calling inversetransform on its center jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.MagnifyTransformer "magnifytransformer wraps a mutableaffinetransformer and modifies the transform and inversetransform methods so that they create an enlarging projection of the graph points. magnifytransformer uses an affine transform to cause translation, scaling, rotation, and shearing while applying a separate magnification filter in its transform and inversetransform methods. create an instance, setting values from the passed component and registering to listen for size changes on the component create an instance with a possibly shared transform override base class transform to project the fisheye effect override base class to un-project the fisheye effect magnifies the point, without considering the lens @return jung.sourceforge.net/license.txt for a description. transform the point from the graph to the view calculate point from center factor out ellipse factor out ellipse transform the point from the graph to the view calculate point from center factor out ellipse radius = math.min(radius, viewradius);"
edu.uci.ics.jung.visualization.transform.MutableAffineTransformer "provides methods to mutate the affinetransform used by affinetransformer base class to map points from one coordinate system to another. create an instance that does not transform points create an instance with the supplied transform setter for the scale fires a propertychangeevent with the affinetransforms representing the previous and new values for scale and offset setter for the scale fires a propertychangeevent with the affinetransforms representing the previous and new values for scale and offset shears the transform by passed parameters x value to shear y value to shear replace the transform's translate x and y values with the passed values, leaving the scale values unchanged the x value the y value apply the passed values to the current transform the x-value the y-value preconcatenates the rotation at the supplied point with the current transform rotates the current transform at the supplied points adds a changelistener. the listener to be added removes a changelistener. the listener to be removed returns an array of all the changelisteners added with addchangelistener(). of the changelisteners added or an empty array if no listeners have been added notifies all listeners that have registered interest for notification on this event type. the event instance is lazily jung.sourceforge.net/license.txt for a description. nothing left to do"
edu.uci.ics.jung.visualization.transform.MutableTransformer "provides an api for the mutation of a transformer and for adding listeners for changes on the transformer jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.MutableTransformerDecorator "a complete decorator that wraps a mutabletransformer. subclasses use this to allow them to only declare methods they need to change. the delegate. the delegate to set. (non-javadoc) @see edu.uci.ics.jung.utils.changeeventsupport#addchangelistener(javax.swing.event.changelistener) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#concatenate(java.awt.geom.affinetransform) (non-javadoc) @see edu.uci.ics.jung.utils.changeeventsupport#firestatechanged() (non-javadoc) @see edu.uci.ics.jung.utils.changeeventsupport#getchangelisteners() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#getscale() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#getscalex() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#getscaley() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#getshearx() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#getsheary() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#gettransform() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#gettranslatex() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#gettranslatey() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.transformer#inversetransform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.shape.shapetransformer#inversetransform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.transformer#istransformed() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#preconcatenate(java.awt.geom.affinetransform) (non-javadoc) @see edu.uci.ics.jung.utils.changeeventsupport#removechangelistener(javax.swing.event.changelistener) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#rotate(double, java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#scale(double, double, java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#setscale(double, double, java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#settoidentity() (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#settranslate(double, double) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#shear(double, double, java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.transformer#transform(java.awt.geom.point2d) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.shape.shapetransformer#transform(java.awt.shape) (non-javadoc) @see edu.uci.ics.jung.visualization.transform.mutabletransformer#translate(double, double) jung.sourceforge.net/license.txt for a description. public boolean istransformed() { return delegate.istransformed(); }"
edu.uci.ics.jung.visualization.transform.shape.Graphics2DWrapper "a complete wrapping of graphics2d, useful as a base class. contains no additional methods, other than direct calls to the delegate. @see graphicsdecorator as an example subclass that adds additional methods. (non-javadoc) @see java.awt.graphics2d#addrenderinghints(java.util.map) (non-javadoc) @see java.awt.graphics#clearrect(int, int, int, int) (non-javadoc) @see java.awt.graphics2d#clip(java.awt.shape) (non-javadoc) @see java.awt.graphics#cliprect(int, int, int, int) (non-javadoc) @see java.awt.graphics#copyarea(int, int, int, int, int, int) (non-javadoc) @see java.awt.graphics#create() (non-javadoc) @see java.awt.graphics#create(int, int, int, int) (non-javadoc) @see java.awt.graphics#dispose() (non-javadoc) @see java.awt.graphics2d#draw(java.awt.shape) (non-javadoc) @see java.awt.graphics2d#draw3drect(int, int, int, int, boolean) (non-javadoc) @see java.awt.graphics#drawarc(int, int, int, int, int, int) (non-javadoc) @see java.awt.graphics#drawbytes(byte[], int, int, int, int) (non-javadoc) @see java.awt.graphics#drawchars(char[], int, int, int, int) (non-javadoc) @see java.awt.graphics2d#drawglyphvector(java.awt.font.glyphvector, float, float) (non-javadoc) @see java.awt.graphics2d#drawimage(java.awt.image.bufferedimage, java.awt.image.bufferedimageop, int, int) (non-javadoc) @see java.awt.graphics2d#drawimage(java.awt.image, java.awt.geom.affinetransform, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, java.awt.color, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, int, int, java.awt.color, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, int, int, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, int, int, int, int, int, int, java.awt.color, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawimage(java.awt.image, int, int, int, int, int, int, int, int, java.awt.image.imageobserver) (non-javadoc) @see java.awt.graphics#drawline(int, int, int, int) (non-javadoc) @see java.awt.graphics#drawoval(int, int, int, int) (non-javadoc) @see java.awt.graphics#drawpolygon(int[], int[], int) (non-javadoc) @see java.awt.graphics#drawpolygon(java.awt.polygon) (non-javadoc) @see java.awt.graphics#drawpolyline(int[], int[], int) (non-javadoc) @see java.awt.graphics#drawrect(int, int, int, int) (non-javadoc) @see java.awt.graphics2d#drawrenderableimage(java.awt.image.renderable.renderableimage, java.awt.geom.affinetransform) (non-javadoc) @see java.awt.graphics2d#drawrenderedimage(java.awt.image.renderedimage, java.awt.geom.affinetransform) (non-javadoc) @see java.awt.graphics#drawroundrect(int, int, int, int, int, int) (non-javadoc) @see java.awt.graphics2d#drawstring(java.text.attributedcharacteriterator, float, float) (non-javadoc) @see java.awt.graphics2d#drawstring(java.text.attributedcharacteriterator, int, int) (non-javadoc) @see java.awt.graphics2d#drawstring(java.lang.string, float, float) (non-javadoc) @see java.awt.graphics2d#drawstring(java.lang.string, int, int) (non-javadoc) @see java.lang.object#equals(java.lang.object) (non-javadoc) @see java.awt.graphics2d#fill(java.awt.shape) (non-javadoc) @see java.awt.graphics2d#fill3drect(int, int, int, int, boolean) (non-javadoc) @see java.awt.graphics#fillarc(int, int, int, int, int, int) (non-javadoc) @see java.awt.graphics#filloval(int, int, int, int) (non-javadoc) @see java.awt.graphics#fillpolygon(int[], int[], int) (non-javadoc) @see java.awt.graphics#fillpolygon(java.awt.polygon) (non-javadoc) @see java.awt.graphics#fillrect(int, int, int, int) (non-javadoc) @see java.awt.graphics#fillroundrect(int, int, int, int, int, int) (non-javadoc) @see java.awt.graphics#finalize() (non-javadoc) @see java.awt.graphics2d#getbackground() (non-javadoc) @see java.awt.graphics#getclip() (non-javadoc) @see java.awt.graphics#getclipbounds() (non-javadoc) @see java.awt.graphics#getclipbounds(java.awt.rectangle) (non-javadoc) @see java.awt.graphics#getcliprect() (non-javadoc) @see java.awt.graphics#getcolor() (non-javadoc) @see java.awt.graphics2d#getcomposite() (non-javadoc) @see java.awt.graphics2d#getdeviceconfiguration() (non-javadoc) @see java.awt.graphics#getfont() (non-javadoc) @see java.awt.graphics#getfontmetrics() (non-javadoc) @see java.awt.graphics#getfontmetrics(java.awt.font) (non-javadoc) @see java.awt.graphics2d#getfontrendercontext() (non-javadoc) @see java.awt.graphics2d#getpaint() (non-javadoc) @see java.awt.graphics2d#getrenderinghint(java.awt.renderinghints.key) (non-javadoc) @see java.awt.graphics2d#getrenderinghints() (non-javadoc) @see java.awt.graphics2d#getstroke() (non-javadoc) @see java.awt.graphics2d#gettransform() (non-javadoc) @see java.lang.object#hashcode() (non-javadoc) @see java.awt.graphics2d#hit(java.awt.rectangle, java.awt.shape, boolean) (non-javadoc) @see java.awt.graphics#hitclip(int, int, int, int) (non-javadoc) @see java.awt.graphics2d#rotate(double, double, double) (non-javadoc) @see java.awt.graphics2d#rotate(double) (non-javadoc) @see java.awt.graphics2d#scale(double, double) (non-javadoc) @see java.awt.graphics2d#setbackground(java.awt.color) (non-javadoc) @see java.awt.graphics#setclip(int, int, int, int) (non-javadoc) @see java.awt.graphics#setclip(java.awt.shape) (non-javadoc) @see java.awt.graphics#setcolor(java.awt.color) (non-javadoc) @see java.awt.graphics2d#setcomposite(java.awt.composite) (non-javadoc) @see java.awt.graphics#setfont(java.awt.font) (non-javadoc) @see java.awt.graphics2d#setpaint(java.awt.paint) (non-javadoc) @see java.awt.graphics#setpaintmode() (non-javadoc) @see java.awt.graphics2d#setrenderinghint(java.awt.renderinghints.key, java.lang.object) (non-javadoc) @see java.awt.graphics2d#setrenderinghints(java.util.map) (non-javadoc) @see java.awt.graphics2d#setstroke(java.awt.stroke) (non-javadoc) @see java.awt.graphics2d#settransform(java.awt.geom.affinetransform) (non-javadoc) @see java.awt.graphics#setxormode(java.awt.color) (non-javadoc) @see java.awt.graphics2d#shear(double, double) (non-javadoc) @see java.awt.graphics#tostring() (non-javadoc) @see java.awt.graphics2d#transform(java.awt.geom.affinetransform) (non-javadoc) @see java.awt.graphics2d#translate(double, double) (non-javadoc) @see java.awt.graphics2d#translate(int, int) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.GraphicsDecorator "an extendion of graphics2dwrapper that adds enhanced methods for drawing icons and components @see transforminggraphics as an example subclass jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.HyperbolicShapeTransformer "hyperbolicshapetransformer extends hyperbolictransformer and adds implementations for methods in shapeflatnesstransformer. it modifies the shapes (vertex, edge, and arrowheads) so that they are distorted by the hyperbolic transformation create an instance, setting values from the passed component and registering to listen for size changes on the component. create an instance, setting values from the passed component and registering to listen for size changes on the component, with a possibly shared transform delegate. transform the supplied shape with the overridden transform method so that the shape is distorted by the hyperbolic transform. a shape to transform generalpath for the transformed shape override base class transform to project the fisheye effect override base class to un-project the fisheye effect jung.sourceforge.net/license.txt for a description. transform the point from the graph to the view delegate.transform(graphpoint); calculate point from center factor out ellipse factor out ellipse elegate.inversetransform(viewpoint); delegate.inversetransform(translatedback);"
edu.uci.ics.jung.visualization.transform.shape.Intersector "jung.sourceforge.net/license.txt for a description. base of rect where y == ry0 top where y == ry1 left side, where x == rx0 right side, where x == rx1 base, where y == ry0 top, where y == ry1"
edu.uci.ics.jung.visualization.transform.shape.MagnifyIconGraphics "subclassed to apply a magnification transform to an icon. jung.sourceforge.net/license.txt for a description. magnify the whole icon clip out the lens so the small icon doesn't get drawn inside of it"
edu.uci.ics.jung.visualization.transform.shape.MagnifyImageLensSupport "changes various visualization settings to activate or deactivate an examining lens for a jung graph application. create the base class, setting common members and creating a custom graphmouse the visualizationviewer to work on jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.MagnifyShapeTransformer "magnifyshapetransformer extends magnifytransformer and adds implementations for methods in shapetransformer. it modifies the shapes (vertex, edge, and arrowheads) so that they are enlarged by the magnify transformation create an instance, setting values from the passed component and registering to listen for size changes on the component. create an instance, setting values from the passed component and registering to listen for size changes on the component, with a possibly shared transform delegate. transform the supplied shape with the overridden transform method so that the shape is distorted by the magnify transform. a shape to transform generalpath for the transformed shape  override base class to un-project the fisheye effect magnify the shape, without considering the lens @return jung.sourceforge.net/license.txt for a description. transform the point from the graph to the view delegate.transform(graphpoint); calculate point from center factor out ellipse factor out ellipse delegate.inversetransform(viewpoint); return delegate.inversetransform(translatedback);"
edu.uci.ics.jung.visualization.transform.shape.ShapeFlatnessTransformer "provides methods to map points from one coordinate system to another: graph to screen and screen to graph. the flatness parameter is used to break a curved shape into smaller segments in order to perform a more detailed transformation. map a shape from graph coordinate system to the screen coordinate system used to break the supplied shape into segments generalpath (shape) representing the screen points of the shape jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.ShapeTransformer "provides methods to map points from one coordinate system to another: graph to screen and screen to graph. map a shape from graph coordinate system to the screen coordinate system generalpath (shape) representing the screen points of the shape jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.TransformingFlatnessGraphics "subclassed to pass certain operations thru the transformer before the base class method is applied this is useful when you want to apply non-affine transformations to the graphics2d used to draw elements of the graph. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.TransformingGraphics "subclassed to pass certain operations thru the transformer before the base class method is applied this is useful when you want to apply non-affine transformations to the graphics2d used to draw elements of the graph. the transformer to apply the transformer. the transformer to set. transform the shape before letting the delegate draw it transform the shape before letting the delegate fill it transform the shape before letting the delegate apply 'hit' with it jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.transform.shape.ViewLensSupport "uses a lenstransformer to use in the view transform. this one will distort vertex shapes. jung.sourceforge.net/license.txt for a description. savedviewtransformer.settransform(lenstransformer.getdelegate().gettransform()); vv.setviewtransformer(savedviewtransformer);"
edu.uci.ics.jung.visualization.util.Animator "how long the relaxer thread pauses between iteration loops. relaxerthreadsleeptime the relaxerthreadsleeptime to set jung.sourceforge.net/license.txt for a description. in case its running"
edu.uci.ics.jung.visualization.util.ArrowFactory "a utility class for creating arrowhead shapes. returns an arrowhead in the shape of a simple isosceles triangle with the specified base and height measurements. it is placed with the vertical axis along the negative x-axis, with its base centered on (0,0). returns an arrowhead in the shape of an isosceles triangle with an isoceles-triangle notch taken out of the base, with the specified base and height measurements. it is placed with the vertical axis along the negative x-axis, with its base centered on (0,0). jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.util.Caching "interface to provide external controls to an implementing class that manages a cache. ititialize resources for a cache clear cache jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.util.ChangeEventSupport "the implementing class provides support for changeevents. removes a changelistener. the listener to be removed returns an array of all the changelisteners added with addchangelistener(). of the changelisteners added or an empty array if no listeners have been added jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.util.DefaultChangeEventSupport "basic implementation of changeeventsupport, using standard jdk classes holds the registered listeners only one changeevent is needed instance since the event's only state is the source property. the source of events generated is always "this". notifies all listeners that have registered interest for notification on this event type. the event instance is lazily jung.sourceforge.net/license.txt for a description. guaranteed to return a non-null array process the listeners last to first, notifying those that are interested in this event lazily create the event:"
edu.uci.ics.jung.visualization.util.GeneralPathAsString ""
edu.uci.ics.jung.visualization.util.LabelWrapper "a utility to wrap long lines, creating html strings with line breaks at a settable max line length create an instance with default line break length = 10 create an instance with passed line break length the max length for lines call 'wrap' to transform the passed string line-wrap the passed string as an html string with break strings inserted. @return jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.util.PredicatedParallelEdgeIndexFunction "a class which creates and maintains indices for parallel edges. edges are evaluated by a predicate function and those that evaluate to true are excluded from computing a parallel offset returns the index for the specified edge. calculates the indices for e and for all edges parallel to e. predicate the predicate to set resets the indices for this edge and its parallel edges. should be invoked when an edge parallel to e has been added or removed. clears all edge indices for all edges in all graphs. does not recalculate the indices. jung.sourceforge.net/license.txt for a description. remove loops remove edges in opposite direction"
edu.uci.ics.jung.visualization.util.VertexShapeFactory "a utility class for generating shapes for drawing vertices. the available shapes include rectangles, rounded rectangles, ellipses, regular polygons, and regular stars. the dimensions of the requested shapes are defined by the specified vertex size function (specified by a transformer) and vertex aspect ratio function (specified by a transformer) implementations: the width of the bounding box of the shape is given by the vertex size, and the height is given by the size multiplied by the vertex's aspect ratio. creates a vertexshapefactory with the specified vertex size and aspect ratio functions. creates a vertexshapefactory with a constant size of 10 and a constant aspect ratio of 1. returns a rectangle2d whose width and height are defined by this instance's size and aspect ratio functions for this vertex. returns a ellipse2d whose width and height are defined by this instance's size and aspect ratio functions for this vertex. returns a roundrectangle2d whose width and height are defined by this instance's size and aspect ratio functions for this vertex. the arc size is set to be half the minimum of the height and width of the frame. returns a regular num_sides-sided polygon whose bounding box's width and height are defined by this instance's size and aspect ratio functions for this vertex. _sides the number of sides of the polygon; must be >= 3. returns a regular polygon of num_points points whose bounding box's width and height are defined by this instance's size and aspect ratio functions for this vertex. _points the number of points of the polygon; must be >= 5. jung.sourceforge.net/license.txt for a description. generate coordinates scale polygon to be right size, translate to center at (0,0) generate coordinates scale polygon to be right size, translate to center at (0,0)"
edu.uci.ics.jung.visualization.VisualizationImageServer "a class that could be used on the server side of a thin-client application. it creates the jung visualization, then produces an image of it. creates a new instance the specified layout and preferred size. jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.VisualizationModel "interface for the state holding model of the visualizationviewer. refactored and extracted from the 1.6.0 version of visualizationviewer set the graph layout sets the graph layout and initialize the layout size to the passed dimensions. the passed dimension will often be the size of the view that will display the graph. returns the current graph layout. register l as a listeners to changes in the model. the view registers in order to repaint itself when the model changes. removes a changelistener. the listener to be removed returns an array of all the changelisteners added with addchangelistener(). of the changelisteners added or an empty array if no listeners have been added jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization.VisualizationServer "set whether this class uses its offscreen image or not. if true, then doublebuffering in the superclass is set to 'false' whether this class uses double buffering. the superclass will be the opposite state. the model. the model to set. in response to changes from the model, repaint the view, then fire an event to any listeners. examples of listeners are the graphzoomscrollpane and the birdseyevisualizationviewer sets the showing renderer to be the input renderer. also tells the renderer to refer to this visualizationviewer as a pickedkey. (because renderers maintain a small amount of state, such as the pickedkey, it is important to create a separate instance for each vv instance.) returns the renderer used by this instance. removes the current graph layout, and adds a new one. the new layout to set removes the current graph layout, and adds a new one, optionally re-scaling the view to show the entire layout the new layout to set whether to scale the view to show the whole layout returns the current graph layout. passes thru to the model @see javax.swing.jcomponent#setvisible(boolean) returns a flag that says whether the visrunner thread is running. if it is not, then you may need to restart the thread. transform the mouse point with the inverse transform of the visualizationviewer. this maps from screen coordinates to graph coordinates. the point to transform (typically, a mouse point) transformed point2d transform the mouse point with the current transform of the visualizationviewer. this maps from graph coordinates to screen coordinates. the point to transform transformed point2d the transformer to set. the renderinghints. the renderinghints to set. the paintable to add. the paintable to remove. the paintable to add. the paintable to remove. adds a changelistener. the listener to be added removes a changelistener. the listener to be removed returns an array of all the changelisteners added with addchangelistener(). of the changelisteners added or an empty array if no listeners have been added notifies all listeners that have registered interest for notification on this event type. the event instance is lazily the pickedstate. the pickedstate. the pickedstate to set. the graphelementaccessor. the picksupport to set. an interface for the prerender and postrender jung.sourceforge.net/license.txt for a description. void setgraphlayout(layout layout, boolean scaletolayout); boolean isvisrunnerrunning(); point2d inversetransform(point2d p);  point2d inverseviewtransform(point2d p);  point2d inverselayouttransform(point2d p); point2d transform(point2d p);  point2d viewtransform(point2d p);  point2d layouttransform(point2d p); void setviewtransformer(mutabletransformer transformer);  void setlayouttransformer(mutabletransformer transformer);  mutabletransformer getviewtransformer();  mutabletransformer getlayouttransformer();"
edu.uci.ics.jung.visualization.VisualizationViewer "adds mouse behaviors and tooltips to the graph visualization base class provides mouselistener, mousemotionlistener, and mousewheellistener events to the graph create an instance with passed parameters. the layout to apply, with its associated graph the renderer to draw it with create an instance with passed parameters. the layout to apply, with its associated graph the renderer to draw it with the preferred size of this view create an instance with passed parameters. create an instance with passed parameters. initial preferred size of the view a setter for the graphmouse. this will remove any previous graphmouse (including the one that is added in the initmouseclicker method. new value current graphmouse this is the interface for adding a mouse listener. the gel will be called back with mouse clicks on vertices. override to request focus on mouse enter, if a key listener is added @see java.awt.component#addkeylistener(java.awt.event.keylistener) the edgetooltiptransformer to set the mouseeventtooltiptransformer to set the vertextooltiptransformer to set called by the superclass to display tooltips a convenience type to represent a class that processes all types of mouse events for the graph jung.sourceforge.net/license.txt for a description. setfocusable(true); addmouselistener(requestfocuslistener); rendercontext.getbasictransformer().inverseviewtransform(event.getpoint());"
edu.uci.ics.jung.visualization3d.control.MouseRotate "$rcsfile: mo mo creates a rotate behavior given the transform group. the transformgroup to operate on. creates a default mouse rotate behavior. creates a rotate behavior. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. interesting flags (wakeup conditions). creates a rotate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. 3d 1.2.1 creates a rotate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behaviors is added to the specified component and works on the given transformgroup. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. the transformgroup to operate on. 3d 1.2.1 creates a rotate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. interesting flags (wakeup conditions). 3d 1.2.1 return the x-axis movement multipler. return the y-axis movement multipler. set the x-axis amd y-axis movement multipler with factor. set the x-axis amd y-axis movement multipler with xfactor and yfactor respectively.  the transformchanged method in the callback class will be called every time the transform is updated int id; int dx, dy; access to the queue must be synchronized consolidate mouse_drag events remember old matrix translate to origin set old translation back update xform"
edu.uci.ics.jung.visualization3d.control.MouseTranslate "$rcsfile: mousetranslate.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ mousetranslate is a java3d behavior object that lets creates a mouse translate behavior given the transform group. the transformgroup to operate on. creates a default translate behavior. creates a translate behavior. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. creates a translate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. 3d 1.2.1 creates a translate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behaviors is added to the specified component and works on the given transformgroup. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. the transformgroup to operate on. 3d 1.2.1 creates a translate behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. interesting flags (wakeup conditions). 3d 1.2.1 return the x-axis movement multipler. return the y-axis movement multipler. set the x-axis amd y-axis movement multipler with factor. set the x-axis amd y-axis movement multipler with xfactor and yfactor respectively.  the transformchanged method in the callback class will be called every time the transform is updated int id; int dx, dy; access to the queue must be synchronized consolodate mouse_drag events system.out.println("dx " + dx + " dy " + dy); system.err.println("currxform is \n"+currxform); system.err.println("ltvw is \n"+ltvw); x_factor = y_factor = 1/ltvw.getscale(); currxform.mulinverse(origcurrentxform); currxform.mul(rot); system.err.println("after mul. currxform is \n"+currxform); transform3d scale = new transform3d(); scale.setscale(ltvw.getscale()); scale.invert(); rot.mul(scale); vector3d translationout = new vector3d(); rot.transform(translation, translationout); currxform.mulinverse(rot); currxform.mul(origcurrentxform);"
edu.uci.ics.jung.visualization3d.control.MouseWheelZoom "$rcsfile: mousewheelzoom.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ mousewheelzoom is a java3d behavior object that lets creates a zoom behavior given the transform group. the transformgroup to operate on. creates a default mouse zoom behavior. creates a zoom behavior. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. 3d 1.3.2 creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behaviors is added to the specified component and works on the given transformgroup. the component to add the mouselistener and mousemotionlistener to. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the transformgroup to operate on. 3d 1.3.2 creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. interesting flags (wakeup conditions). 3d 1.3.2 return the y-axis movement multipler. set the wheel units movement multipler with factor.  the transformchanged method in the callback class will be called every time the transform is updated consolidate mouse_wheel events"
edu.uci.ics.jung.visualization3d.control.MouseZoom "$rcsfile: mousezoom.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ mousezoom is a java3d behavior object that lets creates a zoom behavior given the transform group. the transformgroup to operate on. creates a default mouse zoom behavior. creates a zoom behavior. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the component to add the mouselistener and mousemotionlistener to. 3d 1.2.1 creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behaviors is added to the specified component and works on the given transformgroup. the component to add the mouselistener and mousemotionlistener to. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. the transformgroup to operate on. 3d 1.2.1 creates a zoom behavior that uses awt listeners and behavior posts rather than wakeuponawtevent. the behavior is added to the specified component. a null component can be passed to specify the behavior should use listeners. components can then be added to the behavior with the addlistener(component c) method. note that this behavior still needs a transform group to work on (use settransformgroup(tg)) and the transform group must add this behavior. interesting flags (wakeup conditions). 3d 1.2.1 return the y-axis movement multipler. set the y-axis movement multipler with factor.  the transformchanged method in the callback class will be called every time the transform is updated. int id; int dx, dy; consolodate mouse_drag events"
edu.uci.ics.jung.visualization3d.control.PickMouseBehavior "$rcsfile: pickmousebehavior.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ base class that allows creates a pickmousebehavior given current canvas, root of the tree to operate on, and the bounds. sets the pick mode @see picktool#setmode returns the pickmode @see picktool#getmode sets the pick tolerance @see pickcanvas#settolerance returns the pick tolerance @see pickcanvas#gettolerance subclasses shall implement this update function process mouse move event"
edu.uci.ics.jung.visualization3d.control.PickRotateBehavior "$rcsfile: pickrotatebehavior.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ a mouse behavior that allows creates a pick/rotate behavior that waits for creates a pick/rotate behavior that waits for update the scene to manipulate any nodes. this is not meant to be called by callback method from mo register the class to be called each time the picked object moves int pickmode = picktool.bounds; free the pickresult need to clean up issue 123 --- chien freepickresult(pr);"
edu.uci.ics.jung.visualization3d.control.PickSphereBehavior "a mouse behavior that allows jung.sourceforge.net/license.txt for a description. fill currxform with the current values now i just want the translational part of transformy"
edu.uci.ics.jung.visualization3d.control.PickTranslateBehavior "$rcsfile: picktranslatebehavior.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ a mouse behavior that allows creates a pick/translate behavior that waits for creates a pick/translate behavior that waits for update the scene to manipulate any nodes. this is not meant to be called by callback method from mousetranslate this is used when the picking callback is enabled register the class to be called each time the picked object moves system.err.println("update scene pick translate"); need to clean up issue 123 --- chien freepickresult(pr);"
edu.uci.ics.jung.visualization3d.control.PickZoomBehavior "$rcsfile: pickzoombehavior.java,v $ copyright (c) 2006 sun microsystems, inc. all rights reserved. redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: - redistribution of source code must retain the above copyright notice, this list of conditions and the following disclaimer. - redistribution in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. neither the name of sun microsystems, inc. or the names of contributors may be used to endorse or promote products derived from this software without specific prior written permission. this software is provided "as is," without a warranty of any kind. all express or implied conditions, representations and warranties, including any implied warranty of merchantability, fitness for a particular purpose or non-infringement, are hereby excluded. sun microsystems, inc. ("sun") and its licensors shall not be liable for any damages suffered by licensee as a result of using, modifying or distributing this software or its derivatives. in no event will sun or its licensors be liable for any lost revenue, profit or data, or for direct, indirect, special, consequential, incidental or punitive damages, however caused and regardless of the theory of liability, arising out of the use of or inability to use this software, even if sun has been advised of the possibility of such damages. you acknowledge that this software is not designed, licensed or intended for use in the design, construction, operation or maintenance of any nuclear facility. $revision: 1.1 $ $date: 2009/04/08 06:31:15 $ $state: exp $ a mouse behavior that allows creates a pick/zoom behavior that waits for creates a pick/zoom behavior that waits for update the scene to manipulate any nodes. this is not meant to be called by callback method from mousezoom this is used when the picking callback is enabled register the class to be called each time the picked object moves need to clean up issue 123 --- chien freepickresult(pr);"
edu.uci.ics.jung.visualization3d.decorators.PickableVertexPaintTransformer "paints each vertex according to the paint parameters given in the constructor, so that picked and non-picked vertices can be made to look different. specifies which vertices report as "picked" _paint paint used to draw vertex shapes _paint paint used to fill vertex shapes _paint paint used to fill picked vertex shapes jung.sourceforge.net/license.txt for a description. protected paint draw_paint; paint draw_paint, this.draw_paint = draw_paint; public paint getdrawpaint(v v) { return draw_paint; }"
edu.uci.ics.jung.visualization3d.EdgeGroup "jung.sourceforge.net/license.txt for a description. cylinder cylinder = new cylinder(radius, 1, cylinder.generate_normals | cylinder.generate_texture_coords | cylinder.enable_geometry_picking, 26, 26, look); calculate length transform to accumulate values translate so end is at p0 scale so length is dist p0,p1 cross is the vector to rotate about"
edu.uci.ics.jung.visualization3d.layout.LayoutDecorator "a pure decorator for the layout interface. intended to be overridden to provide specific behavior decoration getter for the delegate delegate setter for the delegate the new delegate @see edu.uci.ics.jung.algorithms.layout.layout#step() @see edu.uci.ics.jung.algorithms.layout.layout#initialize() @see edu.uci.ics.jung.algorithms.layout.layout#setinitializer(org.apache.commons.collections15.transformer) @see edu.uci.ics.jung.algorithms.layout.layout#setlocation(java.lang.object, java.awt.geom.point3f) @see edu.uci.ics.jung.algorithms.layout.layout#getcurrentsize() @see edu.uci.ics.jung.algorithms.layout.layout#getgraph() @see edu.uci.ics.jung.algorithms.layout.layout#getlocation(edu.uci.ics.jung.graph.archetypevertex) @see edu.uci.ics.jung.algorithms.layout.layout#done() @see edu.uci.ics.jung.algorithms.layout.layout#lockvertex(edu.uci.ics.jung.graph.vertex) @see edu.uci.ics.jung.algorithms.layout.layout#islocked(v) @see edu.uci.ics.jung.algorithms.layout.layout#resize(java.awt.dimension) @see edu.uci.ics.jung.algorithms.layout.layout#reset() jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization3d.layout.LayoutEventBroadcaster "a layoutdecorator the fires changeevents when certain methods are called. used to wrap a layout so that the visualization components can be notified of changes. @see layoutdecorator @see edu.uci.ics.jung.algorithms.layout.layout#step() @see edu.uci.ics.jung.algorithms.layout.layout#initialize() @see edu.uci.ics.jung.algorithms.layout.layout#setlocation(java.lang.object, java.awt.geom.point2d) jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization3d.PickVertexBehavior "jung.sourceforge.net/license.txt for a description. buttonone clear previous picked stuff"
edu.uci.ics.jung.visualization3d.PluggableRenderContext "jung.sourceforge.net/license.txt for a description. graylook.setcapability(appearance.allow_material_read); graylook.setcapability(appearance.allow_material_write); return new cylinder(1, 1, cylinder.generate_normals | cylinder.enable_geometry_picking, 26, 26, lightgraylook);"
edu.uci.ics.jung.visualization3d.RenderContext "jung.sourceforge.net/license.txt for a description."
edu.uci.ics.jung.visualization3d.VertexGroup "shape the shape to set labelnode jung.sourceforge.net/license.txt for a description. tt.settranslation(new vector3f(10,10,0));"
edu.uci.ics.jung.visualization3d.VisualizationViewer "a listener used to cause pick events to result in repaints, even if they come from another view holds the state of which vertices of the graph are currently 'picked' holds the state of which edges of the graph are currently 'picked' (non-javadoc) @see edu.uci.ics.jung.visualization.visualizationserver#setpickededgestate(edu.uci.ics.jung.visualization.picking.pickedstate) rendercontext jung.sourceforge.net/license.txt for a description. appearance vertexlook; appearance edgelook; controls = createcontrols(); create a springgraph scene and attach it to the virtual universe this will move the viewplatform back a bit so the objects in the scene can be viewed. t3d.setscale(0.05); objroot.addchild(objtrans); create colors, materials, and appearances. vertexlook = redlook; behavior2.setfactor(10); objtrans.addchild(ptb); system.err.println(tg+" transformchanged \n"+t3d); transform3d lvw = new transform3d(); tg.getlocaltovworld(lvw); system.err.println("lvw = \n"+lvw); lvw.invert(); system.err.println("invert lvw = \n"+lvw); transform3d vwip = new transform3d(); canvas.getvworldtoimageplate(vwip); system.err.println("vwip=\n"+vwip); t3d.mul(lvw); scale.transform(p1); p1.set(p1.getx()2,p1.gety()2,p1.getz()2); layout.setlocation(v, p1); shine it with two colored lights. let java 3d perform optimizations on this scene graph. visrunner runner = new visrunner((iterativecontext)elayout); runner.relax(); this.layout = inlayout; textshape.setalignmentaxis( 0.0f, 1.0f, 0.0f); objscale.addchild( textshape ); branchgroup bg = new branchgroup(); bg.addchild(textshape); branch.addchild(bg); text2d text = new text2d(label+" more text here", new color3f(0,0,0),"serif",50,font.bold); tt.settranslation(new vector3f(100,100,100)); textshape.setgeometry(text); branch.addchild(bg); system.err.println("branch is "+branch); for(int i=0; i<branch.numchildren(); i++) { system.err.println("branch child ["+i+"] is "+branch.getchild(i)); } for(int i=0; i<objtrans.numchildren(); i++) { system.err.println("objtrans child ["+i+"] is "+objtrans.getchild(i)); } public static void main(string argv[]) { final visualizationviewer enigma = new visualizationviewer(); jframe f = new jframe(); f.add(enigma); f.setsize(600,600); f.setdefaultcloseoperation(jframe.exit_on_close); // new mainframe(enigma, 500, 500); // f.pack(); f.setvisible(true); }"
