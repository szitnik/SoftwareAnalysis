#CANONICAL_CLASS_NAME "COMMENTS"
org.jblas.benchmark.ATLASDoubleMultiplicationBenchmark ""
org.jblas.benchmark.ATLASFloatMultiplicationBenchmark ""
org.jblas.benchmark.Benchmark ""
org.jblas.benchmark.BenchmarkResult ""
org.jblas.benchmark.JavaDoubleMultiplicationBenchmark "compute c = a b"
org.jblas.benchmark.JavaFloatMultiplicationBenchmark "compute c = a b"
org.jblas.benchmark.Main "a simple command-line style benchmarking program. benchmarks matrix-matrix multiplication, and compares to a pure java implementation"
org.jblas.benchmark.package-info "simple benchmarking tool. run org.jblas.benchmark.main."
org.jblas.benchmark.Timer ""
org.jblas.ComplexDouble "a complex value with double precision. add two complex numbers in-place add two complex numbers in-place storing the result in this. add two complex numbers. add a real number to a complex number in-place. add a real number to complex number in-place, storing the result in this. add a real number to a complex number. subtract two complex numbers, in-place subtract two complex numbers multiply two complex numbers, inplace multiply two complex numbers divide two complex numbers divide two complex numbers, in-place return the absolute value returns the argument of a complex number. comparing two doublecomplex values."
org.jblas.ComplexDoubleMatrix "constructors and factory functions create a new matrix with newrows rows, newcolumns columns using newdata> as the data. creates a new n times m complexdoublematrix. the number of rows (n) of the new matrix. the number of columns (m) of the new matrix. creates a new complexdoublematrix of size 0 times 0. create a matrix of length len. by default, this creates a row vector. construct a complex matrix from a real matrix. construct a complex matrix from separate real and imaginary parts. either part can be set to null in which case it will be ignored. creates a new matrix by reading it from a file. the path and name of the file to read the matrix from @throws ioexception creates a new n times m complexdoublematrix from the given n times m 2d data array. the first dimension of the array makes the rows (n) and the second dimension the columns (m). for example, the given code  new complexdoublematrix(new double[][]{{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}}).print(); will constructs the following matrix:  1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 . n times m data array creates a new matrix in which all values are equal 0. number of rows number of columns matrix creates a new matrix in which all values are equal 1. number of rows number of columns matrix creates a new matrix where the values of the given vector are the diagonal values of the matrix. the diagonal values matrix construct a matrix of arbitrary shape and set the diagonal according to a passed vector. length of needs to be smaller than rows or columns. vector to fill the diagonal with number of rows of the resulting matrix number of columns of the resulting matrix matrix with dimensions rows columns whose diagonal elements are filled by x create a 1 1 - matrix. for many operations, this matrix functions like a normal double value of the matrix constructed complexdoublematrix test whether a matrix is scalar return the first element of the matrix working with slices (man! 30+ methods just to make this a bit flexible...) basic operations (copying, resizing, element access) return transposed copy of this matrix compute complex conjugate (in-place). compute complex conjugate. compare two matrices. object to compare to if and only if other is also a complexdoublematrix which has the same size and the maximal absolute difference in matrix elements is smaller thatn 1e-6. resize the matrix. all elements will be set to zero. reshape the matrix. number of elements must not change. checks whether two matrices have the same size. assert that two matrices have the same size. the other matrix @throws sizeexception if matrix sizes don't match. check whether this can be multiplied with a. right-hand-side of the multiplication. iff this.columns == a.rows copy complexdoublematrix a to this. this a is resized if necessary. returns a duplicate of this matrix. geometry is the same (including offsets, transpose, etc.), but the buffer is not shared. set matrix element retrieve matrix element get matrix element, passing the variable to store the result. get index of an element checks whether the matrix is empty. checks whether the matrix is square. checks whether the matrix is a vector. get diagonal of the matrix. get real part of the matrix. get imaginary part of the matrix. pretty-print this matrix to system.out. generate string representation of this matrix (multi-line). arithmetic operations ensures that the result vector has the same length as this. if not, resizing result is tried, which fails if result == this or result == other. add two matrices. add a scalar to a matrix. subtract two matrices. subtract a scalar from a matrix subtract two matrices, but subtract first from second matrix, that is, compute result = other - this. subtract a matrix from a scalar (elementwise) multiplication (elementwise) multiplication with a scalar matrix-matrix multiplication check sizes and resize if necessary actually, blas cannot do multiplications in-place. therefore, we will fake by allocating a temporary object on the side and copy the result later. matrix-matrix multiplication with a scalar (for symmetry, does the same as muli(scalar) (elementwise) division (elementwise) division with a scalar (elementwise) division, with operands switched. computes result = other / this. (elementwise) division with a scalar, with operands switched. computes result = a / this. rank one-updates computes a rank-1-update a = a + alpha x y'. computes a rank-1-update a = a + alpha x x'. computes a rank-1-update a = a + alpha x x'. computes a rank-1-update a = a + x x'. computes a rank-1-update a = a + x y'. logical operations computes this^t other computes this^h other return a vector containing the sums of the columns (having number of columns many entries) elementwise functions add a row vector to all rows of the matrix add a vector to all columns of the matrix add a row vector to all rows of the matrix add a vector to all columns of the matrix writes out this matrix to the given data stream. the data output stream to write to. @throws ioexception reads in a matrix from the given data stream. note that the old data of this matrix will be discarded. the data input stream to read from. @throws ioexception saves this matrix to the specified file. the file to write the matrix in. @throws ioexception thrown on errors while writing the matrix to the file loads a matrix from a file into this matrix. note that the old data of this matrix will be discarded. the file to read the matrix from @throws ioexception thrown on errors while reading the matrix autogenerated code code for operators overloads for the usual arithmetic operations # def gen_overloads(base, result_rows, result_cols);  %d\n", rowindex, columnindex, (rows columnindex + rowindex) 2); rjpp-begin------------------------------------------------------------ rjpp-end--------------------------------------------------------------"
org.jblas.ComplexFloat "a complex value with float precision. add two complex numbers in-place add two complex numbers in-place storing the result in this. add two complex numbers. add a real number to a complex number in-place. add a real number to complex number in-place, storing the result in this. add a real number to a complex number. subtract two complex numbers, in-place subtract two complex numbers multiply two complex numbers, inplace multiply two complex numbers divide two complex numbers divide two complex numbers, in-place return the absolute value returns the argument of a complex number. comparing two doublecomplex values."
org.jblas.ComplexFloatMatrix "constructors and factory functions create a new matrix with newrows rows, newcolumns columns using newdata> as the data. creates a new n times m complexfloatmatrix. the number of rows (n) of the new matrix. the number of columns (m) of the new matrix. creates a new complexfloatmatrix of size 0 times 0. create a matrix of length len. by default, this creates a row vector. construct a complex matrix from a real matrix. construct a complex matrix from separate real and imaginary parts. either part can be set to null in which case it will be ignored. creates a new matrix by reading it from a file. the path and name of the file to read the matrix from @throws ioexception creates a new n times m complexfloatmatrix from the given n times m 2d data array. the first dimension of the array makes the rows (n) and the second dimension the columns (m). for example, the given code  new complexfloatmatrix(new float[][]{{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}}).print(); will constructs the following matrix:  1.0f 2.0f 3.0f 4.0f 5.0f 6.0f 7.0f 8.0f 9.0f . n times m data array creates a new matrix in which all values are equal 0. number of rows number of columns matrix creates a new matrix in which all values are equal 1. number of rows number of columns matrix creates a new matrix where the values of the given vector are the diagonal values of the matrix. the diagonal values matrix construct a matrix of arbitrary shape and set the diagonal according to a passed vector. length of needs to be smaller than rows or columns. vector to fill the diagonal with number of rows of the resulting matrix number of columns of the resulting matrix matrix with dimensions rows columns whose diagonal elements are filled by x create a 1 1 - matrix. for many operations, this matrix functions like a normal float value of the matrix constructed complexfloatmatrix test whether a matrix is scalar return the first element of the matrix working with slices (man! 30+ methods just to make this a bit flexible...) basic operations (copying, resizing, element access) return transposed copy of this matrix compute complex conjugate (in-place). compute complex conjugate. compare two matrices. object to compare to if and only if other is also a complexfloatmatrix which has the same size and the maximal absolute difference in matrix elements is smaller thatn 1e-6. resize the matrix. all elements will be set to zero. reshape the matrix. number of elements must not change. checks whether two matrices have the same size. assert that two matrices have the same size. the other matrix @throws sizeexception if matrix sizes don't match. check whether this can be multiplied with a. right-hand-side of the multiplication. iff this.columns == a.rows copy complexfloatmatrix a to this. this a is resized if necessary. returns a duplicate of this matrix. geometry is the same (including offsets, transpose, etc.), but the buffer is not shared. set matrix element retrieve matrix element get matrix element, passing the variable to store the result. get index of an element checks whether the matrix is empty. checks whether the matrix is square. checks whether the matrix is a vector. get diagonal of the matrix. get real part of the matrix. get imaginary part of the matrix. pretty-print this matrix to system.out. generate string representation of this matrix (multi-line). arithmetic operations ensures that the result vector has the same length as this. if not, resizing result is tried, which fails if result == this or result == other. add two matrices. add a scalar to a matrix. subtract two matrices. subtract a scalar from a matrix subtract two matrices, but subtract first from second matrix, that is, compute result = other - this. subtract a matrix from a scalar (elementwise) multiplication (elementwise) multiplication with a scalar matrix-matrix multiplication check sizes and resize if necessary actually, blas cannot do multiplications in-place. therefore, we will fake by allocating a temporary object on the side and copy the result later. matrix-matrix multiplication with a scalar (for symmetry, does the same as muli(scalar) (elementwise) division (elementwise) division with a scalar (elementwise) division, with operands switched. computes result = other / this. (elementwise) division with a scalar, with operands switched. computes result = a / this. rank one-updates computes a rank-1-update a = a + alpha x y'. computes a rank-1-update a = a + alpha x x'. computes a rank-1-update a = a + alpha x x'. computes a rank-1-update a = a + x x'. computes a rank-1-update a = a + x y'. logical operations computes this^t other computes this^h other return a vector containing the sums of the columns (having number of columns many entries) elementwise functions add a row vector to all rows of the matrix add a vector to all columns of the matrix add a row vector to all rows of the matrix add a vector to all columns of the matrix writes out this matrix to the given data stream. the data output stream to write to. @throws ioexception reads in a matrix from the given data stream. note that the old data of this matrix will be discarded. the data input stream to read from. @throws ioexception saves this matrix to the specified file. the file to write the matrix in. @throws ioexception thrown on errors while writing the matrix to the file loads a matrix from a file into this matrix. note that the old data of this matrix will be discarded. the file to read the matrix from @throws ioexception thrown on errors while reading the matrix autogenerated code code for operators overloads for the usual arithmetic operations # def gen_overloads(base, result_rows, result_cols);  %d\n", rowindex, columnindex, (rows columnindex + rowindex) 2); rjpp-begin------------------------------------------------------------ rjpp-end--------------------------------------------------------------"
org.jblas.ConvertsToDoubleMatrix "to change this template, choose tools | templates and open the template in the editor. experimental, not yet used for anything usefull... ."
org.jblas.ConvertsToFloatMatrix "to change this template, choose tools | templates and open the template in the editor."
org.jblas.Decompose "to change this template, choose tools | templates and open the template in the editor. matrix which collects all kinds of decompositions. class to hold an lu decomposition result. contains a lower matrix l, and upper matrix u, and a permutation matrix p such that plu is the original matrix.  compute lu decomposition of a general matrix. computes the lu decomposition using getrf. returns three matrices l, u, p, where l is lower diagonal, u is upper diagonal, and p is a permutation matrix such that a = p l u. general matrix ludecomposition object. if (info ) compute cholesky decomposition of a symmetric, positive definite matrix (only upper half is used) triangular matrix u such that a = u' u compute lu decomposition of a general matrix. computes the lu decomposition using getrf. returns three matrices l, u, p, where l is lower diagonal, u is upper diagonal, and p is a permutation matrix such that a = p l u. general matrix ludecomposition object. compute cholesky decomposition of a symmetric, positive definite matrix (only upper half is used) triangular matrix u such that a = u' u class to represent a qr decomposition.  qr decomposition. decomposes (m,n) matrix a into a (m,m) matrix q and an (m,n) matrix r such that q is orthogonal, r is upper triangular and q r = a note that if a has more rows than columns, then the lower rows of r will contain only zeros, such that the corresponding later columns of q do not enter the computation at all. for some reason, lapack does not properly normalize those columns. matrix decomposition qr decomposition. decomposes (m,n) matrix a into a (m,m) matrix q and an (m,n) matrix r such that q is orthogonal, r is upper triangular and q r = a matrix decomposition collect result collect result"
org.jblas.DoubleFunction "represents a function on doubles. compute the function."
org.jblas.DoubleMatrix "a general matrix class for double typed values. don't be intimidated by the large number of methods this function defines. most are overloads provided for ease of use. for example, for each arithmetic operation, up to six overloaded versions exist to handle in-place computations, and scalar arguments. construction to construct a two-dimensional matrices, you can use the following constructors and static methods.  methoddescription doublematrix(m,n, [value1, value2, value3...])values are filled in row by row. doublematrix(new double[][] {{value1, value2, ...}, ...}inner arrays are columns. doublematrix.zeros(m,n) initial values set to 0.0. doublematrix.ones(m,n) initial values set to 1.0. doublematrix.rand(m,n) values drawn at random between 0.0 and 1.0. doublematrix.randn(m,n) values drawn from normal distribution. doublematrix.eye(n) unit matrix (values 0.0 except for 1.0 on the diagonal). doublematrix.diag(array) diagonal matrix with given diagonal elements.  alternatively, you can construct (column) vectors, if you just supply the length using the following constructors and static methods.  methoddescription doublematrix(m)constructs a column vector. doublematrix(new double[] {value1, value2, ...})constructs a column vector. doublematrix.zeros(m) initial values set to 0.0. doublematrix.ones(m) initial values set to 1.0. doublematrix.rand(m) values drawn at random between 0.0 and 1.0. doublematrix.randn(m) values drawn from normal distribution.  you can also construct new matrices by concatenating matrices either horziontally or vertically:  methoddescription x.concathorizontally(y)new matrix will be x next to y. x.concatvertically(y)new matrix will be x atop y.  element access, copying and duplication to access individual elements, or whole rows and columns, use the following methods:  x.methoddescription x.get(i,j)get element in row i and column j. x.put(i, j, v)set element in row i and column j to value v x.get(i)get the ith element of the matrix (traversing rows first). x.put(i, v)set the ith element of the matrix (traversing rows first). x.getcolumn(i)get a copy of column i. x.putcolumn(i, c)put matrix c into column i. x.getrow(i)get a copy of row i. x.putrow(i, c)put matrix c into row i. x.swapcolumns(i, j)swap the contents of columns i and j. x.swaprows(i, j)swap the contents of columns i and j.  for get and put, you can also pass integer arrays, doublematrix objects, or range objects, which then specify the indices used as follows:  integer array: the elements will be used as indices. doublematrix object: non-zero entries specify the indices. range object: see below.  when using put with multiple indices, the assigned object must have the correct size or be a scalar. there exist the following range objects. the class rangeutils also contains the a number of handy helper methods for constructing these ranges.  class rangeutils method indices allrange all() all legal indices. pointrange point(i)  a single point. intervalrange interval(a, b) all indices from a to b (inclusive) indicesrange indices(int[]) the specified indices. indices(doublematrix)the specified indices. find(doublematrix)the non-zero entries of the matrix.  the following methods can be used for duplicating and copying matrices.  methoddescription x.dup()get a copy of x. x.copy(y)copy the contents of y to x (possible resizing x).  size and shape the following methods permit to acces the size of a matrix and change its size or shape.  x.methoddescription x.rowsnumber of rows. x.columnsnumber of columns. x.lengthtotal number of elements. x.isempty()checks whether rows == 0 and columns == 0. x.isrowvector()checks whether rows == 1. x.iscolumnvector()checks whether columns == 1. x.isvector()checks whether rows == 1 or columns == 1. x.issquare()checks whether rows == columns. x.isscalar()checks whether length == 1. x.resize(r, c)resize the matrix to r rows and c columns, discarding the content. x.reshape(r, c)resize the matrix to r rows and c columns. number of elements must not change.  the size is stored in the rows and columns member variables. the total number of elements is stored in length. do not change these values unless you know what you're doing! arithmetics the usual arithmetic operations are implemented. each operation exists in a in-place version, recognizable by the suffix "i", to which you can supply the result matrix (or this is used, if missing). using in-place operations can also lead to a smaller memory footprint, as the number of temporary objects which are directly garbage collected again is reduced. whenever you specify a result vector, the result vector must already have the correct dimensions. for example, you can add two matrices using the add method. if you want to store the result in of x + y in z, type  x.addi(y, z) // computes x = y + z.  even in-place methods return the result, such that you can easily chain in-place methods, for example:  x.addi(y).addi(z) // computes x += y; x += z  methods which operate element-wise only make sure that the length of the matrices is correct. therefore, you can add a 3 3 matrix to a 1 9 matrix, for example. finally, there exist versions which take doubles instead of doublematrix objects as arguments. these then compute the operation with the same value as the right-hand-side. the same effect can be achieved by passing a doublematrix with exactly one element.  operation method comment x + y x.add(y)  x - y x.sub(y), y.rsub(x) rsub subtracts left from right hand side x y x.mul(y) element-wise multiplication  x.mmul(y)matrix-matrix multiplication  x.dot(y) scalar-product x / y x.div(y), y.rdiv(x) rdiv divides right hand side by left hand side. - x x.neg()   there also exist operations which work on whole columns or rows.  method description x.addrowvectoradds a vector to each row (addirowvector works in-place) x.addcolumnvectoradds a vector to each column x.subrowvectorsubtracts a vector from each row x.subcolumnvectorsubtracts a vector from each column x.mulrowmultiplies a row by a scalar x.mulcolumnmultiplies a row by a column  in principle, you could achieve the same result by first calling getcolumn(), adding, and then calling putcolumn, but these methods are much faster. the following comparison operations are available  operation method x &lt; y x.lt(y) x &lt;= y x.le(y) x &gt; y x.gt(y) x &gt;= y x.ge(y) x == y x.eq(y) x != y x.ne(y)   logical operations are also supported. for these operations, a value different from zero is treated as "true" and zero is treated as "false". all operations are carried out elementwise.  operation method x & y x.and(y) x | y x.or(y) x ^ y x.xor(y) ! x x.not()  finally, there are a few more methods to compute various things:  method description x.max() return maximal element x.argmax() return index of largest element x.min() return minimal element x.argmin() return index of largest element x.columnmins() return column-wise minima x.columnargmins() return column-wise index of minima x.columnmaxs() return column-wise maxima x.columnargmaxs() return column-wise index of maxima  number of rows. number of columns. total number of elements (for convenience). the actual data stored by rows (that is, row 0, row 1...). constructors and factory functions create a new matrix with newrows rows, newcolumns columns using newdata> as the data. the length of the data is not checked! creates a new n times m doublematrix. the number of rows (n) of the new matrix. the number of columns (m) of the new matrix. creates a new doublematrix of size 0 times 0. create a matrix of length len. by default, this creates a row vector. creates a new matrix by reading it from a file. the path and name of the file to read the matrix from @throws ioexception creates a new n times m doublematrix from the given n times m 2d data array. the first dimension of the array makes the rows (n) and the second dimension the columns (m). for example, the given code  new doublematrix(new double[][]{{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}}).print(); will constructs the following matrix:  1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0 9.0 . n times m data array construct doublematrix from ascii representation. this is not very fast, but can be quiet useful when you want to "just" construct a matrix, for example when testing. the format is semicolon separated rows of space separated values, for example "1 2 3; 4 5 6; 7 8 9". serialization create matrix with random values uniformly in 0..1. creates a row vector with random values uniformly in 0..1. create matrix with normally distributed random values. create row vector with normally distributed random values. creates a new matrix in which all values are equal 0. creates a row vector of given length. creates a new matrix in which all values are equal 1. creates a row vector with all elements equal to 1. construct a new n-by-n identity matrix. creates a new matrix where the values of the given vector are the diagonal values of the matrix. construct a matrix of arbitrary shape and set the diagonal according to a passed vector. length of needs to be smaller than rows or columns. vector to fill the diagonal with number of rows of the resulting matrix number of columns of the resulting matrix matrix with dimensions rows columns whose diagonal elements are filled by x create a 1-by-1 matrix. for many operations, this matrix functions like a normal double. test whether a matrix is scalar. return the first element of the matrix. concatenates two matrices horizontally. matrices must have identical numbers of rows. concatenates two matrices vertically. matrices must have identical numbers of columns. working with slices (man! 30+ methods just to make this a bit flexible...) get all elements specified by the linear indices. get all elements for a given row and the specified columns. get all elements for a given column and the specified rows. get all elements from the specified rows and columns. get elements from specified rows and columns. get elements specified by the non-zero entries of the passed matrix. get elements from a row and columns as specified by the non-zero entries of a matrix. get elements from a column and rows as specified by the non-zero entries of a matrix. get elements from columns and rows as specified by the non-zero entries of the passed matrices. return all elements with linear index a, a + 1, ..., b - 1. get elements from a row and columns a to b. get elements from a column and rows a/tt> to b. get elements from rows ra to rb and columns ca to cb. get whole rows from the passed indices. get whole rows as specified by the non-zero entries of a matrix. get whole columns from the passed indices. get whole columns as specified by the non-zero entries of a matrix. assert that the matrix has a certain length. @throws sizeexception asserts that the matrix has a certain number of rows. @throws sizeexception asserts that the amtrix has a certain number of columns. @throws sizeexception set elements in linear ordering in the specified indices. for example, a.put(new int[]{ 1, 2, 0 }, new doublematrix(3, 1, 2.0, 4.0, 8.0) does a.put(1, 2.0), a.put(2, 4.0), a.put(0, 8.0). set multiple elements in a row. set multiple elements in a row. put a sub-matrix as specified by the indices. put a matrix into specified indices. put a single value into the specified indices (linear adressing). put a single value into a row and the specified columns. put a single value into the specified rows of a column. put a single value into the specified rows and columns. put a sub-matrix into the indices specified by the non-zero entries of indices (linear adressing). put a sub-vector into the specified columns (non-zero entries of indices) of a row. put a sub-vector into the specified rows (non-zero entries of indices) of a column. put a sub-matrix into the specified rows and columns (non-zero entries of rindices and cindices. put a single value into the elements specified by the non-zero entries of indices (linear adressing). put a single value into the specified columns (non-zero entries of indices) of a row. put a single value into the specified rows (non-zero entries of indices) of a column. put a single value in the specified rows and columns (non-zero entries of rindices and cindices. find the linear indices of all non-zero elements. basic operations (copying, resizing, element access) return transposed copy of this matrix. compare two matrices. returns true if and only if other is also a doublematrix which has the same size and the maximal absolute difference in matrix elements is smaller thatn 1e-6. resize the matrix. all elements will be set to zero. reshape the matrix. number of elements must not change. generate a new matrix which has the given number of replications of this. checks whether two matrices have the same size. throws sizeexception unless two matrices have the same size. checks whether two matrices can be multiplied (that is, number of columns of this must equal number of rows of a. throws sizeexception unless matrices can be multiplied with one another. checks whether two matrices have the same length. throws sizeexception unless matrices have the same length. copy doublematrix a to this. this a is resized if necessary. returns a duplicate of this matrix. geometry is the same (including offsets, transpose, etc.), but the buffer is not shared. swap two columns of a matrix. swap two rows of a matrix. set matrix element retrieve matrix element get index of an element compute the row index of a linear index. compute the column index of a linear index. get a matrix element (linear indexing). set a matrix element (linear indexing). set all elements to a value. get number of rows. get number of columns. get total number of elements. checks whether the matrix is empty. checks whether the matrix is square. throw sizeexception unless matrix is square. checks whether the matrix is a vector. checks whether the matrix is a row vector. checks whether the matrix is a column vector. returns the diagonal of the matrix. pretty-print this matrix to system.out. generate string representation of the matrix. generate string representation of the matrix, with specified format for the entries. for example, x.tostring("%.1f") generates a string representations having only one position after the decimal point. generate string representation of the matrix, with specified format for the entries, and delimiters. entry format (passed to string.format()) opening parenthesis closing parenthesis separator between columns separator between rows converts the matrix to a one-dimensional array of doubles. converts the matrix to a two-dimensional array of doubles. converts the matrix to a one-dimensional array of integers. convert the matrix to a two-dimensional array of integers. convert the matrix to a one-dimensional array of boolean values. convert the matrix to a two-dimensional array of boolean values. a wrapper which allows to view a matrix as a list of doubles (read-only!). also implements the {@link convertstodoublematrix} interface. arithmetic operations ensures that the result vector has the same length as this. if not, resizing result is tried, which fails if result == this or result == other. add two matrices (in-place). simpleblas.copy(this, result); simpleblas.axpy(1.0, other, result); add a scalar to a matrix (in-place). subtract two matrices (in-place). subtract a scalar from a matrix (in-place). subtract two matrices, but subtract first from second matrix, that is, compute result = other - this (in-place). subtract a matrix from a scalar (in-place). elementwise multiplication (in-place). elementwise multiplication with a scalar (in-place). matrix-matrix multiplication (in-place). check sizes and resize if necessary actually, blas cannot do multiplications in-place. therefore, we will fake by allocating a temporary object on the side and copy the result later. matrix-matrix multiplication with a scalar (for symmetry, does the same as muli(scalar) (in-place). elementwise division (in-place). elementwise division with a scalar (in-place). elementwise division, with operands switched. computes result = other / this (in-place). (elementwise) division with a scalar, with operands switched. computes result = a / this (in-place). negate each element (in-place). negate each element. maps zero to 1.0 and all non-zero values to 0.0 (in-place). maps zero to 1.0 and all non-zero values to 0.0. maps zero to 0.0 and all non-zero values to 1.0 (in-place). maps zero to 0.0 and all non-zero values to 1.0. checks whether all entries (i, j) with i >= j are zero. checks whether all entries (i, j) with i x.sum() / x.length. computes the cumulative sum, that is, the sum of all elements of the matrix up to a given index in linear addressing (in-place). computes the cumulative sum, that is, the sum of all elements of the matrix up to a given index in linear addressing. the scalar product of this with other. computes the projection coefficient of other on this. the returned scalar times this is the orthogonal projection of other on this. the euclidean norm of the matrix as vector, also the frobenius norm of the matrix. the maximum norm of the matrix (maximal absolute value of the elements). the 1-norm of the matrix as vector (sum of absolute values of elements). returns the squared (euclidean) distance. returns the (euclidean) distance. returns the (1-norm) distance. return a new matrix with all elements sorted. sort elements in-place. get the sorting permutation. int[] array such that which indexes the elements in sorted order. sort columns (in-place). sort columns. return matrix of indices which sort all columns. sort rows (in-place). sort rows. return matrix of indices which sort all columns. return a vector containing the sums of the columns (having number of columns many entries) return a vector containing the means of all columns. return a vector containing the sum of the rows. return a vector containing the means of the rows. column and rows access. get a copy of a column. copy a column to the given vector. copy a column back into the matrix. get a copy of a row. copy a row to a given vector. copy a row back into the matrix. return column-wise minimums. return index of minimal element per column. return column-wise maximums. return index of minimal element per column. return row-wise minimums. return index of minimal element per row. return row-wise maximums. return index of minimal element per row. elementwise functions add a row vector to all rows of the matrix (in place). add a row to all rows of the matrix. add a vector to all columns of the matrix (in-place). add a vector to all columns of the matrix. subtract a row vector from all rows of the matrix (in-place). subtract a row vector from all rows of the matrix. subtract a column vector from all columns of the matrix (in-place). subtract a vector from all columns of the matrix. multiply a row by a scalar. multiply a column by a scalar. multiply all columns with a column vector (in-place). multiply all columns with a column vector. multiply all rows with a row vector (in-place). multiply all rows with a row vector. writes out this matrix to the given data stream. the data output stream to write to. @throws ioexception reads in a matrix from the given data stream. note that the old data of this matrix will be discarded. the data input stream to read from. @throws ioexception saves this matrix to the specified file. the file to write the matrix in. @throws ioexception thrown on errors while writing the matrix to the file loads a matrix from a file into this matrix. note that the old data of this matrix will be discarded. the file to read the matrix from @throws ioexception thrown on errors while reading the matrix autogenerated code code for operators overloads for the usual arithmetic operations # def gen_overloads(base, result_rows, result_cols, verb=''); ', '"greater than"'), gen_compare('le', '=', '"greater than or equal"'), gen_compare('eq', '==', 'equality'), gen_compare('ne', '!=', 'inequality'), gen_logical('and', '&', 'logical and'), gen_logical('or', '|', 'logical or'), gen_logical('xor', '^', 'logical xor')) # add a matrix (in place). add a matrix (in place). add a scalar (in place). add a scalar. subtract a matrix (in place). subtract a matrix (in place). subtract a scalar (in place). subtract a scalar. (right-)subtract a matrix (in place). (right-)subtract a matrix (in place). (right-)subtract a scalar (in place). (right-)subtract a scalar. elementwise divide by a matrix (in place). elementwise divide by a matrix (in place). elementwise divide by a scalar (in place). elementwise divide by a scalar. (right-)elementwise divide by a matrix (in place). (right-)elementwise divide by a matrix (in place). (right-)elementwise divide by a scalar (in place). (right-)elementwise divide by a scalar. elementwise multiply by a matrix (in place). elementwise multiply by a matrix (in place). elementwise multiply by a scalar (in place). elementwise multiply by a scalar. matrix-multiply by a matrix (in place). matrix-multiply by a matrix (in place). matrix-multiply by a scalar (in place). matrix-multiply by a scalar. test for "less than" (in-place). test for "less than" (in-place). test for "less than". test for "less than" against a scalar (in-place). test for "less than" against a scalar (in-place). test for "less than" against a scalar. test for "greater than" (in-place). test for "greater than" (in-place). test for "greater than". test for "greater than" against a scalar (in-place). test for "greater than" against a scalar (in-place). test for "greater than" against a scalar. test for "less than or equal" (in-place). test for "less than or equal" (in-place). test for "less than or equal". test for "less than or equal" against a scalar (in-place). test for "less than or equal" against a scalar (in-place). test for "less than or equal" against a scalar. test for "greater than or equal" (in-place). test for "greater than or equal" (in-place). test for "greater than or equal". test for "greater than or equal" against a scalar (in-place). test for "greater than or equal" against a scalar (in-place). test for "greater than or equal" against a scalar. test for equality (in-place). test for equality (in-place). test for equality. test for equality against a scalar (in-place). test for equality against a scalar (in-place). test for equality against a scalar. test for inequality (in-place). test for inequality (in-place). test for inequality. test for inequality against a scalar (in-place). test for inequality against a scalar (in-place). test for inequality against a scalar. compute elementwise logical and (in-place). compute elementwise logical and (in-place). compute elementwise logical and. compute elementwise logical and against a scalar (in-place). compute elementwise logical and against a scalar (in-place). compute elementwise logical and against a scalar. compute elementwise logical or (in-place). compute elementwise logical or (in-place). compute elementwise logical or. compute elementwise logical or against a scalar (in-place). compute elementwise logical or against a scalar (in-place). compute elementwise logical or against a scalar. compute elementwise logical xor (in-place). compute elementwise logical xor (in-place). compute elementwise logical xor. compute elementwise logical xor against a scalar (in-place). compute elementwise logical xor against a scalar (in-place). compute elementwise logical xor against a scalar.  computes x = y + z. computes x += y; x += z rows are contiguous system.err.printf("%d %d matrix process first line process rest actually, this is much harder because the data is not consecutive in memory... this is a bit crazy, but a row vector must have as length as the columns of the matrix. go through file and count columns and rows. what makes this endeavour a bit difficult is that files can have leading or trailing spaces leading to spurious fields after string.split(). go through file a second time process the actual data. rjpp-begin------------------------------------------------------------ rjpp-end--------------------------------------------------------------"
org.jblas.Eigen "eigenvalue and eigenvector related functions.  methods exist for working with symmetric matrices or general eigenvalues. the symmetric versions are usually much faster on symmetric matrices. compute the eigenvalues for a symmetric matrix. computes the eigenvalues and eigenvectors for a symmetric matrix. array of doublematrix objects containing the eigenvectors stored as the columns of the first matrix, and the eigenvalues as diagonal elements of the second matrix. computes the eigenvalues of a general matrix. computes the eigenvalues and eigenvectors of a general matrix. array of complexdoublematrix objects containing the eigenvectors stored as the columns of the first matrix, and the eigenvalues as the diagonal elements of the second matrix. compute generalized eigenvalues of the problem a x = l b x. symmetric matrix a. only the upper triangle will be considered. symmetric matrix b. only the upper triangle will be considered. vector of eigenvalues l. solve a general problem a x = l b x. symmetric matrix a symmetric matrix b array of matrices of length two. the first one is an array of the eigenvectors x the second one is a vector containing the corresponding eigenvalues l. compute the eigenvalues for a symmetric matrix. computes the eigenvalues and eigenvectors for a symmetric matrix. array of floatmatrix objects containing the eigenvectors stored as the columns of the first matrix, and the eigenvalues as diagonal elements of the second matrix. computes the eigenvalues of a general matrix. computes the eigenvalues and eigenvectors of a general matrix. array of complexfloatmatrix objects containing the eigenvectors stored as the columns of the first matrix, and the eigenvalues as the diagonal elements of the second matrix. compute generalized eigenvalues of the problem a x = l b x. symmetric matrix a. only the upper triangle will be considered. symmetric matrix b. only the upper triangle will be considered. vector of eigenvalues l. solve a general problem a x = l b x. symmetric matrix a symmetric matrix b array of matrices of length two. the first one is an array of the eigenvectors x the second one is a vector containing the corresponding eigenvalues l.  setting up result arrays transferring the result system.err.printf("vr = %s\n", vr.tostring()); begin the code below has been automatically generated. do not edit! setting up result arrays transferring the result system.err.printf("vr = %s\n", vr.tostring()); end"
org.jblas.exceptions.LapackArgumentException "lapackexception for a specific argument. lapack routines routinely check whether some arguments contain illegal arguments. this exception class automatically constructs a message for a given argument index. construct exception for given function and info. message will read "argument  had an illegal value.");"
org.jblas.exceptions.LapackConvergenceException "to change this template, choose tools | templates and open the template in the editor."
org.jblas.exceptions.LapackException "base class for all exceptions within lapack. also reports the function where the error is. construct new lapackexception for the given function. construct new lapack exception for the given function, with message."
org.jblas.exceptions.LapackPositivityException "to change this template, choose tools | templates and open the template in the editor."
org.jblas.exceptions.LapackSingularityException "exception thrown when matrices are singular."
org.jblas.exceptions.package-info "jblas related exceptions."
org.jblas.exceptions.SizeException ""
org.jblas.exceptions.UnsupportedArchitectureException "   "
org.jblas.FloatFunction "represents a function on floats. compute the function."
org.jblas.FloatMatrix "a general matrix class for float typed values. don't be intimidated by the large number of methods this function defines. most are overloads provided for ease of use. for example, for each arithmetic operation, up to six overloaded versions exist to handle in-place computations, and scalar arguments. construction to construct a two-dimensional matrices, you can use the following constructors and static methods.  methoddescription floatmatrix(m,n, [value1, value2, value3...])values are filled in row by row. floatmatrix(new float[][] {{value1, value2, ...}, ...}inner arrays are columns. floatmatrix.zeros(m,n) initial values set to 0.0f. floatmatrix.ones(m,n) initial values set to 1.0f. floatmatrix.rand(m,n) values drawn at random between 0.0f and 1.0f. floatmatrix.randn(m,n) values drawn from normal distribution. floatmatrix.eye(n) unit matrix (values 0.0f except for 1.0f on the diagonal). floatmatrix.diag(array) diagonal matrix with given diagonal elements.  alternatively, you can construct (column) vectors, if you just supply the length using the following constructors and static methods.  methoddescription floatmatrix(m)constructs a column vector. floatmatrix(new float[] {value1, value2, ...})constructs a column vector. floatmatrix.zeros(m) initial values set to 0.0f. floatmatrix.ones(m) initial values set to 1.0f. floatmatrix.rand(m) values drawn at random between 0.0f and 1.0f. floatmatrix.randn(m) values drawn from normal distribution.  you can also construct new matrices by concatenating matrices either horziontally or vertically:  methoddescription x.concathorizontally(y)new matrix will be x next to y. x.concatvertically(y)new matrix will be x atop y.  element access, copying and duplication to access individual elements, or whole rows and columns, use the following methods:  x.methoddescription x.get(i,j)get element in row i and column j. x.put(i, j, v)set element in row i and column j to value v x.get(i)get the ith element of the matrix (traversing rows first). x.put(i, v)set the ith element of the matrix (traversing rows first). x.getcolumn(i)get a copy of column i. x.putcolumn(i, c)put matrix c into column i. x.getrow(i)get a copy of row i. x.putrow(i, c)put matrix c into row i. x.swapcolumns(i, j)swap the contents of columns i and j. x.swaprows(i, j)swap the contents of columns i and j.  for get and put, you can also pass integer arrays, floatmatrix objects, or range objects, which then specify the indices used as follows:  integer array: the elements will be used as indices. floatmatrix object: non-zero entries specify the indices. range object: see below.  when using put with multiple indices, the assigned object must have the correct size or be a scalar. there exist the following range objects. the class rangeutils also contains the a number of handy helper methods for constructing these ranges.  class rangeutils method indices allrange all() all legal indices. pointrange point(i)  a single point. intervalrange interval(a, b) all indices from a to b (inclusive) indicesrange indices(int[]) the specified indices. indices(floatmatrix)the specified indices. find(floatmatrix)the non-zero entries of the matrix.  the following methods can be used for duplicating and copying matrices.  methoddescription x.dup()get a copy of x. x.copy(y)copy the contents of y to x (possible resizing x).  size and shape the following methods permit to acces the size of a matrix and change its size or shape.  x.methoddescription x.rowsnumber of rows. x.columnsnumber of columns. x.lengthtotal number of elements. x.isempty()checks whether rows == 0 and columns == 0. x.isrowvector()checks whether rows == 1. x.iscolumnvector()checks whether columns == 1. x.isvector()checks whether rows == 1 or columns == 1. x.issquare()checks whether rows == columns. x.isscalar()checks whether length == 1. x.resize(r, c)resize the matrix to r rows and c columns, discarding the content. x.reshape(r, c)resize the matrix to r rows and c columns. number of elements must not change.  the size is stored in the rows and columns member variables. the total number of elements is stored in length. do not change these values unless you know what you're doing! arithmetics the usual arithmetic operations are implemented. each operation exists in a in-place version, recognizable by the suffix "i", to which you can supply the result matrix (or this is used, if missing). using in-place operations can also lead to a smaller memory footprint, as the number of temporary objects which are directly garbage collected again is reduced. whenever you specify a result vector, the result vector must already have the correct dimensions. for example, you can add two matrices using the add method. if you want to store the result in of x + y in z, type  x.addi(y, z) // computes x = y + z.  even in-place methods return the result, such that you can easily chain in-place methods, for example:  x.addi(y).addi(z) // computes x += y; x += z  methods which operate element-wise only make sure that the length of the matrices is correct. therefore, you can add a 3 3 matrix to a 1 9 matrix, for example. finally, there exist versions which take floats instead of floatmatrix objects as arguments. these then compute the operation with the same value as the right-hand-side. the same effect can be achieved by passing a floatmatrix with exactly one element.  operation method comment x + y x.add(y)  x - y x.sub(y), y.rsub(x) rsub subtracts left from right hand side x y x.mul(y) element-wise multiplication  x.mmul(y)matrix-matrix multiplication  x.dot(y) scalar-product x / y x.div(y), y.rdiv(x) rdiv divides right hand side by left hand side. - x x.neg()   there also exist operations which work on whole columns or rows.  method description x.addrowvectoradds a vector to each row (addirowvector works in-place) x.addcolumnvectoradds a vector to each column x.subrowvectorsubtracts a vector from each row x.subcolumnvectorsubtracts a vector from each column x.mulrowmultiplies a row by a scalar x.mulcolumnmultiplies a row by a column  in principle, you could achieve the same result by first calling getcolumn(), adding, and then calling putcolumn, but these methods are much faster. the following comparison operations are available  operation method x &lt; y x.lt(y) x &lt;= y x.le(y) x &gt; y x.gt(y) x &gt;= y x.ge(y) x == y x.eq(y) x != y x.ne(y)   logical operations are also supported. for these operations, a value different from zero is treated as "true" and zero is treated as "false". all operations are carried out elementwise.  operation method x & y x.and(y) x | y x.or(y) x ^ y x.xor(y) ! x x.not()  finally, there are a few more methods to compute various things:  method description x.max() return maximal element x.argmax() return index of largest element x.min() return minimal element x.argmin() return index of largest element x.columnmins() return column-wise minima x.columnargmins() return column-wise index of minima x.columnmaxs() return column-wise maxima x.columnargmaxs() return column-wise index of maxima  number of rows. number of columns. total number of elements (for convenience). the actual data stored by rows (that is, row 0, row 1...). constructors and factory functions create a new matrix with newrows rows, newcolumns columns using newdata> as the data. the length of the data is not checked! creates a new n times m floatmatrix. the number of rows (n) of the new matrix. the number of columns (m) of the new matrix. creates a new floatmatrix of size 0 times 0. create a matrix of length len. by default, this creates a row vector. creates a new matrix by reading it from a file. the path and name of the file to read the matrix from @throws ioexception creates a new n times m floatmatrix from the given n times m 2d data array. the first dimension of the array makes the rows (n) and the second dimension the columns (m). for example, the given code  new floatmatrix(new float[][]{{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}}).print(); will constructs the following matrix:  1.0f 2.0f 3.0f 4.0f 5.0f 6.0f 7.0f 8.0f 9.0f . n times m data array construct floatmatrix from ascii representation. this is not very fast, but can be quiet useful when you want to "just" construct a matrix, for example when testing. the format is semicolon separated rows of space separated values, for example "1 2 3; 4 5 6; 7 8 9". serialization create matrix with random values uniformly in 0..1. creates a row vector with random values uniformly in 0..1. create matrix with normally distributed random values. create row vector with normally distributed random values. creates a new matrix in which all values are equal 0. creates a row vector of given length. creates a new matrix in which all values are equal 1. creates a row vector with all elements equal to 1. construct a new n-by-n identity matrix. creates a new matrix where the values of the given vector are the diagonal values of the matrix. construct a matrix of arbitrary shape and set the diagonal according to a passed vector. length of needs to be smaller than rows or columns. vector to fill the diagonal with number of rows of the resulting matrix number of columns of the resulting matrix matrix with dimensions rows columns whose diagonal elements are filled by x create a 1-by-1 matrix. for many operations, this matrix functions like a normal float. test whether a matrix is scalar. return the first element of the matrix. concatenates two matrices horizontally. matrices must have identical numbers of rows. concatenates two matrices vertically. matrices must have identical numbers of columns. working with slices (man! 30+ methods just to make this a bit flexible...) get all elements specified by the linear indices. get all elements for a given row and the specified columns. get all elements for a given column and the specified rows. get all elements from the specified rows and columns. get elements from specified rows and columns. get elements specified by the non-zero entries of the passed matrix. get elements from a row and columns as specified by the non-zero entries of a matrix. get elements from a column and rows as specified by the non-zero entries of a matrix. get elements from columns and rows as specified by the non-zero entries of the passed matrices. return all elements with linear index a, a + 1, ..., b - 1. get elements from a row and columns a to b. get elements from a column and rows a/tt> to b. get elements from rows ra to rb and columns ca to cb. get whole rows from the passed indices. get whole rows as specified by the non-zero entries of a matrix. get whole columns from the passed indices. get whole columns as specified by the non-zero entries of a matrix. assert that the matrix has a certain length. @throws sizeexception asserts that the matrix has a certain number of rows. @throws sizeexception asserts that the amtrix has a certain number of columns. @throws sizeexception set elements in linear ordering in the specified indices. for example, a.put(new int[]{ 1, 2, 0 }, new floatmatrix(3, 1, 2.0f, 4.0f, 8.0f) does a.put(1, 2.0f), a.put(2, 4.0f), a.put(0, 8.0f). set multiple elements in a row. set multiple elements in a row. put a sub-matrix as specified by the indices. put a matrix into specified indices. put a single value into the specified indices (linear adressing). put a single value into a row and the specified columns. put a single value into the specified rows of a column. put a single value into the specified rows and columns. put a sub-matrix into the indices specified by the non-zero entries of indices (linear adressing). put a sub-vector into the specified columns (non-zero entries of indices) of a row. put a sub-vector into the specified rows (non-zero entries of indices) of a column. put a sub-matrix into the specified rows and columns (non-zero entries of rindices and cindices. put a single value into the elements specified by the non-zero entries of indices (linear adressing). put a single value into the specified columns (non-zero entries of indices) of a row. put a single value into the specified rows (non-zero entries of indices) of a column. put a single value in the specified rows and columns (non-zero entries of rindices and cindices. find the linear indices of all non-zero elements. basic operations (copying, resizing, element access) return transposed copy of this matrix. compare two matrices. returns true if and only if other is also a floatmatrix which has the same size and the maximal absolute difference in matrix elements is smaller thatn 1e-6. resize the matrix. all elements will be set to zero. reshape the matrix. number of elements must not change. generate a new matrix which has the given number of replications of this. checks whether two matrices have the same size. throws sizeexception unless two matrices have the same size. checks whether two matrices can be multiplied (that is, number of columns of this must equal number of rows of a. throws sizeexception unless matrices can be multiplied with one another. checks whether two matrices have the same length. throws sizeexception unless matrices have the same length. copy floatmatrix a to this. this a is resized if necessary. returns a duplicate of this matrix. geometry is the same (including offsets, transpose, etc.), but the buffer is not shared. swap two columns of a matrix. swap two rows of a matrix. set matrix element retrieve matrix element get index of an element compute the row index of a linear index. compute the column index of a linear index. get a matrix element (linear indexing). set a matrix element (linear indexing). set all elements to a value. get number of rows. get number of columns. get total number of elements. checks whether the matrix is empty. checks whether the matrix is square. throw sizeexception unless matrix is square. checks whether the matrix is a vector. checks whether the matrix is a row vector. checks whether the matrix is a column vector. returns the diagonal of the matrix. pretty-print this matrix to system.out. generate string representation of the matrix. generate string representation of the matrix, with specified format for the entries. for example, x.tostring("%.1f") generates a string representations having only one position after the decimal point. generate string representation of the matrix, with specified format for the entries, and delimiters. entry format (passed to string.format()) opening parenthesis closing parenthesis separator between columns separator between rows converts the matrix to a one-dimensional array of floats. converts the matrix to a two-dimensional array of floats. converts the matrix to a one-dimensional array of integers. convert the matrix to a two-dimensional array of integers. convert the matrix to a one-dimensional array of boolean values. convert the matrix to a two-dimensional array of boolean values. a wrapper which allows to view a matrix as a list of doubles (read-only!). also implements the {@link convertstofloatmatrix} interface. arithmetic operations ensures that the result vector has the same length as this. if not, resizing result is tried, which fails if result == this or result == other. add two matrices (in-place). simpleblas.copy(this, result); simpleblas.axpy(1.0f, other, result); add a scalar to a matrix (in-place). subtract two matrices (in-place). subtract a scalar from a matrix (in-place). subtract two matrices, but subtract first from second matrix, that is, compute result = other - this (in-place). subtract a matrix from a scalar (in-place). elementwise multiplication (in-place). elementwise multiplication with a scalar (in-place). matrix-matrix multiplication (in-place). check sizes and resize if necessary actually, blas cannot do multiplications in-place. therefore, we will fake by allocating a temporary object on the side and copy the result later. matrix-matrix multiplication with a scalar (for symmetry, does the same as muli(scalar) (in-place). elementwise division (in-place). elementwise division with a scalar (in-place). elementwise division, with operands switched. computes result = other / this (in-place). (elementwise) division with a scalar, with operands switched. computes result = a / this (in-place). negate each element (in-place). negate each element. maps zero to 1.0f and all non-zero values to 0.0f (in-place). maps zero to 1.0f and all non-zero values to 0.0f. maps zero to 0.0f and all non-zero values to 1.0f (in-place). maps zero to 0.0f and all non-zero values to 1.0f. checks whether all entries (i, j) with i >= j are zero. checks whether all entries (i, j) with i x.sum() / x.length. computes the cumulative sum, that is, the sum of all elements of the matrix up to a given index in linear addressing (in-place). computes the cumulative sum, that is, the sum of all elements of the matrix up to a given index in linear addressing. the scalar product of this with other. computes the projection coefficient of other on this. the returned scalar times this is the orthogonal projection of other on this. the euclidean norm of the matrix as vector, also the frobenius norm of the matrix. the maximum norm of the matrix (maximal absolute value of the elements). the 1-norm of the matrix as vector (sum of absolute values of elements). returns the squared (euclidean) distance. returns the (euclidean) distance. returns the (1-norm) distance. return a new matrix with all elements sorted. sort elements in-place. get the sorting permutation. int[] array such that which indexes the elements in sorted order. sort columns (in-place). sort columns. return matrix of indices which sort all columns. sort rows (in-place). sort rows. return matrix of indices which sort all columns. return a vector containing the sums of the columns (having number of columns many entries) return a vector containing the means of all columns. return a vector containing the sum of the rows. return a vector containing the means of the rows. column and rows access. get a copy of a column. copy a column to the given vector. copy a column back into the matrix. get a copy of a row. copy a row to a given vector. copy a row back into the matrix. return column-wise minimums. return index of minimal element per column. return column-wise maximums. return index of minimal element per column. return row-wise minimums. return index of minimal element per row. return row-wise maximums. return index of minimal element per row. elementwise functions add a row vector to all rows of the matrix (in place). add a row to all rows of the matrix. add a vector to all columns of the matrix (in-place). add a vector to all columns of the matrix. subtract a row vector from all rows of the matrix (in-place). subtract a row vector from all rows of the matrix. subtract a column vector from all columns of the matrix (in-place). subtract a vector from all columns of the matrix. multiply a row by a scalar. multiply a column by a scalar. multiply all columns with a column vector (in-place). multiply all columns with a column vector. multiply all rows with a row vector (in-place). multiply all rows with a row vector. writes out this matrix to the given data stream. the data output stream to write to. @throws ioexception reads in a matrix from the given data stream. note that the old data of this matrix will be discarded. the data input stream to read from. @throws ioexception saves this matrix to the specified file. the file to write the matrix in. @throws ioexception thrown on errors while writing the matrix to the file loads a matrix from a file into this matrix. note that the old data of this matrix will be discarded. the file to read the matrix from @throws ioexception thrown on errors while reading the matrix autogenerated code code for operators overloads for the usual arithmetic operations # def gen_overloads(base, result_rows, result_cols, verb=''); ', '"greater than"'), gen_compare('le', '=', '"greater than or equal"'), gen_compare('eq', '==', 'equality'), gen_compare('ne', '!=', 'inequality'), gen_logical('and', '&', 'logical and'), gen_logical('or', '|', 'logical or'), gen_logical('xor', '^', 'logical xor')) # add a matrix (in place). add a matrix (in place). add a scalar (in place). add a scalar. subtract a matrix (in place). subtract a matrix (in place). subtract a scalar (in place). subtract a scalar. (right-)subtract a matrix (in place). (right-)subtract a matrix (in place). (right-)subtract a scalar (in place). (right-)subtract a scalar. elementwise divide by a matrix (in place). elementwise divide by a matrix (in place). elementwise divide by a scalar (in place). elementwise divide by a scalar. (right-)elementwise divide by a matrix (in place). (right-)elementwise divide by a matrix (in place). (right-)elementwise divide by a scalar (in place). (right-)elementwise divide by a scalar. elementwise multiply by a matrix (in place). elementwise multiply by a matrix (in place). elementwise multiply by a scalar (in place). elementwise multiply by a scalar. matrix-multiply by a matrix (in place). matrix-multiply by a matrix (in place). matrix-multiply by a scalar (in place). matrix-multiply by a scalar. test for "less than" (in-place). test for "less than" (in-place). test for "less than". test for "less than" against a scalar (in-place). test for "less than" against a scalar (in-place). test for "less than" against a scalar. test for "greater than" (in-place). test for "greater than" (in-place). test for "greater than". test for "greater than" against a scalar (in-place). test for "greater than" against a scalar (in-place). test for "greater than" against a scalar. test for "less than or equal" (in-place). test for "less than or equal" (in-place). test for "less than or equal". test for "less than or equal" against a scalar (in-place). test for "less than or equal" against a scalar (in-place). test for "less than or equal" against a scalar. test for "greater than or equal" (in-place). test for "greater than or equal" (in-place). test for "greater than or equal". test for "greater than or equal" against a scalar (in-place). test for "greater than or equal" against a scalar (in-place). test for "greater than or equal" against a scalar. test for equality (in-place). test for equality (in-place). test for equality. test for equality against a scalar (in-place). test for equality against a scalar (in-place). test for equality against a scalar. test for inequality (in-place). test for inequality (in-place). test for inequality. test for inequality against a scalar (in-place). test for inequality against a scalar (in-place). test for inequality against a scalar. compute elementwise logical and (in-place). compute elementwise logical and (in-place). compute elementwise logical and. compute elementwise logical and against a scalar (in-place). compute elementwise logical and against a scalar (in-place). compute elementwise logical and against a scalar. compute elementwise logical or (in-place). compute elementwise logical or (in-place). compute elementwise logical or. compute elementwise logical or against a scalar (in-place). compute elementwise logical or against a scalar (in-place). compute elementwise logical or against a scalar. compute elementwise logical xor (in-place). compute elementwise logical xor (in-place). compute elementwise logical xor. compute elementwise logical xor against a scalar (in-place). compute elementwise logical xor against a scalar (in-place). compute elementwise logical xor against a scalar.  computes x = y + z. computes x += y; x += z rows are contiguous system.err.printf("%d %d matrix process first line process rest actually, this is much harder because the data is not consecutive in memory... this is a bit crazy, but a row vector must have as length as the columns of the matrix. go through file and count columns and rows. what makes this endeavour a bit difficult is that files can have leading or trailing spaces leading to spurious fields after string.split(). go through file a second time process the actual data. rjpp-begin------------------------------------------------------------ rjpp-end--------------------------------------------------------------"
org.jblas.Geometry "general functions which are geometric in nature. for example, computing all pairwise squared distances between all columns of a matrix. compute the pairwise squared distances between all columns of the two matrices. an efficient way to do this is to observe that (x-y)^2 = x^2 - 2xy - y^2 and to then properly carry out the computation with matrices. center a vector (subtract mean from all elements (in-place). center the rows of a matrix (in-place). center the columns of a matrix (in-place). normalize a vector (scale such that its euclidean norm is 1) (in-place). normalize the rows of a matrix (in-place). normalize the columns of a matrix (in-place). compute the pairwise squared distances between all columns of the two matrices. an efficient way to do this is to observe that (x-y)^2 = x^2 - 2xy - y^2 and to then properly carry out the computation with matrices. center a vector (subtract mean from all elements (in-place). center the rows of a matrix (in-place). center the columns of a matrix (in-place). normalize a vector (scale such that its euclidean norm is 1) (in-place). normalize the rows of a matrix (in-place). normalize the columns of a matrix (in-place).  z.print(); begin the code below has been automatically generated. do not edit! z.print(); end"
org.jblas.Info "   "
org.jblas.JavaBlas "to change this template, choose tools | templates and open the template in the editor. implementation of some blas functions, mostly those which require linear runtime in the number of matrix elements. because of the copying overhead when passing primitive arrays to native code, it doesn't make sense for these functions to be implemented in native code. the java code is about as fast. the same conventions were used as in the native code, that is, for each array you also pass an index pointing to the starting index. these methods are mostly optimized for the case where the starting index is 0 and the increment is 1. exchange two vectors. copy dx to dy. compute dy <- da dx + dy. computes dz <- dx + dy compute scalar product between dx and dy. exchange two vectors. copy dx to dy. compute dy <- da dx + dy. computes dz <- dx + dy compute scalar product between dx and dy.  begin the code below has been automatically generated. do not edit! end"
org.jblas.MatrixFunctions "this class provides the functions from java.lang.math for matrices. the functions are applied to each element of the matrix. # def mapfct(f); arccosine function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#acos(doublematrix) matrix # mapfct('math.acos') # applies the trigonometric arcsine function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#asin(doublematrix) matrix # mapfct('math.asin') # applies the trigonometric arctangend function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#atan(doublematrix) matrix # mapfct('math.atan') # applies the cube root function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cbrt(doublematrix) matrix # mapfct('math.cbrt') # element-wise round up by applying the ceil function on each element. note that this is an in-place operation. @see matrixfunctions#ceil(doublematrix) matrix # mapfct('math.ceil') # applies the cosine function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cos(doublematrix) matrix # mapfct('math.cos') # applies the hyperbolic cosine function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cosh(doublematrix) matrix # mapfct('math.cosh') # applies the exponential function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#exp(doublematrix) matrix # mapfct('math.exp') # element-wise round down by applying the floor function on each element. note that this is an in-place operation. @see matrixfunctions#floor(doublematrix) matrix # mapfct('math.floor') # applies the natural logarithm function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#log(doublematrix) matrix # mapfct('math.log') # applies the logarithm with basis to 10 element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#log10(doublematrix) matrix # mapfct('math.log10') # element-wise power function. replaces each element with its power of d.note that this is an in-place operation. the exponent @see matrixfunctions#pow(doublematrix,double) matrix # mapfct('math.signum') # # mapfct('math.sin') # # mapfct('math.sinh') # # mapfct('math.sqrt') # # mapfct('math.tan') # # mapfct('math.tanh') # returns a copy of this matrix where all elements are set to their absolute values. @see matrixfunctions#absi(doublematrix) of this matrix returns a copy of this matrix where the trigonometric acos function is applied element wise. @see matrixfunctions#acosi(doublematrix) of this matrix # %w{abs acos asin atan cbrt ceil cos cosh exp floor log log10 signum sin sinh sqrt tan tanh}.map do |fct| arccosine function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#acos(floatmatrix) matrix # mapfct('math.acos') # applies the trigonometric arcsine function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#asin(floatmatrix) matrix # mapfct('math.asin') # applies the trigonometric arctangend function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#atan(floatmatrix) matrix # mapfct('math.atan') # applies the cube root function element wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cbrt(floatmatrix) matrix # mapfct('math.cbrt') # element-wise round up by applying the ceil function on each element. note that this is an in-place operation. @see matrixfunctions#ceil(floatmatrix) matrix # mapfct('math.ceil') # applies the cosine function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cos(floatmatrix) matrix # mapfct('math.cos') # applies the hyperbolic cosine function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#cosh(floatmatrix) matrix # mapfct('math.cosh') # applies the exponential function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#exp(floatmatrix) matrix # mapfct('math.exp') # element-wise round down by applying the floor function on each element. note that this is an in-place operation. @see matrixfunctions#floor(floatmatrix) matrix # mapfct('math.floor') # applies the natural logarithm function element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#log(floatmatrix) matrix # mapfct('math.log') # applies the logarithm with basis to 10 element-wise on this matrix. note that this is an in-place operation. @see matrixfunctions#log10(floatmatrix) matrix # mapfct('math.log10') # element-wise power function. replaces each element with its power of d.note that this is an in-place operation. the exponent @see matrixfunctions#pow(floatmatrix,float) matrix # mapfct('math.signum') # # mapfct('math.sin') # # mapfct('math.sinh') # # mapfct('math.sqrt') # # mapfct('math.tan') # # mapfct('math.tanh') # returns a copy of this matrix where all elements are set to their absolute values. @see matrixfunctions#absi(floatmatrix) of this matrix returns a copy of this matrix where the trigonometric acos function is applied element wise. @see matrixfunctions#acosi(floatmatrix) of this matrix # %w{abs acos asin atan cbrt ceil cos cosh exp floor log log10 signum sin sinh sqrt tan tanh}.map do |fct| <<-eos public static float #{fct}(float x) { return (float)math.#{fct}(x); } eos end # calculate matrix exponential of a square matrix. a scaled pade approximation algorithm is used. the algorithm has been directly translated from golub & van loan "matrix computations", algorithm 11.3f.1. special horner techniques from 11.2f are also used to minimize the number of matrix multiplications. square matrix exponential of a  rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- constants for pade approximation scaled version of a calculate d and n using special horner techniques u = c0i + c2a^2 + c4a^4 + (c6i + c8a^2 + c10a^4 + c12a^6)a^6 v = c1i + c3a^2 + c5a^4 + (c7i + c9a^2 + c11a^4 + c13a^6)a^6 solve df = n for f now square j times stop start begin the code below has been automatically generated. do not edit! rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- rjpp-begin------------------------------------------------------------ rjpp-end-------------------------------------------------------------- constants for pade approximation scaled version of a calculate d and n using special horner techniques u = c0i + c2a^2 + c4a^4 + (c6i + c8a^2 + c10a^4 + c12a^6)a^6 v = c1i + c3a^2 + c5a^4 + (c7i + c9a^2 + c11a^4 + c13a^6)a^6 solve df = n for f now square j times end"
org.jblas.NativeBlas "native blas and lapack functions. the nativeblas class contains the native blas and lapack functions. each fortran function is mapped to a static method of this class. for each array argument, an additional parameter is introduced which gives the offset from the beginning of the passed array. in c, you would be able to pass a different pointer, but in java, you can only pass the whole array. note that due to the way the jni is usually implemented, the arrays are first copied outside of the jvm before the function is called. this means that functions whose runtime is linear in the amount of memory do usually not run faster just because you are using a native implementation. this holds true for most level 1 blas routines (like vector addition), and unfortunately also for most level 2 blas routines (like matrix-vector multiplication). for these, there exists a class javablas which contains java implementations. in lapack, there exist routines which require workspace to be allocated together with a standard procedure for computing the size of these workspaces. jblas automatically also generates wrappers for these routines with automatic workspace allocation. these routines have the same name, but the workspace arguments are removed. finally, an example: the fortran routine subroutine daxpy(n,da,dx,incx,dy,incy) double precision da integer incx,incy,n double precision dx(),dy()  becomes  public static native void daxpy(int n, double da, double[] dx, int dxidx, int incx, double[] dy, int dyidx, int incy); "
org.jblas.NativeBlasLibraryLoader "help class for loading libraries needed for nativeblas the only use of this class is to have nativeblas inherit from this class. let's do some quick tests to see whether we trigger some errors when dependent libraries cannot be found"
org.jblas.package-info "main linear algebra package. this package contains the linear algebra packages from jblas."
org.jblas.ranges.AllRange "to change this template, choose tools | templates and open the template in the editor. a range over all available indices. can be used to address whole columns or rows. like the ":" index in matlab. don't forget to call init() before using this range."
org.jblas.ranges.IndicesRange "to change this template, choose tools | templates and open the template in the editor. range which varies over pre-specified indices. for example,  int[] indices = new int[] { 1, 1, 2, 3, 5, 8, 13 }; range r = new indicesrange(indices); ranges over the first few fibonacci numbers. initialize from integer array. initialize from doublematrix. entries are converted to integers by truncation."
org.jblas.ranges.IntervalRange "to change this template, choose tools | templates and open the template in the editor. range which varies from a given interval. endpoint is exclusive!  "new intervalrange(0, 3)" enumerates 0, 1, 2. construct new interval range. endpoints are inclusive."
org.jblas.ranges.package-info "provide ways to specify indices ranges."
org.jblas.ranges.PointRange "to change this template, choose tools | templates and open the template in the editor. a pointrange is a range which only has a single point. construct a new pointrange with the one given index."
org.jblas.ranges.Range "to change this template, choose tools | templates and open the template in the editor. the range interface represents basically a set of indices. before using a range you have to call init() with the actually available lower and upper bounds, such that you can also have an "allrange" which contains all possible indices. further operations include:   length() - returns total number of elements.  next() - increase counter (use value()) to retrieve the value.  index() - get the index of the current value.  value() - get the current value.  hasmore() - more indices available.  typical uses look like this:  for (r.init(lower, upper); r.hasmore(); r.next()) { system.out.printf("value number %d is %d%n", index(), value()); } initialize range to available indices total number of indices. increase counter. consecutive numbering of current index. get current index. more indices available?"
org.jblas.ranges.RangeUtils "to change this template, choose tools | templates and open the template in the editor. a bunch of static functions for making construction of ranges more uniform. basically, we have  point(3) - a pointrange. indices(new int[] {1,2,3,...}) - a indices range. interval(1, 2) - an interval range. all() - an allrange. indices(x) - with a doublematrix. find(x) - an index constructed from the non-zero elements of x.  construct point range (constant range) with given index."
org.jblas.SimpleBlas "this class provides a cleaner direct interface to the blas routines by extracting the parameters of the matrices from the matrices itself.  for example, you can just pass the vector and do not have to pass the length, corresponding doublebuffer, offset and step size explicitly.  currently, all the general matrix routines are implemented. blas level 1 compute x  y (swap two matrices) compute x  n, the solution consists only of the first n rows of b. an (m,n) matrix an (max(m,n), k) matrix (well, at least) blas level 1 compute x  y (swap two matrices) compute x  n, the solution consists only of the first n rows of b. an (m,n) matrix an (max(m,n), k) matrix (well, at least)  import edu.ida.core.outputvalue; nativeblas.dswap(x.length, x.data, 0, 1, y.data, 0, 1); nativeblas.dcopy(x.length, x.data, 0, 1, y.data, 0, 1); nativeblas.daxpy(dx.length, da, dx.data, 0, 1, dy.data, 0, 1); return nativeblas.ddot(x.length, x.data, 0, 1, y.data, 0, 1); stop start system.err.printf("gelsd\n"); system.err.printf("m = %d, n = %d, nrhs = %d\n", m, n, nrhs); system.err.printf("smlsiz = %d, nlvl = %d\n", smlsiz, nlvl); system.err.printf("iwork size = %d\n", 3 minmn nlvl + 11 minmn); begin the code below has been automatically generated. do not edit! nativeblas.sswap(x.length, x.data, 0, 1, y.data, 0, 1); nativeblas.scopy(x.length, x.data, 0, 1, y.data, 0, 1); nativeblas.saxpy(dx.length, da, dx.data, 0, 1, dy.data, 0, 1); return nativeblas.sdot(x.length, x.data, 0, 1, y.data, 0, 1); system.err.printf("gelsd\n"); system.err.printf("m = %d, n = %d, nrhs = %d\n", m, n, nrhs); system.err.printf("smlsiz = %d, nlvl = %d\n", smlsiz, nlvl); system.err.printf("iwork size = %d\n", 3 minmn nlvl + 11 minmn); end"
org.jblas.Singular "to change this template, choose tools | templates and open the template in the editor.  compute a singular-value decomposition of a. doublematrix[3] array of u, s, v such that a = u diag(s) v' compute a singular-value decomposition of a (sparse variant). sparse means that the matrices u and v are not square but only have as many columns (or rows) as necessary. doublematrix[3] array of u, s, v such that a = u diag(s) v' compute a singular-value decomposition of a (sparse variant). sparse means that the matrices u and v are not square but only have as many columns (or rows) as necessary. complexdoublematrix[3] array of u, s, v such that a = u diag(s) v compute a singular-value decomposition of a. complexdoublematrix[3] array of u, s, v such that a = u diag(s) v' compute the singular values of a matrix. doublematrix of dimension m n min(m, n) vector of singular values. compute the singular values of a complex matrix. complexdoublematrix of dimension m n real-valued (!) min(m, n) vector of singular values. compute a singular-value decomposition of a. floatmatrix[3] array of u, s, v such that a = u diag(s) v' compute a singular-value decomposition of a (sparse variant). sparse means that the matrices u and v are not square but only have as many columns (or rows) as necessary. floatmatrix[3] array of u, s, v such that a = u diag(s) v' compute a singular-value decomposition of a (sparse variant). sparse means that the matrices u and v are not square but only have as many columns (or rows) as necessary. complexfloatmatrix[3] array of u, s, v such that a = u diag(s) v compute a singular-value decomposition of a. complexfloatmatrix[3] array of u, s, v such that a = u diag(s) v' compute the singular values of a matrix. floatmatrix of dimension m n min(m, n) vector of singular values. compute the singular values of a complex matrix. complexfloatmatrix of dimension m n real-valued (!) min(m, n) vector of singular values. begin the code below has been automatically generated. do not edit! end"
org.jblas.Solve "solving linear equations. solves the linear equation ax = b. solves the linear equation ax = b for symmetric a. solves the linear equation ax = b for symmetric and positive definite a. computes the least squares solution for over or underdetermined linear equations ax = b in the overdetermined case, when m > n, that is, there are more equations than variables, it computes the least squares solution of x -> ||ax - b ||_2. in the underdetermined case, when m  n, that is, there are more equations than variables, it computes the least squares solution of x -> ||ax - b ||_2. in the underdetermined case, when m < n (less equations than variables), there are infinitely many solutions and it computes the minimum norm solution. an (m,n) matrix a (m,k) matrix the minimum norm or least squares solution. computes the pseudo-inverse. note, this function uses the solveleastsquares and might produce different numerical solutions for the underdetermined case than matlab. rectangular matrix p such that apa = a and pap = p.  begin the code below has been automatically generated. do not edit! end"
org.jblas.Trigonometry "container for trigonometric functions on vectors and matrices.  yet to be filled"
org.jblas.util.ArchFlavor "for platforms where it isn't applicable."
org.jblas.util.Functions ""
org.jblas.util.LibraryLoader "class which allows to load a dynamic file as resource (for example, from a jar-file) find the library libname as a resource, copy it to a tempfile and load it using system.load(). the name of the library has to be the base name, it is mapped to the corresponding system name using system.maplibraryname(). for example, the library "foo" is called "libfoo.so" under linux and "foo.dll" under windows, but you just have to pass "foo" the loadlibrary().  i'm not quite sure if this doesn't open all kinds of security holes. any ideas?  this function reports some more information to the "org.jblas" logger at the fine level. basename of the library @throws unsatisfiedlinkerror if library cannot be founds jdk 7 changed the ending for mac os from "jnilib" to "dylib". if that is the case, remap the filename. translate all those windows to "windows". ("windows xp", "windows vista", "windows 7", etc.) compute the path to the library. the path is basically "/" + os.name + "/" + os.arch + "/" + libname. full path without the os name non-unified. try to open a file at the given position. load a system library from a stream. copies the library to a temp file and loads from there. name of the library (just used in constructing the library name) inputstream pointing to the library  preload flavor libraries oh man, have to get out of here! system.getproperty("file.separator"); system.getproperty("file.separator"); leo says 8k block size is standard ;)"
org.jblas.util.Logger ""
org.jblas.util.package-info "support classes for jblas. this package contains several support classes."
org.jblas.util.Permutations "functions which generate random permutations. create a random permutation of the numbers 0, ..., size - 1. see algorithm p, d.e. knuth: the art of computer programming, vol. 2, p. 145 get a random sample of k out of n elements. see algorithm s, d. e. knuth, the art of computer programming, vol. 2, p.142. create a permutation matrix from a lapack-style 'ipiv' vector. row i was interchanged with row ipiv[i] create a permutation matrix from a lapack-style 'ipiv' vector. row i was interchanged with row ipiv[i]  system.out.printf("size = %d n = %d\n", size, n); for (int i = 0; i < n; i++) system.out.printf("ipiv[%d] = %d\n", i, ipiv[i]); system.out.printf("size = %d n = %d\n", size, n); for (int i = 0; i < n; i++) system.out.printf("ipiv[%d] = %d\n", i, ipiv[i]);"
org.jblas.util.Random ""
org.jblas.util.SanityChecks "run a few sanity checks on the installation to see whether everything runs as expected. check whether vector addition works. this is pure java code and should work. check matrix multiplication. this is already atlas/blas code. check whether error handling works. if it works, you should see an ok, otherwise, you might see the actual error message and then the program exits. compute eigenvalues. this is a routine not in atlas, but in the original lapack. complexdoublematrix[] azb = org.jblas.singular.sparsesvd(new complexdoublematrix(data)); system.out.println(azb[0].tostring()); system.out.println(azb[1].tostring()); system.out.println(azb[2].tostring());  shouldn't happen"
